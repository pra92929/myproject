CREATE OR REPLACE FUNCTION c_orderline_trg()
  RETURNS trigger AS
$BODY$ DECLARE 

/*************************************************************************
  * The contents of this file are subject to the Compiere Public
  * License 1.1 ("License"); You may not use this file except in
  * compliance with the License. You may obtain a copy of the License in
  * the legal folder of your Openbravo installation.
  * Software distributed under the License is distributed on an
  * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing rights
  * and limitations under the License.
  * The Original Code is  Compiere  ERP &  Business Solution
  * The Initial Developer of the Original Code is Jorg Janke and ComPiere, Inc.
  * Portions created by Jorg Janke are Copyright (C) 1999-2001 Jorg Janke,
  * parts created by ComPiere are Copyright (C) ComPiere, Inc.;
  * All Rights Reserved.
  * Contributor(s): Openbravo SLU
  * Contributions are Copyright (C) 2001-2015 Openbravo, S.L.U.
  *
  * Specifically, this derivative work is based upon the following Compiere
  * file and version.
  *************************************************************************/

  v_newTaxBaseAmt NUMERIC;
  v_oldTaxBaseAmt NUMERIC;
  v_oldLine NUMERIC:= 0;
  v_newLineNetAmt NUMERIC:= 0;
  v_newLineAlternate NUMERIC:= 0;
  v_taxAmt NUMERIC:= 0;
  v_BaseAmount C_TAX.BASEAMOUNT%TYPE;
  v_HasTaxLine  BOOLEAN := FALSE;
  v_Prec   NUMERIC;
  v_ID   VARCHAR(32); --OBTG:VARCHAR2--
  v_Processed  VARCHAR(60);
  v_UOM_ID    VARCHAR(32); --OBTG:VARCHAR2--
  v_IsSOTrx CHAR(1);
  v_Count NUMERIC;
  v_taxBaseAmt NUMERIC;
  v_rate NUMERIC;
  v_isSummary CHAR(1);
  xTaxAmt NUMERIC:=0;
  v_reservation_id    VARCHAR(32); --OBTG:VARCHAR2--
  v_prereservedqty    NUMERIC;
  v_IsWithholding_Tax C_Tax.IsWithholdingTax%TYPE;
  v_IsCashVAT_Tax C_Tax.IsCashVAT%TYPE;
  v_IsCashVAT_Order C_Order.IsCashVAT%TYPE;
  v_Rate_Tax C_Tax.Rate%TYPE;
  v_Prdct_Base_UOM VARCHAR(32);
BEGIN
    
    IF AD_isTriggerEnabled()='N' THEN IF TG_OP = 'DELETE' THEN RETURN OLD; ELSE RETURN NEW; END IF; 
    END IF;

 
IF (TG_OP = 'UPDATE') THEN
  IF NOT(COALESCE(old.M_Product_ID,'0') <> COALESCE(NEW.M_Product_ID,'0')
  OR COALESCE(old.LineNetAmt,0) <> COALESCE(NEW.LineNetAmt,0)
  OR COALESCE(old.FreightAmt,0) <> COALESCE(NEW.FreightAmt,0)
  OR COALESCE(old.ChargeAmt,0) <> COALESCE(NEW.ChargeAmt,0)
  OR COALESCE(old.C_Tax_ID,'0') <> COALESCE(NEW.C_Tax_ID,'0')
  OR COALESCE(old.C_Uom_ID,'0') <> COALESCE(NEW.C_Uom_ID,'0')
  OR COALESCE(old.qtyOrdered,0) <> COALESCE(NEW.qtyOrdered,0)
  OR COALESCE(old.PriceActual,0) <> COALESCE(NEW.PriceActual,0)
  --Added by Usha
   OR COALESCE(old.em_exs_user_qty,0) <> COALESCE(NEW.em_exs_user_qty,0)
  OR COALESCE(old.em_exs_unitprice,0) <> COALESCE(NEW.em_exs_unitprice,0)
  OR COALESCE(old.em_exs_user_uom_id,'0') <> COALESCE(NEW.em_exs_user_uom_id,'0')
    OR COALESCE(old.em_exs_discounttype,'0') <> COALESCE(NEW.em_exs_discounttype,'0')
  OR COALESCE(old.em_exs_discountvalue,0) <> COALESCE(NEW.em_exs_discountvalue,0))

  --Ends by Usha
 THEN
  IF TG_OP = 'DELETE' THEN RETURN OLD; ELSE RETURN NEW; END IF; 
  END IF;
 END IF;
 /**
  * Check Product changes = not possible when reservation, invoice or delivery exists
  */
 IF (TG_OP = 'DELETE') THEN
  IF (old.QtyReserved <> 0 AND old.C_ORDER_DISCOUNT_ID IS NULL) THEN
   RAISE EXCEPTION '%', '@20200@' || ' ' ||old.QtyReserved; --OBTG:-20000--
  ELSIF (old.QtyDelivered <> 0) THEN
   RAISE EXCEPTION '%', '@20201@' || ' ' || old.QtyDelivered; --OBTG:-20000--
  ELSIF (old.QtyInvoiced <> 0) THEN
   RAISE EXCEPTION '%', '@20202@' || ' ' || old.QtyInvoiced; --OBTG:-20000--
  END IF;
  -- Check if reservation exists to delete it first.
  SELECT issotrx INTO v_IsSOTrx
  FROM c_order
  WHERE c_order_id = old.c_order_id;
  IF (v_issotrx = 'Y') THEN
    SELECT count(*) INTO v_count
    FROM m_reservation 
    WHERE c_orderline_id = OLD.c_orderline_id;
    IF (v_count > 0) THEN
      RAISE EXCEPTION '%', '@DeleteRelatedReservation@'; --OBTG:-20000--
    END IF;
  ELSE
    DELETE FROM m_reservation_stock
    WHERE c_orderline_id = OLD.c_orderline_id;
  END IF;
 ELSIF (TG_OP = 'UPDATE') THEN
   SELECT issotrx INTO v_IsSOTrx
   FROM c_order
   WHERE c_order_id = old.c_order_id;
   SELECT count(*) INTO v_count
    FROM m_reservation 
    WHERE c_orderline_id = OLD.c_orderline_id;
   IF (old.M_Product_ID <> NEW.M_Product_ID) THEN
     IF (old.QtyReserved <> 0) THEN
       RAISE EXCEPTION '%', '@20203@' || ' ' || old.QtyReserved; --OBTG:-20000--
     ELSIF (old.QtyDelivered <> 0) THEN
       RAISE EXCEPTION '%', '@20204@' || ' ' || old.QtyDelivered; --OBTG:-20000--
     ELSIF (old.QtyInvoiced <> 0) THEN
       RAISE EXCEPTION '%', '@20205@' || ' ' || old.QtyInvoiced; --OBTG:-20000--
     ELSIF (v_IsSOTrx = 'N') THEN
       SELECT count(*) INTO v_Count
       FROM m_inoutline
       WHERE c_orderline_id = old.c_orderline_id;
       IF (v_count > 0) THEN
         RAISE EXCEPTION '%', '@20206@'; --OBTG:-20000--
       END IF;
       SELECT count(*) INTO v_count
       FROM m_requisitionorder
       WHERE c_orderline_id = old.c_orderline_id;
       IF (v_count > 0) THEN
         RAISE EXCEPTION '%', '@ProductChangeLineInRequisition@'; --OBTG:-20000--
       END IF;
     -- Looks for a draft reservation for the order line and change its product
     ELSIF (v_count > 0) THEN
       SELECT count(*) INTO v_count
       FROM m_reservation 
       WHERE c_orderline_id = OLD.c_orderline_id
       AND res_status = 'DR';
       IF (v_count > 0) THEN
         SELECT max(m_reservation_id) INTO v_reservation_id
         FROM m_reservation 
         WHERE c_orderline_id = OLD.c_orderline_id
         AND m_product_id = OLD.m_product_id
         AND res_status = 'DR';
         DELETE FROM m_reservation_stock
         WHERE m_reservation_id = v_reservation_id;
         UPDATE m_reservation
         SET m_product_id = NEW.M_Product_ID
         WHERE m_reservation_id = v_reservation_id;
       ELSE
         RAISE EXCEPTION '%', '@ProductChangeLineInReservation@'; --OBTG:-20000--
       END IF;
     END IF;
   END IF;
 END IF;

 -- Get ID
 IF (TG_OP = 'UPDATE' OR TG_OP = 'INSERT') THEN
     IF (NEW.M_PRODUCT_ID IS NOT NULL) THEN
       SELECT C_UOM_ID INTO v_UOM_ID FROM M_PRODUCT WHERE M_PRODUCT_ID=NEW.M_PRODUCT_ID;
       IF (COALESCE(v_UOM_ID,'0') <> COALESCE(NEW.C_UOM_ID,'0')) THEN
         RAISE EXCEPTION '%', '@20111@'; --OBTG:-20000--
       END IF;
     END IF;
  v_ID := new.C_Order_ID;
 ELSE
  v_ID := old.C_Order_ID;
 END IF;

 SELECT StdPrecision
 INTO v_Prec
 FROM C_Currency, C_Order
 WHERE C_Currency.C_Currency_ID = C_Order.C_Currency_ID
 AND C_Order_ID = v_ID;
 /**
  * Round Base
  */
    IF (v_issotrx = 'Y') THEN
v_Prec :=0.00;
END IF;
 --v_Prec := 2;
 IF (TG_OP = 'INSERT' OR TG_OP = 'UPDATE') THEN

   --Added by Tirumala
   
     IF(NEW.em_exs_rate_weight = 'Y' ) THEN
     IF(NEW.EM_Exs_Totalweight IS NOT NULL OR NEW.EM_Exs_Totalweight <>0) THEN



      NEW.EM_Exs_Avgweight := NEW.EM_Exs_Totalweight / new.em_exs_user_qty;

      new.em_exs_unitprice := NEW.EM_Exs_Avgweight  * new.PriceList;

      END IF; --ends IF(NEW.EM_Exs_Totalweight IS NOT NULL OR NEW.EM_Exs_Totalweight <>0)
      END IF; -- ends IF(NEW.em_exs_rate_weight = 'Y' )



   --Ended by Tirumala

      -- Modified by I.Ciordia. Sometimes js fails calculting lineNet
 -- new.LineNetAmt := ROUND(new.QtyOrdered*new.PriceActual, v_Prec);-- Modified by I.Ciordia
   --Added by usha
   --Discount logic

    IF (NEW.em_exs_isdiscount = 'Y' ) THEN
   IF(new.em_exs_discounttype IS NOT NULL AND (new.em_exs_discountvalue IS NOT NULL OR new.em_exs_discountvalue<>0))THEN
IF(new.em_exs_discounttype='Value')THEN
new.em_exs_unitprice := (new.PriceList*new.em_exs_user_qty-new.em_exs_discountvalue)/new.em_exs_user_qty;
--new.PriceList :=new.em_exs_unitprice;
ELSIF(new.em_exs_discounttype='Percentage')THEN
new.em_exs_unitprice :=new.PriceList-new.PriceList*(new.em_exs_discountvalue/100);
ELSIF(new.em_exs_discounttype='Quantity')THEN
new.em_exs_unitprice :=(new.PriceList-new.em_exs_discountvalue);

--raise exception '%',COALESCE((new.em_exs_discountvalue/100),0);

--new.PriceList :=new.em_exs_unitprice;

END IF;--ENDs IF(new.em_exs_discounttype='Value')THEN


    END IF;--Ends IF(new.em_exs_discounttype IS NOT NULL AND (new.em_exs_discountvalue IS NOT NULL OR new.em_exs_discountvalue<>0))
   END IF; -- Ends     IF (NEW.em_exs_isdiscount = 'Y' )
    
  IF(new.em_exs_unitprice IS NULL OR new.em_exs_unitprice<>0  AND new.em_exs_user_qty IS NULL AND new.em_exs_user_uom_id IS NULL)THEN 

  new.em_exs_unitprice := new.PRICEACTUAL;
  new.em_exs_user_qty :=new.QtyOrdered;
  new.em_exs_user_uom_id :=new.C_UOM_ID;

  END IF;
    new.PRICEACTUAL := new.em_exs_unitprice;
   new.LineNetAmt := ROUND(new.em_exs_user_qty*new.em_exs_unitprice, v_Prec);
   new.em_exs_user_totalval_atax := ROUND(new.em_exs_user_qty*new.em_exs_unitprice, v_Prec);
--Get Product Base UOM
   SELECT C_UOM_ID INTO v_Prdct_Base_UOM From M_Product Where M_Product_ID=new.M_Product_ID;

   IF(new.em_exs_user_uom_id = v_Prdct_Base_UOM)THEN
      new.C_UOM_ID := new.em_exs_user_uom_id;
      new.QtyOrdered := new.em_exs_user_qty;

   ELSE
 
       new.C_UOM_ID := v_Prdct_Base_UOM;
       new.QtyOrdered := c_uom_convert(new.em_exs_user_qty,new.em_exs_user_uom_id,v_Prdct_Base_UOM, to_char(v_Prec));
  
    END IF;--End  IF(new.em_exs_user_uom_id == v_Prdct_Base_UOM)THEN  
--Update condition tab
UPDATE expur_condition SET updated=TO_DATE(now()),updatedby=new.updatedby where c_orderline_id=new.c_orderline_id;
  --Ends by Usha
  new.FreightAmt := ROUND(new.FreightAmt, v_Prec);
  new.ChargeAmt := ROUND(new.ChargeAmt, v_Prec);
  
  --IF (round(to_number(NEW.QTYORDERED) * to_number(NEW.PRICEACTUAL),v_Prec) != to_number(NEW.LINENETAMT)) THEN
  --Added by Usha
  IF (round(to_number(NEW.em_exs_user_qty) * to_number(NEW.em_exs_unitprice),v_Prec) != to_number(NEW.LINENETAMT)) THEN
  --Ends Added by usha
      RAISE EXCEPTION '%', '@LineAmountNotCorrect@' ; --OBTG:-20000--
    END IF;
 END IF;

 -- Update C_Order.IsCashVAT flag from the line tax rate.
 -- We do it this way to force any process that creates Orders to properly set the C_Order.IsCashVAT
 -- If a user manually changes the tax rate when entering a line, the order's header IsCash VAT may change
 -- This will just work for not withholding tax rates
 IF (TG_OP = 'INSERT' OR TG_OP = 'UPDATE') THEN
  IF (NEW.C_TAX_ID IS NOT NULL) THEN
   SELECT COALESCE(iswithholdingtax, 'N'), COALESCE(IsCashVAT, 'N'), COALESCE(rate, 0)
   INTO v_IsWithholding_Tax, v_IsCashVAT_Tax, v_Rate_Tax
   FROM C_Tax
   WHERE C_Tax_ID=NEW.C_Tax_ID;

   IF (v_IsWithholding_Tax='N' AND v_Rate_Tax<>0) THEN
    SELECT COALESCE(IsCashVAT, 'N')
    INTO v_IsCashVAT_Order
    FROM C_Order
    WHERE C_Order_ID=NEW.C_Order_ID;

    IF (v_IsCashVAT_Tax <> v_IsCashVAT_Order) THEN
      UPDATE C_Order
      SET IsCashVAT = v_IsCashVAT_Tax
      WHERE C_Order_ID=NEW.C_Order_ID;
    END IF;
   END IF;
  END IF;
 END IF;

IF TG_OP = 'DELETE' THEN RETURN OLD; ELSE RETURN NEW; END IF; 

END 

; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION c_orderline_trg()
  OWNER TO tad;
 
















--Function: c_taxpayment_post(character varying)

-- DROP FUNCTION c_taxpayment_post(character varying);

CREATE OR REPLACE FUNCTION c_taxpayment_post(p_pinstance_id character varying)
  RETURNS void AS
$BODY$ DECLARE 
/*************************************************************************
* The contents of this file are subject to the Openbravo  Public  License
* Version  1.1  (the  "License"),  being   the  Mozilla   Public  License
* Version 1.1  with a permitted attribution clause; you may not  use this
* file except in compliance with the License. You  may  obtain  a copy of
* the License at http://www.openbravo.com/legal/license.html
* Software distributed under the License  is  distributed  on  an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
* License for the specific  language  governing  rights  and  limitations
* under the License.
* The Original Code is Openbravo ERP.
* The Initial Developer of the Original Code is Openbravo SLU
* All portions are Copyright (C) 2001-2012 Openbravo SLU
* All Rights Reserved.
* Contributor(s):  ______________________________________.
************************************************************************/
v_resultstr VARCHAR(2000) := ''; --OBTG:VARCHAR2--
v_message VARCHAR(200) := ''; --OBTG:VARCHAR2--
v_record_ID VARCHAR(32); --OBTG:VARCHAR2--
v_result NUMERIC:= 1;
-- Success
v_total NUMERIC;
v_c_settlement_cancel_ID VARCHAR(32); --OBTG:VARCHAR2--
-- Parameter
--TYPE record IS REFCURSOR;
cur_parameter record;
cur_registertype record;
cur_line record;
--Added by Ashutosh
cur_trxorg record;
cur_jline record;
v_totalcr numeric;
v_totaldr numeric;
v_totaldrv numeric;
v_totalcrv numeric;
v_em_exfm_barea VARCHAR(32);
-- Record Info
v_client_ID VARCHAR(32); --OBTG:VARCHAR2--
v_org_ID VARCHAR(32); --OBTG:VARCHAR2--
v_updatedby c_taxpayment.updatedby%TYPE;
v_createdby c_taxpayment.createdby%TYPE;
v_processed c_taxpayment.processed%TYPE;

v_taxtotalamt NUMERIC;
v_prevvatcredit NUMERIC;
v_paymentamt NUMERIC;
v_paymentcreditamt NUMERIC;
v_paymentdebitamt NUMERIC;
v_isreceipt VARCHAR(1); --OBTG:VARCHAR2--
v_ispayment VARCHAR(1); --OBTG:VARCHAR2--
v_posted VARCHAR(60);

v_taxamtfromreglines NUMERIC;

v_taxregistertotal NUMERIC;

v_date TIMESTAMP;
v_settlementid VARCHAR(32); --OBTG:varchar2--
v_settlementdoctype_ID VARCHAR(32); --OBTG:VARCHAR2--
v_sdocumentno VARCHAR(40);
v_debtpaymentid VARCHAR(32); --OBTG:varchar2--
v_debtpaymentbalancingid VARCHAR(32); --OBTG:varchar2--
v_paymentrule VARCHAR(30); --OBTG:VARCHAR2--
v_bpartner_ID VARCHAR(32); --OBTG:VARCHAR2--


v_gl_journalbatchid VARCHAR(32); --OBTG:varchar2--
v_gljbdocumentno VARCHAR(40);
v_gl_journaldoctype_ID VARCHAR(32); --OBTG:VARCHAR2--
v_gl_journalid VARCHAR(32); --OBTG:varchar2--
v_gljdocumentno VARCHAR(40);
v_gl_journallineid VARCHAR(32); --OBTG:varchar2--
v_line NUMERIC;
v_validcombination_ID VARCHAR(32); --OBTG:VARCHAR2--

v_glitem_acct VARCHAR(32); --OBTG:VARCHAR2--
v_glitem_ID VARCHAR(32); --OBTG:VARCHAR2--

v_debit NUMERIC;
v_credit NUMERIC;
 v_totaldebit NUMERIC;
v_totalcredit NUMERIC;


v_acctschema_ID VARCHAR(32); --OBTG:VARCHAR2--
v_calendar_ID VARCHAR(32); --OBTG:VARCHAR2--
v_currency_ID VARCHAR(32); --OBTG:VARCHAR2--
v_currencyratetype VARCHAR(30); --OBTG:VARCHAR2--
v_gl_category_ID VARCHAR(32); --OBTG:VARCHAR2--
v_period_ID VARCHAR(32); --OBTG:VARCHAR2--
v_gl_category_count  NUMERIC;

v_name VARCHAR(255); --OBTG:NVARCHAR2--
v_TRTcountY  NUMERIC;
v_TRTcountN  NUMERIC;
v_DBA_ErrorLog_ID VARCHAR(32); --OBTG:VARCHAR2--
v_dummy VARCHAR(2000); --OBTG:VARCHAR2--
v_count NUMERIC:=0;
v_FIN_PAYMENT_ID VARCHAR(32); --OBTG:VARCHAR2--
v_FIN_PAYMENT_DETAIL_ID VARCHAR(32); --OBTG:VARCHAR2--
v_FIN_FINACC_TRANSACTION_ID VARCHAR(32); --OBTG:VARCHAR2--
v_PaymentDocType_ID VARCHAR(32); --OBTG:VARCHAR2--
v_PaymentDocumentNo FIN_PAYMENT.DOCUMENTNO%TYPE;
v_Financial_Account_ID VARCHAR(32); --OBTG:VARCHAR2--
v_PaymentMethod_ID VARCHAR(32); --OBTG:VARCHAR2--
v_CreateFinTransaction FIN_FINACC_PAYMENTMETHOD.AUTOMATIC_RECEIPT%TYPE;
v_ExecutionType FIN_FINACC_PAYMENTMETHOD.PAYIN_EXECUTION_TYPE%TYPE;

BEGIN
  --  Update AD_PInstance
    RAISE NOTICE '%','Updating PInstance - Processing ' || p_pinstance_id;
    v_resultstr := 'PInstanceNotFound';
    PERFORM AD_UPDATE_PINSTANCE(p_pinstance_id,   NULL,   'Y',   NULL,   NULL);
    -- Get Parameters
    v_resultstr := 'ReadingParameters';
    FOR cur_parameter IN
      (SELECT i.record_id,
         i.ad_user_id,
         p.parametername,
         p.p_string,
         p.p_number,
         p.p_date
       FROM ad_pinstance i LEFT JOIN ad_pinstance_para p ON i.ad_pinstance_id = p.ad_pinstance_id
       WHERE i.ad_pinstance_id = p_pinstance_id
       ORDER BY p.seqno)
    LOOP
      v_record_id := cur_parameter.record_id;
    END LOOP;

    -- Get Parameter
    RAISE NOTICE '%','  v_Record_ID=' || v_record_id;

    BEGIN
      -- BODY

      select dateto, ad_client_id, ad_org_id, createdby, updatedby, generatepayment, c_acctschema_id, c_currency_id, name, C_BPARTNER_ID, processed,em_exfm_barea
        into v_date, v_client_id, v_org_id, v_createdby, v_updatedby, v_ispayment, v_acctschema_id, v_currency_id, v_name, v_bpartner_id, v_processed,v_em_exfm_barea
        from c_taxpayment
        where c_taxpayment_id=v_record_id;

      select count(*) 
      into v_gl_category_count
      from gl_category 
      where ad_isorgincluded(v_org_id, gl_category.ad_org_id, v_client_id)<>-1
      AND gl_category.ad_client_id = v_client_id
      and gl_category.categorytype = 'M';

      if (v_gl_category_count>0) then
          select max(gl_category_id)
          into v_gl_category_id
          from    (select gl_category_id
		  from gl_category 
		  where gl_category.categorytype = 'M'
		  AND ad_isorgincluded(v_org_id, gl_category.ad_org_id, v_client_id)<>-1
		  AND gl_category.ad_client_id = v_client_id
		  order by isdefault desc) tmp;
      else
          RAISE EXCEPTION '%', '@OrgForManualGLCategory@'; --OBTG:-20000--
      end if;
   

        v_paymentrule := 'T';
        v_currencyratetype := 'S';

      select c_calendar_id into v_calendar_ID
      from ad_org
      where ad_org_id = ad_org_getcalendarowner(v_org_id);

      select c_period_id into v_period_id
      from c_period
      where enddate = (select max(enddate) from c_period where enddate <=v_date
                      and exists (select 1 from c_year where c_calendar_id = v_calendar_ID
                    and c_period.c_year_id = c_year.c_year_id))
      and exists (select 1 from c_year where c_calendar_id = v_calendar_ID
                    and c_period.c_year_id = c_year.c_year_id);

     --start processing

     update c_taxpayment
     set processing='Y' where c_taxpayment_id=v_record_id;

     --unprocess
     if v_processed='Y' then
      begin

      select tp.gl_journal_id ,  gljb.gl_journalbatch_id, tp.c_settlement_id, tp.fin_payment_id
      into v_gl_journalid, v_gl_journalbatchid, v_settlementid, v_FIN_PAYMENT_ID
      from c_taxpayment tp
      inner join gl_journal glj on tp.gl_journal_id=glj.gl_journal_id
      inner join gl_journalbatch gljb on gljb.gl_journalbatch_id=glj.gl_journalbatch_id
      where tp.C_TAXPAYMENT_ID = v_record_id;

      update gl_journal set docaction='RE' where gl_journal_id=v_gl_journalid;
      select posted into v_posted from gl_journal where gl_journal_id=v_gl_journalid;
      if v_posted = 'Y' then
       RAISE EXCEPTION '%', '@GLJournalDocumentPosted@' ; --OBTG:-20000--
       end if;
      PERFORM GL_JOURNAL_POST(null, v_gl_journalid);
        update c_taxpayment set gl_journal_id=null where c_taxpayment.C_TAXPAYMENT_ID = v_record_id;
        delete from gl_journalline where gl_journal_id=v_gl_journalid;
        delete from gl_journal where gl_journal_id=v_gl_journalid;
        delete from gl_journalbatch where gl_journalbatch_id=v_gl_journalbatchid;

      if v_ispayment = 'Y' then
        SELECT COUNT(1) INTO v_count
        FROM ad_preference
        WHERE property = 'FinancialManagement'
	  AND ad_module_id <> '0';
        IF (v_count > 0) THEN
	  v_dummy := AD_GET_PREFERENCE_VALUE('FinancialManagement', 'Y', v_client_id, v_org_id, NULL, NULL, NULL);
        ELSIF (v_count = 0) THEN
	  PERFORM C_SETTLEMENT_POST(null, v_settlementid);
	  update c_taxpayment set c_settlement_id=null where c_taxpayment.C_TAXPAYMENT_ID = v_record_id;
	  delete from c_debt_payment_balancing where c_debt_payment_id in
	  (select c_debt_payment_id from c_debt_payment where c_settlement_generate_id = v_settlementid);
	  delete from c_debt_payment where c_settlement_generate_id = v_settlementid;
	  delete from c_settlement where c_settlement_id=v_settlementid;
	end if;
      end if;
    end;
    end if;


   if v_processed='N' then
   begin
       --gl journal
        SELECT * INTO  v_gl_journalbatchid FROM ad_sequence_next('GL_JournalBatch', v_record_id);
        SELECT * INTO  v_gljbdocumentno FROM ad_sequence_doc('DocumentNo_GL_JournalBatch', v_client_id, 'Y');

        insert
        into gl_journalbatch (gl_journalbatch_id,   ad_client_id,   ad_org_id,   isactive,   created,   createdby,   updated,   updatedby,   documentno, description, postingtype,   datedoc,   dateacct, c_period_id, c_currency_id)
        values (v_gl_journalbatchid, v_client_id, v_org_id,'Y', TO_DATE(NOW()), v_createdby, TO_DATE(NOW()), v_updatedby, v_gljbdocumentno, v_name, 'A', v_date, v_date, v_period_id, v_currency_id);

        v_gl_journaldoctype_id := ad_get_doctype(v_client_id,   v_org_id,   to_char('GLJ'));
        SELECT * INTO  v_gl_journalid FROM ad_sequence_next('GL_Journal', v_record_id);
        SELECT * INTO  v_gljdocumentno FROM ad_sequence_doctype(v_gl_journaldoctype_id, v_record_id, 'Y');

        insert
        into gl_journal (gl_journal_id,   ad_client_id,   ad_org_id,   isactive,   created,   createdby,   updated,   updatedby, c_acctschema_id, 
        c_doctype_id, documentno, docstatus, docaction, isapproved,description, postingtype, gl_category_id,   datedoc,   dateacct, c_period_id, 
        c_currency_id, currencyratetype, gl_journalbatch_id,em_exfm_c_taxpayment_id)
        values (v_gl_journalid, v_client_id, v_org_id,'Y', TO_DATE(NOW()), v_createdby, TO_DATE(NOW()), v_updatedby, v_acctschema_id, 
        v_gl_journaldoctype_id, v_gljdocumentno, 'DR', 'CO', 'Y', v_name, 'A', v_gl_category_id, v_date, v_date, v_period_id, 
        v_currency_id, v_currencyratetype, v_gl_journalbatchid,v_record_id);

      v_line:=0;
      v_totaldebit:=0;
      v_totalcredit:=0;

      for cur_line in
      (select
      ttl.c_tax_id,
      tt.issotrx,
      case when tt.issotrx='Y' then ta.t_due_acct else ta.t_credit_acct end as acct_id
      from c_taxregister_type_lines ttl
      inner join c_taxregister_type tt on ttl.c_taxregister_type_id=tt.c_taxregister_type_id
      inner join c_tax_acct ta on ta.c_tax_id=ttl.c_tax_id
      where tt.isactive='Y' and ttl.isactive='Y' and ta.isactive='Y' and ta.c_acctschema_id = v_acctschema_id
      group by ttl.c_tax_id, tt.issotrx, case when tt.issotrx='Y' then ta.t_due_acct else ta.t_credit_acct end)

      loop --move the sum over
      
      for cur_trxorg in
      (select sum(trl.taxamt) as taxAmt,trl.em_exfm_trx_org_id as trxOrg
      from c_taxregisterline trl
      inner join c_taxregister tr on tr.c_taxregister_id=trl.c_taxregister_id
      inner join c_taxregister_type trt on trt.c_taxregister_type_id=tr.c_taxregister_type_id
      where trl.c_tax_id=cur_line.c_tax_id
      and trt.issotrx=cur_line.issotrx
      and tr.c_taxpayment_id=v_record_id
      group by trl.em_exfm_trx_org_id)
	
      loop
	v_taxamtfromreglines:=cur_trxorg.taxAmt;

      SELECT * INTO  v_gl_journallineid FROM ad_sequence_next('GL_JournalLine', v_record_id);


      if v_taxamtfromreglines is null then
      v_taxamtfromreglines := 0;
      end if;

      if cur_line.issotrx='N'  then
      v_credit := v_taxamtfromreglines;
      v_debit := 0;
      else
      v_credit := 0;
      v_debit := v_taxamtfromreglines;
      end if;

      if v_taxamtfromreglines <> 0 then
      begin
      v_line := v_line + 10;
      insert
      into gl_journalline(gl_journalline_id,   ad_client_id,   ad_org_id,   isactive,   created,
         createdby,   updated,   updatedby, gl_journal_id, line, c_currency_id, currencyratetype,
          dateacct, c_validcombination_id, AMTSOURCEDR, AMTSOURCECR, AMTACCTDR, AMTACCTCR,em_exfm_trxorg,c_tax_id)
      values
      (v_gl_journallineid, v_client_id, v_org_id,'Y', TO_DATE(NOW()), v_createdby, TO_DATE(NOW()),
       v_updatedby, v_gl_journalid, v_line, v_currency_id, v_currencyratetype, v_date, cur_line.acct_id,
        v_debit, v_credit, v_debit, v_credit,cur_trxorg.trxOrg,cur_line.c_tax_id);
      end;
      end if;
	
      v_totaldebit := v_totaldebit+v_credit;
      v_totalcredit := v_totalcredit+v_debit;
	end loop;
      end loop;
/*--Added by Asutosh
v_totaldrv:=0;
v_totalcrv:=0;
   for cur_jline in
	(select distinct em_exfm_trxorg,c_tax_id,sum(amtsourcedr) as dr,sum(amtsourcecr) as cr
	from gl_journalline where gl_journal_id = v_gl_journalid
	group by em_exfm_trxorg,c_tax_id)
	
loop 
select case when tt.issotrx='N' then max(glitem_credit_acct) else max(glitem_debit_acct) end, max(tt.c_glitem_id)
      into v_glitem_acct, v_glitem_id
      from c_taxregister_type tt
      inner join c_glitem_acct gia on gia.c_glitem_id=tt.c_glitem_id
      where tt.isactive='Y' and gia.isactive='Y' and tt.issotrx= case when cur_jline.cr-cur_jline.dr > 0 then 'Y' else 'N' end
      group by tt.issotrx;

	if cur_jline.cr-cur_jline.dr > 0 
	then 
	v_totaldr:=cur_jline.cr-cur_jline.dr;
	v_totalcr:=0;

v_line := v_line + 10;
SELECT * INTO  v_gl_journallineid FROM ad_sequence_next('GL_JournalLine', v_record_id);

     insert
     into gl_journalline(gl_journalline_id,   ad_client_id,   ad_org_id,   isactive,   created,
     createdby,   updated,   updatedby, gl_journal_id,line, c_currency_id, currencyratetype, dateacct,
     c_validcombination_id, AMTSOURCEDR, AMTSOURCECR, AMTACCTDR, AMTACCTCR,em_exfm_trxorg)
    values (v_gl_journallineid,v_client_id,v_org_id,'Y',TO_DATE(NOW()),v_createdby,TO_DATE(NOW()),
     v_updatedby, v_gl_journalid,v_line, v_currency_id, v_currencyratetype, v_date, v_glitem_acct,
     v_totaldr, v_totalcr, v_totaldr, v_totalcr,cur_jline.em_exfm_trxorg);

else
	v_totalcr:=cur_jline.dr-cur_jline.cr;
	v_totaldr:=0;

v_line := v_line + 10;
SELECT * INTO  v_gl_journallineid FROM ad_sequence_next('GL_JournalLine', v_record_id);
--raise exception '%',v_totalcr;
     insert
     into gl_journalline(gl_journalline_id,   ad_client_id,   ad_org_id,   isactive,   created,
     createdby,   updated,   updatedby, gl_journal_id,line, c_currency_id, currencyratetype, dateacct,
     c_validcombination_id, AMTSOURCEDR, AMTSOURCECR, AMTACCTDR, AMTACCTCR,em_exfm_trxorg)
    values (v_gl_journallineid,v_client_id,v_org_id,'Y',TO_DATE(NOW()),v_createdby,TO_DATE(NOW()),
     v_updatedby, v_gl_journalid,v_line, v_currency_id, v_currencyratetype, v_date, v_glitem_acct,
     v_totaldr, v_totalcr, v_totaldr, v_totalcr,cur_jline.em_exfm_trxorg);

	end if;
v_totaldrv:=v_totaldrv+v_totaldr;
v_totalcrv:=v_totalcrv+v_totalcr;

end loop;*/
--raise exception '%','v_totaldrv'||v_totaldrv || 'v_totalcrv'||v_totalcrv;

      select count(*)
      into v_TRTcountY
      from c_taxregister_type tt where tt.issotrx='Y';

      select count(*)
      into v_TRTcountN
      from c_taxregister_type tt where tt.issotrx='N';

      if v_TRTcountY=0 or v_TRTcountN=0 then
      RAISE EXCEPTION '%', '@TwoRegisterTypesNeeded@'; --OBTG:-20000--
      end if;

      select case when tt.issotrx='Y' then max(glitem_credit_acct) else max(glitem_debit_acct) end, max(tt.c_glitem_id)
      into v_glitem_acct, v_glitem_id
      from c_taxregister_type tt
      inner join c_glitem_acct gia on gia.c_glitem_id=tt.c_glitem_id
      where tt.isactive='Y' and gia.isactive='Y' and tt.issotrx= case when v_totalcredit - v_totaldebit > 0 then 'N' else 'Y' end
      group by tt.issotrx;

      if (v_glitem_acct is null) then
        RAISE EXCEPTION '%', '@NoAcctForGLItem@'; --OBTG:-20000--
      end if;

      if v_totalcredit - v_totaldebit > 0
      then
       v_totalcredit := v_totalcredit - v_totaldebit;
       v_totaldebit := 0;
       else
       v_totaldebit := v_totaldebit - v_totalcredit;
        v_totalcredit := 0;
        end if;

      v_line := v_line + 10;
      SELECT * INTO  v_gl_journallineid FROM ad_sequence_next('GL_JournalLine', v_record_id);
     insert
     into gl_journalline(gl_journalline_id,   ad_client_id,   ad_org_id,   isactive,   created,   createdby,   updated,   updatedby, gl_journal_id,    
     line, c_currency_id, currencyratetype, dateacct, c_validcombination_id, AMTSOURCEDR, AMTSOURCECR, AMTACCTDR, AMTACCTCR,em_exfm_trxorg)
                 values (v_gl_journallineid,   v_client_id,      v_org_id,        'Y',     TO_DATE(NOW()), v_createdby,   TO_DATE(NOW()), v_updatedby, v_gl_journalid, 
                 v_line, v_currency_id, v_currencyratetype, v_date, v_glitem_acct, v_totaldebit, v_totalcredit, v_totaldebit, v_totalcredit,v_em_exfm_barea);

    PERFORM GL_JOURNAL_POST(null, v_gl_journalid);

      UPDATE c_taxpayment
        SET gl_journal_id = v_gl_journalid
        where c_taxpayment.C_TAXPAYMENT_ID = v_record_id;

      --settlement


      if v_ispayment='Y' then
      		select sum(case when  c_taxregister.C_TAXREGISTER_TYPE_ID in
		(select C_TAXREGISTER_TYPE_ID from c_taxregister_type where c_taxregister_type.ISSOTRX='Y')
		then taxtotalamt
		else -taxtotalamt end ),
		sum(case when  c_taxregister.C_TAXREGISTER_TYPE_ID in
		(select C_TAXREGISTER_TYPE_ID from c_taxregister_type where c_taxregister_type.ISSOTRX='Y')
		then -lastregaccumamt
		else lastregaccumamt end )
		into v_taxtotalamt, v_prevvatcredit
		from c_taxregister where c_taxregister.C_TAXPAYMENT_ID=v_record_id;

		if v_prevvatcredit < 0 then v_prevvatcredit := 0;
		end if;
		v_paymentamt := v_taxtotalamt - v_prevvatcredit;


	      if v_paymentamt <=0 then
		      v_isreceipt:='Y';
		      v_paymentamt:=(-1)*v_paymentamt;
		      v_paymentcreditamt  := v_paymentamt;
		      v_paymentdebitamt := 0;
	      else
		      v_isreceipt:='N';
		      v_paymentcreditamt  := 0;
		      v_paymentdebitamt := v_paymentamt;
	      end if;

	      SELECT COUNT(1) INTO v_count
	      FROM ad_preference
	      WHERE property = 'FinancialManagement'
		AND ad_module_id <> '0';
	IF (v_count > 0) THEN
		v_dummy := AD_GET_PREFERENCE_VALUE('FinancialManagement', 'Y', v_client_id, v_org_id, NULL, NULL, NULL);
	ELSIF (v_count = 0) THEN
		v_ResultStr:='Generating C_Debt_Payment';

		v_settlementdoctype_id := ad_get_doctype(v_client_id,   v_org_id,   to_char('STM'));
		SELECT * INTO  v_settlementid FROM ad_sequence_next('C_Settlement', v_record_id);
		SELECT * INTO  v_sdocumentno FROM ad_sequence_doctype(v_settlementdoctype_id, v_record_id, 'Y');

		IF(v_sdocumentno IS NULL) THEN --to do send by mail
		SELECT * INTO  v_sdocumentno FROM ad_sequence_doc('DocumentNo_C_Settlement', v_client_id, 'Y');
		END IF;

		INSERT
			INTO c_settlement(c_settlement_id,   ad_client_id,   ad_org_id,   isactive,   created,   createdby,   updated,   updatedby,   documentno,   datetrx,   dateacct,   settlementtype,   c_doctype_id,   processing,   processed,   posted,   createfrom,   isgenerated, c_currency_id)
			SELECT v_settlementid,
			  ad_client_id,
			  ad_org_id,
			  'Y',
			  TO_DATE(NOW()),
			  createdby,
			  TO_DATE(NOW()),
			  updatedby,
			  v_sdocumentno,
			  v_date,
			  TRUNC(TO_DATE(NOW())),
			  'I',
			  v_settlementdoctype_id,
			  'N',
			  'N',
			  'N',
			  'N',
			  'N',
			  v_currency_id
			FROM c_taxpayment
		       WHERE c_taxpayment_id = v_record_id;

	       SELECT * INTO  v_debtpaymentid FROM ad_sequence_next('C_Debt_Payment', v_record_id);

	       INSERT
		 INTO c_debt_payment(c_debt_payment_id,   ad_client_id,   ad_org_id,   isactive,   created,   createdby,   
		 updated,   updatedby,   isreceipt,   c_settlement_cancel_id,   c_settlement_generate_id,   description,   
		 c_invoice_id,   c_bpartner_id,   c_currency_id,   c_cashline_id,   c_bankaccount_id,   c_cashbook_id,   
		 paymentrule,   ispaid,   amount,   writeoffamt,   dateplanned,   ismanual,   isvalid,   c_bankstatementline_id,   
		 changesettlementcancel,   cancel_processed,   generate_processed,   c_project_id,   status,   status_initial)
	       VALUES(v_debtpaymentid,   v_client_id,   v_org_id,   'Y',   TO_DATE(NOW()),   v_createdby,   
		  TO_DATE(NOW()), v_updatedby,   v_isreceipt,   NULL,   v_settlementid, v_name,   
		  NULL,   v_bpartner_id,   v_currency_id,   NULL,   NULL,   NULL,   
		  v_paymentrule,   'N',  v_paymentamt ,   0,   v_date,   'Y',   'Y',   NULL,   
		  'N',   'N',   'Y',   null,   'DE',   'DE');


	       SELECT * INTO  v_debtpaymentbalancingid FROM ad_sequence_next('C_Debt_Payment_Balancing', v_record_id);

	       insert
	       into c_debt_payment_balancing(c_debt_payment_balancing_id,   ad_client_id,   ad_org_id,   isactive,   created,   createdby,   
	       updated,   updatedby, c_debt_payment_id, AMOUNTDEBIT, AMOUNTCREDIT, C_GLITEM_ID)
	       values(v_debtpaymentbalancingid,   v_client_id,   v_org_id,   'Y',   TO_DATE(NOW()),   v_createdby,   
	       TO_DATE(NOW()),   v_updatedby, v_debtpaymentid, v_paymentdebitamt, v_paymentcreditamt, v_glitem_id);
	       PERFORM C_SETTLEMENT_POST(null, v_settlementid);

	       UPDATE c_taxpayment
		SET c_settlement_id = v_settlementid
		where c_taxpayment.C_TAXPAYMENT_ID = v_record_id;
	END IF;
      end if;
     END;

 end if;
  --C_TaxPayment_Post - Extension Point
  SELECT count(*) INTO v_count FROM DUAL
  WHERE EXISTS (SELECT 1 FROM ad_ep_procedures WHERE ad_extension_points_id = '2166B73BAD34456CBABCDFE243A5FBCA');
  IF (v_count=1) THEN
    DECLARE
      v_ep_instance VARCHAR(32); --OBTG:VARCHAR2--
      v_extension_point_id VARCHAR(32) := '2166B73BAD34456CBABCDFE243A5FBCA'; --OBTG:VARCHAR2--
    BEGIN
      v_ep_instance := get_uuid();
      PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'Record_ID', v_record_id, NULL, NULL, NULL, NULL, NULL, NULL);
      PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'User', v_UpdatedBy, NULL, NULL, NULL, NULL, NULL, NULL);
      PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'GLItem', v_glitem_id, NULL, NULL, NULL, NULL, NULL, NULL);
      PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'Amount', NULL, NULL, v_paymentamt, NULL, NULL, NULL, NULL);
      PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'IsReceipt', v_isreceipt, NULL, NULL, NULL, NULL, NULL, v_Message);
      PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'Message', NULL, NULL, NULL, NULL, NULL, NULL, v_Message);
      PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'Result', NULL, NULL, v_result, NULL, NULL, NULL, NULL);
      PERFORM AD_EXTENSION_POINT_HANDLER(v_ep_instance, v_extension_point_id);
      SELECT p_number INTO v_Result
      FROM ad_ep_instance_para
      WHERE ad_ep_instance_id = v_ep_instance
        AND parametername LIKE 'Result';
      SELECT p_text INTO v_Message
      FROM ad_ep_instance_para
      WHERE ad_ep_instance_id = v_ep_instance
        AND parametername LIKE 'Message';

      DELETE FROM ad_ep_instance_para
      WHERE ad_ep_instance_id = v_ep_instance;
    END;
  END IF;

  
 -- stop processing
  update c_taxpayment
     set processing='N', processed = (CASE WHEN v_processed='N' THEN 'Y' ELSE 'N' END) where c_taxpayment_id=v_record_id;
 end;
     IF(p_pinstance_id IS NOT NULL) THEN
    --  Update AD_PInstance
    RAISE NOTICE '%','Updating PInstance - Finished';
    PERFORM AD_UPDATE_PINSTANCE(p_pinstance_id,   v_updatedby,   'N',   v_result,   v_message);
    ELSE
    RAISE NOTICE '%','--<<C_TaxPayment_Post finished>> ' || v_message;
    END IF;

    EXCEPTION
WHEN OTHERS THEN
  v_ResultStr:= '@ERROR=' || SQLERRM;
  RAISE NOTICE '%',v_ResultStr ;
  IF(p_PInstance_ID IS NOT NULL) THEN
    -- ROLLBACK;
    PERFORM AD_UPDATE_PINSTANCE(p_PInstance_ID, NULL, 'N', 0, v_ResultStr) ;
  ELSE
    -- ROLLBACK;
    RAISE EXCEPTION '%', SQLERRM;
  END IF;
  RETURN;
END ; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION c_taxpayment_post(character varying)
  OWNER TO tad;










-- Function: c_uom_convert(numeric, character varying, character varying, character varying)

-- DROP FUNCTION c_uom_convert(numeric, character varying, character varying, character varying);

CREATE OR REPLACE FUNCTION c_uom_convert(p_qty numeric, p_uomfrom_id character varying, p_uomto_id character varying, p_stdprecision character varying)
  RETURNS numeric AS
$BODY$ DECLARE 
/*************************************************************************
* The contents of this file are subject to the Compiere Public
* License 1.1 ("License"); You may not use this file except in
* compliance with the License. You may obtain a copy of the License in
* the legal folder of your Openbravo installation.
* Software distributed under the License is distributed on an
* "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
* implied. See the License for the specific language governing rights
* and limitations under the License.
* The Original Code is  Compiere  ERP &  Business Solution
* The Initial Developer of the Original Code is Jorg Janke and ComPiere, Inc.
* Portions created by Jorg Janke are Copyright (C) 1999-2001 Jorg Janke,
* parts created by ComPiere are Copyright (C) ComPiere, Inc.;
* All Rights Reserved.
* Contributor(s): Openbravo SLU
* Contributions are Copyright (C) 2001-2008 Openbravo, S.L.U.
*
* Specifically, this derivative work is based upon the following Compiere
* file and version.
*************************************************************************
* $Id: C_UOM_Convert.sql,v 1.3 2002/10/21 04:49:45 jjanke Exp $
***
* Title: Convert Quantity
* Description:
*  from UOMFrom_ID to UOMTo_ID
*  standard or costing precision based on target UOM
* Test:
*  SELECT C_UOM_Convert (11,101,102, 'Y') FROM DUAL => 1.38
************************************************************************/
  v_Result NUMERIC:= NULL;
  v_Rate NUMERIC:= NULL;
  v_StdPrecision     NUMERIC;
  v_CostingPrecision NUMERIC;
BEGIN
  -- Nothing to do
  IF(p_UOMFrom_ID = p_UOMTo_ID  OR p_UOMFrom_ID IS NULL OR p_UOMTo_ID IS NULL  OR p_Qty IS NULL OR p_Qty = 0) THEN
    RETURN p_Qty;
  END IF;
  -- Get Multiply Rate
  BEGIN
    SELECT MultiplyRate
    INTO v_Rate
    FROM C_UOM_Conversion
    WHERE C_UOM_ID = p_UOMFrom_ID
    AND C_UOM_TO_ID = p_UOMTo_ID;
    -- We have it
    v_Result := p_Qty * v_Rate;
  EXCEPTION
  WHEN OTHERS THEN
    NULL;
  END;
  -- Get Divide Rate
  IF(v_Result IS NULL) THEN
    BEGIN
      SELECT DivideRate
      INTO v_Rate
      FROM C_UOM_Conversion
      WHERE C_UOM_ID = p_UOMTo_ID
      AND C_UOM_TO_ID = p_UOMFrom_ID;
      -- We have it
      v_Result := p_Qty * v_Rate;
    EXCEPTION
    WHEN OTHERS THEN
      NULL;
    END;
  END IF;
  -- Round
  IF(v_Result IS NOT NULL) THEN
    BEGIN
      SELECT StdPrecision,
        CostingPrecision
      INTO v_StdPrecision,
        v_CostingPrecision
      FROM C_UOM
      WHERE C_UOM_ID = p_UOMTo_ID;
      -- We have a precision
      IF(p_StdPrecision = 'Y') THEN
        --v_Result := ROUND(v_Result, v_StdPrecision) ;
      ELSE
        --v_Result := ROUND(v_Result, v_CostingPrecision) ;
      END IF;
    EXCEPTION
    WHEN OTHERS THEN
      NULL;
    END;
  END IF;
RETURN v_Result;
END ; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION c_uom_convert(numeric, character varying, character varying, character varying)
  OWNER TO tad;









CREATE OR REPLACE FUNCTION m_inout_createinvoice(p_pinstance_id character varying)
  RETURNS void AS
$BODY$ DECLARE 
/*************************************************************************
  * The contents of this file are subject to the Compiere Public
  * License 1.1 ("License"); You may not use this file except in
  * compliance with the License. You may obtain a copy of the License in
  * the legal folder of your Openbravo installation.
  * Software distributed under the License is distributed on an
  * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing rights
  * and limitations under the License.
  * The Original Code is  Compiere  ERP &  Business Solution
  * The Initial Developer of the Original Code is Jorg Janke and ComPiere, Inc.
  * Portions created by Jorg Janke are Copyright (C) 1999-2001 Jorg Janke,
  * parts created by ComPiere are Copyright (C) ComPiere, Inc.;
  * All Rights Reserved.
  * Contributor(s): Openbravo SLU
  * Contributions are Copyright (C) 2001-2014 Openbravo, S.L.U.
  *
  * Specifically, this derivative work is based upon the following Compiere
  * file and version.
  *************************************************************************
  * $Id: M_InOut_CreateInvoice.sql,v 1.7 2003/07/22 05:41:27 jjanke Exp $
  ***
  * Title: Create Invoice from Shipment
  * Description:
  ************************************************************************/
  -- Logistice
  v_ResultStr VARCHAR(2000):=''; --OBTG:VARCHAR2--
  v_Message VARCHAR(2000):=''; --OBTG:VARCHAR2--
  v_Record_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_User_ID VARCHAR(32):='0'; --OBTG:VARCHAR2--
  v_LinesFromOrder NUMERIC:= 0;
  -- Parameter
  --TYPE RECORD IS REFCURSOR;
    Cur_Parameter RECORD;
    -- Parameter Variables
    v_M_PriceList_Version_ID VARCHAR(32); --OBTG:VARCHAR2--
 
    v_isdeferredexpense M_Product.IsDeferredExpense%TYPE;
    v_expplantype M_Product.ExpPlanType%TYPE;
    v_periodnumber_exp M_Product.periodnumber_exp%TYPE;
    v_defaultperiod_exp M_Product.defaultperiod_exp%TYPE;

    v_isdeferred_inv C_InvoiceLine.IsDeferred%TYPE;
    v_defplantype_inv C_InvoiceLine.DefPlanType%TYPE;
    v_periodnumber_inv C_InvoiceLine.periodnumber%TYPE;
    v_period_inv C_InvoiceLine.c_period_id%TYPE;
    v_OrderQty NUMERIC;
    v_OrderUom VARCHAR(32);
    v_OrderUnitprice NUMERIC;
    v_region VARCHAR(32); 
    v_gstin_no VARCHAR(32); 
    v_hsnsac_code VARCHAR(32); 
    
  BEGIN
    --  Update AD_PInstance
    RAISE NOTICE '%','Updating PInstance - Processing ' || p_PInstance_ID ;
    v_ResultStr:='PInstanceNotFound';
    PERFORM AD_UPDATE_PINSTANCE(p_PInstance_ID, NULL, 'Y', NULL, NULL) ;
  BEGIN --BODY
    -- Get Parameters
    v_ResultStr:='ReadingParameters';
    FOR Cur_Parameter IN
      (SELECT i.Record_ID,
        p.ParameterName,
        p.P_String,
        p.P_Number,
        p.P_Date,
        i.AD_User_ID
      FROM AD_PINSTANCE i
      LEFT JOIN AD_PINSTANCE_PARA p
        ON i.AD_PInstance_ID=p.AD_PInstance_ID
      WHERE i.AD_PInstance_ID=p_PInstance_ID
      ORDER BY p.SeqNo
      )
    LOOP
      v_Record_ID:=Cur_Parameter.Record_ID;
      v_User_ID:=Cur_Parameter.AD_User_ID;
      IF(Cur_Parameter.ParameterName='M_PriceList_Version_ID') THEN
        v_M_PriceList_Version_ID:=Cur_Parameter.P_String;
        RAISE NOTICE '%','  M_PriceList_Version_ID=' || v_M_PriceList_Version_ID ;
      ELSE
        RAISE NOTICE '%','*** Unknown Parameter=' || Cur_Parameter.ParameterName ;
      END IF;
    END LOOP; -- Get Parameter
    RAISE NOTICE '%','  Record_ID=' || v_Record_ID ;
    DECLARE
      Cur_Shipment RECORD;
      Cur_ShipmentLines RECORD;
      --
      v_Invoice_ID VARCHAR(32) ; --OBTG:VARCHAR2--
      v_NextNo VARCHAR(32) ; --OBTG:VARCHAR2--
      v_DocType_ID VARCHAR(32) ; --OBTG:VARCHAR2--
      v_InvoiceNo NUMERIC(10) ;
      v_DocumentNo C_INVOICE.DocumentNo%TYPE;
      v_IsDiscountPrinted CHAR(1) ;
      v_PaymentRule VARCHAR(60) ; --OBTG:VARCHAR2--
      v_C_PaymentTerm_ID VARCHAR(32) ; --OBTG:VARCHAR2--
      v_C_Currency_ID VARCHAR(32) ; --OBTG:VARCHAR2--
      v_M_PriceList_ID VARCHAR(32) ; --OBTG:VARCHAR2--
      v_FIN_PaymentMethod_ID VARCHAR(32) ; --OBTG:VARCHAR2--
      v_istaxincluded CHAR(1);
      --
      v_C_UOM_ID VARCHAR(32) ; --OBTG:VARCHAR2--
      v_C_Tax_ID VARCHAR(32) ; --OBTG:VARCHAR2--
      v_PriceList NUMERIC;
      v_PriceActual NUMERIC;
      v_PriceLimit NUMERIC;
      v_gross_unit_price NUMERIC;
      v_line_gross_amount NUMERIC;
      v_priceprecision NUMERIC;
      v_stdprecision NUMERIC;
      --
      v_taxBaseAmt NUMERIC;
      v_LineNetAmt NUMERIC;
      v_TotalNet NUMERIC;
      -- v_Offer_ID       varchar2(32);
    BEGIN
      FOR CUR_Shipment IN
        (SELECT *  FROM M_INOUT  WHERE M_InOut_ID=v_Record_ID)
      LOOP -- Just to have all variables
        v_DocumentNo:=NULL;
        DECLARE
          Cur_CInvoiceCInvLine RECORD;
        BEGIN
          v_ResultStr:='Check Invoice exists';
          FOR Cur_CInvoiceCInvLine IN
            (SELECT i.DocumentNo,
              i.C_Invoice_ID
            FROM C_INVOICE i,
              C_INVOICELINE il,
              M_INOUTLINE iol
            WHERE i.C_Invoice_ID=il.C_Invoice_ID
              AND il.M_InOutLine_ID=iol.M_InOutLine_ID
              AND iol.M_InOut_ID=CUR_Shipment.M_InOut_ID
            )
          LOOP
            v_DocumentNo:=Cur_CInvoiceCInvLine.DocumentNo;
            v_Invoice_ID:=Cur_CInvoiceCInvLine.C_Invoice_ID;
            EXIT;
          END LOOP;
        EXCEPTION
        WHEN OTHERS THEN
          NULL;
        END;
        -- We have an Invoice
        IF(v_DocumentNo IS NOT NULL) THEN
          v_Message:='@ShipmentCreateDocAlreadyExists@ = '  || v_DocumentNo;
          RAISE EXCEPTION '%', v_Message; --OBTG:-20000--
          -- Shipment must be complete
        ELSIF(CUR_Shipment.DocStatus NOT IN('CO', 'CL')) THEN
          v_Message:='@ShipmentCreateDocNotCompleted@';
          RAISE EXCEPTION '%', v_Message; --OBTG:-20000--
          -- Create Invoice from Shipment
        ELSE
          v_ResultStr:='GetBPartnerInfo'; -- P=OnCredit
          SELECT IsDiscountPrinted,(
            CASE WHEN PaymentRulePO IS NULL THEN 'P' ELSE PaymentRulePO
            END
            ),
            PO_PaymentTerm_ID
          INTO v_IsDiscountPrinted,
            v_PaymentRule,
            v_C_PaymentTerm_ID
          FROM C_BPARTNER
          WHERE C_BPartner_ID=CUR_Shipment.C_BPartner_ID;
          -- Get PaymentTerms
          IF(v_C_PaymentTerm_ID IS NULL) THEN
            v_ResultStr:='GetPaymentTerm'; -- let it fail if no unique record
            v_Message:='@NoPaymentTerm@';
            DECLARE
              Cur_CPayTerm RECORD;
            BEGIN
              FOR Cur_CPayTerm IN
                (SELECT C_PaymentTerm_ID
                FROM C_PAYMENTTERM
                WHERE AD_Client_ID=CUR_Shipment.AD_Client_ID
                ORDER BY IsDefault DESC,
                  NetDays ASC
                )
              LOOP
                v_C_PaymentTerm_ID:=Cur_CPayTerm.C_PaymentTerm_ID;
                EXIT;
              END LOOP;
            END;
          END IF;
          --
          IF(CUR_Shipment.C_Order_ID IS NOT NULL) THEN
            v_ResultStr:='GetCurrencyInfo-Order';
            SELECT C_Currency_ID,
              M_PriceList_ID, FIN_PaymentMethod_ID,
              istaxincluded
            INTO v_C_Currency_ID,
              v_M_PriceList_ID, v_FIN_PaymentMethod_ID,
              v_istaxincluded
            FROM C_ORDER
            WHERE C_Order_ID=CUR_Shipment.C_Order_ID;
          ELSE
            v_ResultStr:='GetCurrencyInfo-PL';
            SELECT pl.C_Currency_ID,
              pl.M_PriceList_ID, pl.istaxincluded
            INTO v_C_Currency_ID,
              v_M_PriceList_ID, v_istaxincluded
            FROM M_PRICELIST pl,
              M_PRICELIST_VERSION plv
            WHERE pl.M_PriceList_ID=plv.M_PriceList_ID
              AND M_PriceList_Version_ID=v_M_PriceList_Version_ID;
            SELECT po_paymentmethod_id INTO v_FIN_PaymentMethod_ID
            FROM c_bpartner
            WHERE c_bpartner_id = CUR_Shipment.C_BPartner_ID;
          END IF;
          
          SELECT PricePrecision, stdprecision
            INTO v_priceprecision, v_stdprecision
          FROM C_CURRENCY
          WHERE C_CURRENCY_ID = v_C_Currency_ID;
          
          v_ResultStr:='GetDocTypeInfo';
          --v_DocType_ID:=Ad_Get_Doctype(CUR_Shipment.AD_Client_ID, CUR_Shipment.AD_Org_ID, 'API') ;
          --
          v_DocType_ID:=(select em_exfm_pur_inv_doctypes from c_doctype where c_doctype_id=(select c_doctype_id from M_INOUT  WHERE M_InOut_ID=v_Record_ID));

          if(v_DocType_ID is null) then
		raise exception '%','Please configure the Contra Purchase Invoice Document Type for: ' || (select name from c_doctype where c_doctype_id=(select c_doctype_id from M_INOUT  WHERE M_InOut_ID=v_Record_ID));
          end if;

          select em_exgst_bpartner_region,em_exgst_gstin_no into v_region,v_gstin_no from c_order where c_order_id=CUR_Shipment.C_Order_ID;
          
          SELECT * INTO  v_Invoice_ID FROM Ad_Sequence_Next('C_Invoice', CUR_Shipment.AD_Client_ID) ;
          SELECT * INTO  v_DocumentNo FROM Ad_Sequence_Doctype(v_DocType_ID, CUR_Shipment.AD_Client_ID, 'Y') ;
          IF(v_DocumentNo IS NULL) THEN
            SELECT * INTO  v_DocumentNo FROM Ad_Sequence_Doc('DocumentNo_C_Invoice', CUR_Shipment.AD_Client_ID, 'Y') ;
          END IF;
          IF(v_DocumentNo IS NULL) THEN
            v_DocumentNo:=CUR_Shipment.DocumentNo; --  use the Receipt
          END IF;
          --
          RAISE NOTICE '%','  Invoice_ID=' || v_Invoice_ID || ' DocumentNo=' || v_DocumentNo ;
          v_ResultStr:='InsertInvoice ' || v_Invoice_ID;
          v_Message:='@DocumentNo@ = ' || v_DocumentNo;
          INSERT
          INTO C_INVOICE
            (
              C_Invoice_ID, C_Order_ID, AD_Client_ID, AD_Org_ID,
              IsActive, Created, CreatedBy, Updated,
              UpdatedBy, IsSOTrx, DocumentNo, DocStatus,
              DocAction, Processing, Processed, C_DocType_ID,
              C_DocTypeTarget_ID, Description, SalesRep_ID, 
              DateInvoiced, DatePrinted, IsPrinted, TaxDate,
              DateAcct, C_PaymentTerm_ID, C_BPartner_ID, C_BPartner_Location_ID,
              AD_User_ID, POReference, DateOrdered, IsDiscountPrinted,
              C_Currency_ID, PaymentRule, C_Charge_ID, ChargeAmt,
              TotalLines, GrandTotal, M_PriceList_ID, C_Campaign_ID,
              C_Project_ID, C_Activity_ID, AD_OrgTrx_ID, User1_ID,
              User2_ID, fin_paymentmethod_id, C_Costcenter_ID,
              A_Asset_ID, em_exgst_bpartner_region, em_exgst_gstin_no
            )
            VALUES
            (
              v_Invoice_ID, CUR_Shipment.C_Order_ID, CUR_Shipment.AD_Client_ID, CUR_Shipment.AD_Org_ID,
               'Y', TO_DATE(NOW()), v_User_ID, TO_DATE(NOW()),
              v_User_ID, 'N', v_DocumentNo, 'DR',
               'CO', 'N', 'N', v_DocType_ID,
              v_DocType_ID, CUR_Shipment.Description, CUR_Shipment.salesrep_id, 
              CUR_Shipment.movementdate, NULL, 'N', TO_DATE(NOW()),
              CUR_Shipment.movementdate, v_C_PaymentTerm_ID, CUR_Shipment.C_BPartner_ID, CUR_Shipment.C_BPartner_Location_ID,
              CUR_Shipment.AD_User_ID, NULL, CUR_Shipment.DateOrdered, v_IsDiscountPrinted,
              v_C_Currency_ID, v_PaymentRule, NULL, 0,
              0, 0, v_M_PriceList_ID, CUR_Shipment.C_Campaign_ID,
              CUR_Shipment.C_Project_ID, CUR_Shipment.C_Activity_ID, CUR_Shipment.AD_OrgTrx_ID, CUR_Shipment.User1_ID,
              CUR_Shipment.User2_ID, v_fin_paymentmethod_id, CUR_Shipment.C_Costcenter_ID,
              CUR_Shipment.A_Asset_ID, v_region, v_gstin_no
            )
            ;
          -- Lines
          v_TotalNet:=0;
          FOR CUR_ShipmentLines IN
            (SELECT *  FROM M_INOUTLINE  WHERE M_InOut_ID=v_Record_ID)
          LOOP
            v_LinesFromOrder:= v_LinesFromOrder + 1;
            -- Get Price
            IF(CUR_ShipmentLines.C_OrderLine_ID IS NOT NULL) THEN
              v_ResultStr:='GettingPrice-Order';
              SELECT COALESCE(MAX(PriceList), 0),
                COALESCE(MAX(PriceActual), 0),
                COALESCE(MAX(PriceLimit), 0),
                COALESCE(MAX(CUR_ShipmentLines.movementqty*priceactual),0),
                COALESCE(MAX(gross_unit_price), 0),
                COALESCE(MAX(line_gross_amount), 0),
                MAX(c_tax_id)
              INTO v_PriceList,
                v_PriceActual,
                v_PriceLimit,
                v_LineNetAmt,
                v_gross_unit_price,
                v_line_gross_amount,
                v_c_Tax_ID
              FROM C_ORDERLINE
              WHERE C_OrderLine_ID=CUR_ShipmentLines.C_OrderLine_ID;

	   -- Get Tax Base Amount
	      SELECT COALESCE(co.taxbaseamt,0) * C_DIVIDE((l.MovementQty-SUM(COALESCE(mi.Qty,0))),COALESCE(co.qtyordered,1)) as taxbaseamt
	      INTO v_taxBaseAmt
	      FROM M_INOUTLINE l left join M_MATCHINV mi on l.M_InOutLine_ID=mi.M_InOutLine_ID
                left join C_ORDERLINE co ON co.C_ORDERLINE_ID=l.C_ORDERLINE_ID
	      WHERE l.m_inoutline_id=CUR_ShipmentLines.m_inoutline_id
	      GROUP BY co.taxbaseamt,l.MovementQty,co.qtyordered;
            ELSE
              v_ResultStr:='GettingPrice-PList';
              SELECT COALESCE(MAX(PriceList), 0),
                COALESCE(MAX(PriceStd), 0),
                COALESCE(MAX(PriceLimit), 0)
              INTO v_PriceList,
                v_PriceActual,
                v_PriceLimit
              FROM M_PRODUCTPRICE
              WHERE M_Product_ID=CUR_ShipmentLines.M_Product_ID
                AND M_PriceList_Version_ID=v_M_PriceList_Version_ID;
              v_C_Tax_ID:=C_Gettax(CUR_ShipmentLines.M_Product_ID, CUR_Shipment.MovementDate, CUR_Shipment.AD_Org_ID, CUR_Shipment.M_Warehouse_ID, CUR_Shipment.C_BPartner_Location_ID, CUR_Shipment.C_BPartner_Location_ID, CUR_Shipment.C_Project_ID, 'N') ;
              IF (v_istaxincluded = 'Y') THEN
                v_gross_unit_price:= v_PriceActual;
                v_line_gross_amount:= ROUND(v_gross_unit_price * CUR_ShipmentLines.MovementQty, v_stdprecision);
                v_PriceActual:= C_GET_NET_PRICE_FROM_GROSS(v_C_Tax_ID, v_PriceActual, 0, v_priceprecision, 1);
                v_LineNetAmt:= ROUND(v_PriceActual * CUR_ShipmentLines.MovementQty, v_stdprecision);
              ELSE
                v_PriceActual:=M_Get_Offers_Price(TO_DATE(NOW()), CUR_Shipment.C_BPartner_ID, CUR_ShipmentLines.M_Product_ID, v_PriceActual, CUR_ShipmentLines.MovementQty, v_M_PriceList_ID);
                v_LineNetAmt:=ROUND(M_Get_Offers_Price(TO_DATE(NOW()), CUR_Shipment.C_BPartner_ID, CUR_ShipmentLines.M_Product_ID, v_PriceActual, CUR_ShipmentLines.MovementQty, v_M_PriceList_ID) *CUR_ShipmentLines.MovementQty, v_stdprecision) ;
              END IF;
            END IF;
            -- Get UOM + Tax -- VERY simplified, but should work in most cases
            v_ResultStr:='NoUOM+Tax';
            SELECT C_UOM_ID, EXPPLANTYPE, ISDEFERREDEXPENSE, PERIODNUMBER_EXP, DEFAULTPERIOD_EXP
            INTO v_C_UOM_ID, v_expplantype, v_isdeferredexpense, v_periodnumber_exp, v_defaultperiod_exp
            FROM M_PRODUCT
            WHERE M_Product_ID=CUR_ShipmentLines.M_Product_ID;

						v_period_inv:= c_get_default_period(v_Invoice_ID, v_defaultperiod_exp);
						IF(v_period_inv IS NOT NULL AND v_isdeferredexpense = 'Y') THEN
							v_isdeferred_inv := v_isdeferredexpense;
							v_defplantype_inv := v_expplantype;
							v_periodnumber_inv := v_periodnumber_exp;
					  ELSE
					  	v_period_inv := NULL;
							v_isdeferred_inv := 'N';
							v_defplantype_inv := NULL;
							v_periodnumber_inv := NULL;
						END IF;
            -- v_UOM_ID, v_Tax_ID
            v_ResultStr:='InsertInvoiceLine';
            SELECT * INTO  v_NextNo FROM Ad_Sequence_Next('C_InvoiceLine', CUR_Shipment.C_Order_ID) ;
            --Added logic by Usha
            SELECT em_exs_user_uom_id,em_exs_unitprice 
            INTO v_OrderUom,v_OrderUnitprice from c_orderline where c_orderline_id =CUR_ShipmentLines.C_OrderLine_ID;
            SELECT em_exs_recvdqty INTO v_OrderQty from m_inoutline where m_inoutline_id =CUR_ShipmentLines.m_inoutline_id;
            --Ends logic by usha
            select em_exgst_hsn_sac_code into v_hsnsac_code from c_orderline where c_orderline_id=CUR_ShipmentLines.C_OrderLine_ID;
            INSERT
            INTO C_INVOICELINE
              (
                C_InvoiceLine_ID, AD_Client_ID, AD_Org_ID, IsActive,
                Created, CreatedBy, Updated, UpdatedBy,
                C_Invoice_ID, C_OrderLine_ID, M_InOutLine_ID, Line,
                Description, M_Product_ID, QtyInvoiced, PriceList,
                PriceActual, PriceLimit, LineNetAmt, C_Charge_ID,
                ChargeAmt, C_UOM_ID,
                C_Tax_ID,  --MODIFIED BY F.IRIAZABAL
                QuantityOrder, M_Product_Uom_ID, PriceStd, taxbaseamt,
                gross_unit_price, line_gross_amount,
                isdeferred, defplantype, periodnumber, c_period_id,
                c_project_id, user1_id, user2_id, c_costcenter_id, a_asset_id,em_exs_user_qty,em_exs_user_uom_id,em_exs_unitprice, em_exgst_hsn_sac_code
              )
              VALUES
              (
                v_NextNo, CUR_Shipment.AD_Client_ID, CUR_ShipmentLines.AD_Org_ID, 'Y',
                TO_DATE(NOW()), v_User_ID, TO_DATE(NOW()), v_User_ID, -- LineTrigger reqirement
                v_Invoice_ID, CUR_ShipmentLines.C_OrderLine_ID, CUR_ShipmentLines.M_InOutLine_ID, CUR_ShipmentLines.Line,
                CUR_ShipmentLines.Description, CUR_ShipmentLines.M_Product_ID, CUR_ShipmentLines.MovementQty, v_PriceList,
                v_PriceActual, v_PriceLimit, v_LineNetAmt, NULL,
                0, v_C_UOM_ID,
                v_C_Tax_ID,  --MODIFIED BY F.IRIAZABAL
                CUR_ShipmentLines.QuantityOrder, CUR_ShipmentLines.M_Product_Uom_ID, v_PriceActual,v_taxBaseAmt,
                v_gross_unit_price, v_line_gross_amount,
                v_isdeferred_inv, v_defplantype_inv, v_periodnumber_inv, v_period_inv,
                coalesce(CUR_ShipmentLines.c_project_id, CUR_Shipment.c_project_id),
                coalesce(CUR_ShipmentLines.user1_id, CUR_Shipment.user1_id),
                coalesce(CUR_ShipmentLines.user2_id, CUR_Shipment.user2_id),
                coalesce(CUR_ShipmentLines.c_costcenter_id, CUR_Shipment.c_costcenter_id),
                coalesce(CUR_ShipmentLines.a_asset_id, CUR_Shipment.a_asset_id),v_OrderQty,v_OrderUom,v_OrderUnitprice, v_hsnsac_code
              )
              ;
            v_TotalNet:=v_TotalNet + v_LineNetAmt;
          END LOOP; -- ShipLines
        END IF;
      END LOOP; -- All Shipments
    
	-- Code Added/Changed For Updating Proper Document Sequence No. For Goods Reciept - On 30-July-2018
	v_Message := 'Document No. = ' || (select documentno from c_invoice where c_invoice_id =  v_Invoice_ID limit 1);
  	v_Message:= v_Message || '. ' || v_LinesFromOrder || ' ' || '@UsedPricesFromOrder@';
    

END;
    ---- <<FINISH_PROCESS>>
    --  Update AD_PInstance
    RAISE NOTICE '%','Updating PInstance - Finished ' || v_Message ;
    PERFORM AD_UPDATE_PINSTANCE(p_PInstance_ID, NULL, 'N', 1, v_Message) ;
    RETURN;
  END; --BODY
EXCEPTION
WHEN OTHERS THEN
  v_ResultStr:= '@ERROR=' || SQLERRM;
  RAISE NOTICE '%',v_ResultStr ;
  -- ROLLBACK;
  PERFORM AD_UPDATE_PINSTANCE(p_PInstance_ID, NULL, 'N', 0, v_ResultStr) ;
  RETURN;
END ; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION m_inout_createinvoice(character varying)
  OWNER TO tad;












-- Function: m_requisition_createpo(character varying)

-- DROP FUNCTION m_requisition_createpo(character varying);

CREATE OR REPLACE FUNCTION m_requisition_createpo(p_pinstance_id character varying)
  RETURNS void AS
$BODY$ DECLARE 
/*************************************************************************
* The contents of this file are subject to the Openbravo  Public  License
* Version  1.1  (the  "License"),  being   the  Mozilla   Public  License
* Version 1.1  with a permitted attribution clause; you may not  use this
* file except in compliance with the License. You  may  obtain  a copy of
* the License at http://www.openbravo.com/legal/license.html
* Software distributed under the License  is  distributed  on  an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
* License for the specific  language  governing  rights  and  limitations
* under the License.
* The Original Code is Openbravo ERP.
* The Initial Developer of the Original Code is Openbravo SLU
* All portions are Copyright (C) 2008-2015 Openbravo SLU
* All Rights Reserved.
* Contributor(s):  ______________________________________.
************************************************************************/
  -- Logistice
  v_ResultStr VARCHAR(2000):=''; --OBTG:VARCHAR2--
  v_Message VARCHAR(2000):=''; --OBTG:VARCHAR2--
  v_Result NUMERIC:=1; -- 0=failure
  v_Record_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_User_ID VARCHAR(32):='0'; --OBTG:VARCHAR2--
  v_Client_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_sales_rep_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_Count NUMERIC;
  v_C_DOCTYPE_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_C_Order_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_DocumentNo VARCHAR(60); --OBTG:NVARCHAR2--
  v_Line NUMERIC;
  v_Vendor_Old VARCHAR(32); --OBTG:VARCHAR2--
  v_PriceList_Old VARCHAR(32); --OBTG:VARCHAR2--
  v_BPartner_Location_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_BillTo_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_Currency_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_COrderLine_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_NoRecords NUMERIC:=0;
  v_RequisitionOrder_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_PaymentTerm_ID VARCHAR(32); --OBTG:VARCHAR2--

  v_PriceList NUMERIC;
  v_PriceLimit NUMERIC;
  v_PriceStd NUMERIC;
  v_PriceActual NUMERIC;
  v_Discount NUMERIC;
  v_Tax_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_gross_unit_price NUMERIC;
  v_line_gross_amount NUMERIC;
  v_lineNetAmt NUMERIC;
  v_stdPre NUMERIC;
  v_priPre NUMERIC;
  v_Gross NUMERIC;

  p_OrderDate TIMESTAMP;
  p_Vendor_ID VARCHAR(32); --OBTG:VARCHAR2--
  p_PriceList_ID VARCHAR(32); --OBTG:VARCHAR2--
  p_Org_ID VARCHAR(32); --OBTG:VARCHAR2--
  p_Warehouse_ID VARCHAR(32); --OBTG:VARCHAR2--
  
  --  Parameter
  --TYPE RECORD IS REFCURSOR;
  Cur_Parameter RECORD;
  Cur_Product RECORD;
  Cur_Lines RECORD;
BEGIN
  RAISE NOTICE '%','BEGIN M_REQUISITION_ORDER ' || p_PInstance_ID ;
  v_ResultStr:='PInstanceNotFound';
  PERFORM AD_UPDATE_PINSTANCE(p_PInstance_ID, NULL, 'Y', NULL, NULL) ;

  BEGIN --BODY
    -- Get Parameters
    v_ResultStr:='ReadingParameters';
    FOR Cur_Parameter IN
      (SELECT i.Record_ID, i.AD_User_ID, i.AD_Client_ID, i.AD_Org_ID,
        p.ParameterName, p.P_String, p.P_Number, p.P_Date
      FROM AD_PInstance i
      LEFT JOIN AD_PInstance_Para p
        ON i.AD_PInstance_ID=p.AD_PInstance_ID
      WHERE i.AD_PInstance_ID=p_PInstance_ID
      ORDER BY p.SeqNo) LOOP
      IF (Cur_Parameter.ParameterName = 'DateOrdered') THEN
        p_OrderDate := Cur_Parameter.P_Date;
      ELSIF (Cur_Parameter.ParameterName = 'C_BPartner_ID') THEN
        p_Vendor_ID := Cur_Parameter.P_String;
      ELSIF (Cur_Parameter.ParameterName = 'M_PriceList_ID') THEN
        p_PriceList_ID := Cur_Parameter.P_String;
      ELSIF (Cur_Parameter.ParameterName = 'AD_Org_ID') THEN
        p_Org_ID := Cur_Parameter.P_String;
      ELSIF (Cur_Parameter.ParameterName = 'M_Warehouse_ID') THEN
        p_Warehouse_ID := Cur_Parameter.P_String;
      END IF;
      v_Record_ID:=Cur_Parameter.Record_ID;
      v_User_ID:=Cur_Parameter.AD_User_ID;
      v_Client_ID := Cur_Parameter.AD_Client_ID;
    END LOOP; -- Get Parameter

    v_ResultStr := 'Checking vendor';
    IF (p_Vendor_ID IS NULL) THEN
      FOR Cur_Product IN (
          SELECT M_PRODUCT.NAME, M_REQUISITIONLINE.LINE
          FROM M_REQUISITION, M_REQUISITIONLINE, M_PRODUCT
          WHERE M_REQUISITION.M_REQUISITION_ID = M_REQUISITIONLINE.M_REQUISITION_ID
            AND M_REQUISITIONLINE.M_PRODUCT_ID = M_PRODUCT.M_PRODUCT_ID
            AND M_REQUISITION.M_REQUISITION_ID = v_Record_ID
            AND M_REQUISITIONLINE.C_BPARTNER_ID IS NULL
            AND M_REQUISITION.C_BPARTNER_ID IS NULL
            AND NOT EXISTS (SELECT 1
                            FROM M_PRODUCT_PO
                            WHERE M_PRODUCT_PO.M_PRODUCT_ID = M_REQUISITIONLINE.M_PRODUCT_ID
                              AND M_PRODUCT_PO.ISACTIVE = 'Y'
                              AND M_PRODUCT_PO.ISCURRENTVENDOR = 'Y'
                              AND M_PRODUCT_PO.DISCONTINUED = 'N')) LOOP
        v_Message := '@Inline@ ' || Cur_Product.line || ' @ForProduct@ ' || Cur_Product.Name || ' @BPartnerNotFound@';
        RAISE EXCEPTION '%', v_Message; --OBTG:-20000--
      END LOOP;
    END IF;

    v_ResultStr:='Start lines cursor';
    FOR Cur_Lines IN
      (SELECT A.*,
           COALESCE(A.A_PRICELIST_ID, C_BPARTNER.PO_PRICELIST_ID) AS PRICELIST_ID,
           C_BPARTNER.PAYMENTRULEPO AS PAYMENTRULE, C_BPARTNER.PO_PAYMENTMETHOD_ID, C_BPARTNER.PO_PAYMENTTERM_ID AS C_PAYMENTTERM_ID,
           C_BPARTNER.DELIVERYRULE, C_BPARTNER.DELIVERYVIARULE, C_BPARTNER.C_BPARTNER_ID AS C_BPID, 
           M_PRICELIST.ISTAXINCLUDED
       FROM (SELECT COALESCE(p_Vendor_ID, M_REQUISITIONLINE.C_BPARTNER_ID, M_REQUISITION.C_BPARTNER_ID, PRODUCT_PO.C_BPARTNER_ID) AS VENDOR_ID,
                 COALESCE(p_PriceList_ID, M_REQUISITIONLINE.M_PRICELIST_ID, M_REQUISITION.M_PRICELIST_ID) AS A_PRICELIST_ID,
                 M_REQUISITIONLINE.*
              FROM M_REQUISITION, M_REQUISITIONLINE LEFT JOIN (SELECT MAX(C_BPARTNER_ID) AS C_BPARTNER_ID, M_PRODUCT_ID
                                                               FROM M_PRODUCT_PO
                                                               WHERE ISCURRENTVENDOR = 'Y'
                                                                 AND ISACTIVE = 'Y'
                                                                 AND DISCONTINUED = 'N'
                                                               GROUP BY M_PRODUCT_ID) PRODUCT_PO
                                                              ON M_REQUISITIONLINE.M_PRODUCT_ID = PRODUCT_PO.M_PRODUCT_ID
              WHERE M_REQUISITION.M_REQUISITION_ID = M_REQUISITIONLINE.M_REQUISITION_ID
                AND M_REQUISITION.M_REQUISITION_ID = v_Record_ID
                AND M_REQUISITIONLINE.REQSTATUS = 'O'
                AND NOT (COALESCE(M_REQUISITIONLINE.LOCKEDBY, v_User_ID) <> v_User_ID
                         AND COALESCE(M_REQUISITIONLINE.LOCKDATE, TO_DATE('01-01-1900', 'DD-MM-YYYY')) >= (TO_DATE(NOW())-3))
              ) A, C_BPARTNER, M_PRICELIST
       WHERE A.VENDOR_ID = C_BPARTNER.C_BPARTNER_ID
       AND m_pricelist.m_pricelist_ID = CASE WHEN A.A_PRICELIST_ID is not null then A.A_PRICELIST_ID ELSE C_BPARTNER.PO_PRICELIST_ID END
       ORDER BY A.VENDOR_ID, COALESCE(A.A_PRICELIST_ID, C_BPARTNER.PO_PRICELIST_ID), A.NEEDBYDATE) LOOP
      v_ResultStr:='Line start';

      IF (Cur_Lines.PRICELIST_ID IS NULL ) THEN
        v_Message := '@PriceListVersionNotFound@';
        RAISE EXCEPTION '%', v_Message; --OBTG:-20000--
      END IF;

      IF (v_C_Order_ID IS NULL OR v_Vendor_Old <> Cur_Lines.Vendor_ID OR v_PriceList_Old <> Cur_Lines.PriceList_ID) THEN
      --Commented by usha
       /* IF (v_C_Order_ID IS NOT NULL) THEN
          v_ResultStr := 'Post Order ' || v_C_Order_ID;
          PERFORM C_ORDER_POST1(null, v_C_Order_ID);
          v_Message := v_Message || ', ' || '@OrderDocumentno@ ' || v_DocumentNo;
        END IF;*/
        v_ResultStr := 'Create new C_Order';
        v_Vendor_Old := Cur_Lines.Vendor_ID;
        v_PriceList_Old := Cur_Lines.PriceList_ID;
        v_Line := 0;
        v_NoRecords := v_NoRecords +1;
        v_C_Order_ID:=Ad_Sequence_Nextno('C_Order') ;
        v_C_DOCTYPE_ID:=Ad_Get_DocType(v_Client_ID, p_Org_ID, 'POO') ;
        SELECT * INTO  v_DocumentNo FROM AD_Sequence_DocType(v_C_DOCTYPE_ID, v_Client_ID, 'Y') ;
        IF(v_DocumentNo IS NULL) THEN
          SELECT * INTO  v_DocumentNo FROM AD_Sequence_Doc('DocumentNo_C_Order', v_Client_ID, 'Y') ;
        END IF;
        SELECT MIN(C_BPARTNER_LOCATION_ID) INTO v_BPartner_Location_ID
        FROM C_BPARTNER_LOCATION
        WHERE ISACTIVE='Y'
          AND ISSHIPTO='Y'
          AND C_BPARTNER_ID=Cur_Lines.Vendor_ID;
        SELECT MIN(AD_USER_ID) INTO v_sales_rep_ID
         FROM AD_USER
         WHERE ISACTIVE='Y'
         AND C_BPARTNER_ID=Cur_Lines.Vendor_ID;  
        SELECT MIN(C_BPARTNER_LOCATION_ID) INTO v_BillTo_ID
        FROM C_BPARTNER_LOCATION
        WHERE ISACTIVE='Y'
          AND ISBILLTO='Y'
          AND C_BPARTNER_ID=Cur_Lines.Vendor_ID;

        SELECT C_CURRENCY_ID INTO v_Currency_ID
        FROM M_PRICELIST
        WHERE M_PRICELIST_ID = Cur_Lines.Pricelist_ID;

        IF(Cur_Lines.C_PAYMENTTERM_ID IS NULL) THEN
          SELECT c_paymentterm_id INTO v_PaymentTerm_ID
          FROM c_paymentterm
          WHERE isactive='Y'
            AND isdefault='Y'
            AND AD_Client_ID = v_Client_ID;
        END IF;
        --Added by usha payment term logic
        SELECT c_paymentterm_id INTO v_PaymentTerm_ID from c_paymentterm where name ='Immediate' limit 1;
 
        v_ResultStr := 'Insert C_Order id: ' || v_C_Order_ID || ' No.: ' || v_DocumentNo;
        INSERT INTO C_ORDER (
            C_ORDER_ID, AD_CLIENT_ID, AD_ORG_ID, CREATEDBY,CREATED,
            UPDATEDBY, UPDATED, ISSOTRX, DOCUMENTNO, DOCSTATUS,
            DOCACTION, C_DOCTYPE_ID, C_DOCTYPETARGET_ID, DATEORDERED,
            DATEACCT, C_BPARTNER_ID, C_BPARTNER_LOCATION_ID, ISDISCOUNTPRINTED,
            C_CURRENCY_ID, PAYMENTRULE, FIN_PAYMENTMETHOD_ID, C_PAYMENTTERM_ID, INVOICERULE,
            DELIVERYRULE, FREIGHTCOSTRULE, DELIVERYVIARULE, PRIORITYRULE,
            TOTALLINES, GRANDTOTAL, M_WAREHOUSE_ID, M_PRICELIST_ID,
            ISTAXINCLUDED, POSTED, PROCESSING, BILLTO_ID,
            AD_USER_ID, COPYFROM, DATEPROMISED,EM_Exs_Cre_Ord
        ) VALUES (
            v_C_Order_ID, v_CLIENT_ID, p_Org_ID, v_User_ID,TO_DATE(NOW()),
            v_User_ID, TO_DATE(NOW()), 'N', v_DocumentNo, 'DR',
             'CO', '0', v_C_DOCTYPE_ID, p_OrderDate,
            p_OrderDate, Cur_Lines.vendor_Id, v_BPartner_Location_ID, 'N',
            v_Currency_ID, COALESCE(Cur_Lines.PAYMENTRULE, 'P'), Cur_Lines.PO_PAYMENTMETHOD_ID, v_PaymentTerm_ID, 'D',
            COALESCE(Cur_Lines.Deliveryrule, 'A'), 'I', 'D', '5',
            0, 0, p_WAREHOUSE_ID, Cur_Lines.PRICELIST_ID,
             'N', 'N', 'N', v_BillTo_ID,
            v_sales_rep_ID, 'N', Cur_Lines.NEEDBYDATE,'N'
        );
      END IF;

      v_ResultStr := 'Create C_Order_Line';
      v_Line := v_Line + 10;
      SELECT * INTO  v_COrderLine_ID FROM Ad_Sequence_Next('C_OrderLine', v_Client_ID);

      SELECT pp.PRICELIST, pp.PRICELIMIT, pp.PRICESTD,
             ROUND(M_GET_OFFERS_PRICE(TO_DATE(p_OrderDate),Cur_Lines.C_BPID,Cur_Lines.M_Product_ID,COALESCE(Cur_Lines.PRICEACTUAL, pp.PRICESTD),Cur_Lines.QTY - Cur_Lines.ORDEREDQTY,Cur_Lines.PRICELIST_ID),CUR.PRICEPRECISION), 
             pp.Gross
        INTO v_PriceList, v_PriceLimit, v_PriceStd, v_PriceActual, v_Gross
      FROM
        (SELECT COALESCE(Cur_Lines.PRICELIST, MAX(M_PRODUCTPRICE.PRICELIST), Cur_Lines.PRICEACTUAL) AS PRICELIST,
             COALESCE(MAX(M_PRODUCTPRICE.PRICELIMIT), Cur_Lines.PRICEACTUAL) AS PRICELIMIT,
             COALESCE(Cur_Lines.PRICEACTUAL, MAX(M_PRODUCTPRICE.PRICESTD)) AS PRICESTD,
             COALESCE(Cur_Lines.Gross_Unit_Price, 0) as Gross
         FROM M_PRODUCTPRICE
         WHERE M_PRICELIST_VERSION_ID = M_GET_PRICELIST_VERSION(Cur_Lines.PRICELIST_ID, p_OrderDate)
           AND M_PRODUCT_ID = Cur_Lines.M_PRODUCT_ID) pp, (SELECT PRICEPRECISION, STDPRECISION FROM C_CURRENCY WHERE C_CURRENCY_ID = v_Currency_ID) CUR;

     /* IF (v_PriceActual IS NULL) THEN
        v_Message := '@PriceNotFound@';
        RAISE EXCEPTION '%', v_Message; --OBTG:-20000--
      END IF;*/
 --Added logic by usha
      SELECT c_tax_id INTO v_Tax_ID from c_tax where name ='No Tax' limit 1;
      --Ends tax logic by usha
     -- v_Tax_ID := C_GetTax(Cur_Lines.M_Product_ID, p_OrderDate, p_Org_ID, p_Warehouse_ID, v_BillTo_ID, v_BPartner_Location_ID, null, 'N');
      IF (v_Tax_ID is NULL) THEN
        v_Message := '@NoTaxDefinedForRequisitionLine@' || v_Line;
        RAISE EXCEPTION '%', v_Message; --OBTG:-20000--
      END IF;
      
      
      SELECT STDPRECISION, PRICEPRECISION INTO v_stdPre, v_priPre FROM C_CURRENCY WHERE C_CURRENCY_ID = v_Currency_ID;
    
      v_ResultStr:='Insert order line';
      IF (Cur_Lines.istaxincluded = 'Y') THEN
        v_gross_unit_price:= v_Gross;
        v_line_gross_amount:= ROUND(v_gross_unit_price * (Cur_Lines.QTY - Cur_Lines.ORDEREDQTY), v_stdPre);
        v_PriceActual:= C_GET_NET_PRICE_FROM_GROSS(v_Tax_ID, v_line_gross_amount, v_line_gross_amount, v_priPre, (Cur_Lines.QTY - Cur_Lines.ORDEREDQTY));
        v_LineNetAmt:= ROUND(v_PriceActual * (Cur_Lines.QTY - Cur_Lines.ORDEREDQTY), v_stdPre);
        IF (v_PriceList = 0) THEN
          v_Discount := 0 ;
        ELSE
          v_Discount :=ROUND((v_PriceList-v_gross_unit_price) / v_PriceList*100, v_stdPre); -- Calculate rounded discount
        END IF;
      ELSE
        v_LineNetAmt:= ROUND(v_PriceActual*(Cur_Lines.QTY - Cur_Lines.ORDEREDQTY), v_stdPre);
        v_gross_unit_price := 0;
        v_line_gross_amount:= 0;
        IF (v_PriceList = 0) THEN
          v_Discount := 0 ;
        ELSE
          v_Discount :=ROUND((v_PriceList-v_PriceActual) / v_PriceList*100, v_stdPre); -- Calculate rounded discount
        END IF;
      END IF;
     
      INSERT INTO C_OrderLine (
          C_ORDERLINE_ID, AD_CLIENT_ID, AD_ORG_ID, ISACTIVE,
          CREATED, CREATEDBY, UPDATED, UPDATEDBY,
          C_ORDER_ID, LINE, C_BPARTNER_ID, C_BPARTNER_LOCATION_ID,
          DATEORDERED, DATEPROMISED, DESCRIPTION, M_PRODUCT_ID,
          M_ATTRIBUTESETINSTANCE_ID,
          M_WAREHOUSE_ID, C_UOM_ID, QTYORDERED, C_CURRENCY_ID,
          PRICELIST, PRICEACTUAL, PRICELIMIT,
          PRICESTD, LINENETAMT, DISCOUNT,
          C_TAX_ID, M_PRODUCT_UOM_ID, QUANTITYORDER, GROSS_UNIT_PRICE, LINE_GROSS_AMOUNT,em_exs_user_qty,em_exs_user_uom_id,em_exs_unitprice
      ) VALUES (
          v_COrderLine_ID,v_Client_ID, p_Org_ID,'Y',
          TO_DATE(NOW()), v_User_ID, TO_DATE(NOW()), v_User_ID,
          v_C_Order_ID, v_Line, Cur_Lines.Vendor_ID, v_BPartner_Location_ID,
          p_OrderDate, Cur_Lines.NEEDBYDATE, Cur_Lines.SUPPLIERNOTES, Cur_Lines.M_Product_ID,
          Cur_Lines.M_AttributeSetInstance_ID,
          p_Warehouse_ID, Cur_Lines.C_UOM_ID, Cur_Lines.QTY - Cur_Lines.ORDEREDQTY, v_Currency_ID,
          v_PriceList, v_PriceActual, v_PriceLimit,
          v_PriceStd, v_LineNetAmt,v_Discount,
          v_Tax_ID, Cur_Lines.M_Product_UOM_ID, Cur_Lines.QuantityOrder, v_gross_unit_price, v_line_gross_amount,Cur_Lines.em_exs_user_qty,Cur_Lines.em_exs_user_uom_id,0
      );

      SELECT * INTO  v_RequisitionOrder_ID FROM Ad_Sequence_Next('M_RequisitionOrder', v_User_ID);

      INSERT INTO M_REQUISITIONORDER (
        M_REQUISITIONORDER_ID, AD_CLIENT_ID, AD_ORG_ID,
        CREATED, CREATEDBY, UPDATED, UPDATEDBY, ISACTIVE,
        M_REQUISITIONLINE_ID, C_ORDERLINE_ID, QTY
      ) VALUES (
        v_RequisitionOrder_ID, v_Client_ID, p_Org_ID,
        TO_DATE(NOW()), v_User_ID, TO_DATE(NOW()), v_User_ID, 'Y',
        Cur_Lines.M_RequisitionLine_ID, v_COrderLine_ID, Cur_Lines.QTY - Cur_Lines.ORDEREDQTY
      );
      PERFORM M_REQUISITIONLINE_STATUS(NULL, Cur_Lines.M_RequisitionLine_ID, v_User_ID);
    END LOOP;

    v_ResultStr := 'Post last Order ' || v_C_Order_ID;
    --PERFORM C_ORDER_POST1(null, v_C_Order_ID);
    v_Message := v_Message || ', ' || '@OrderDocumentno@ ' || v_DocumentNo;





  END; --BODY
  v_Message:='@Created@: ' || v_NoRecords || v_Message;
  PERFORM AD_UPDATE_PINSTANCE(p_PInstance_ID, NULL, 'N', v_Result, v_Message);

EXCEPTION
WHEN OTHERS THEN
  RAISE NOTICE '%','M_Requisition_Order error: ' || v_ResultStr;
  IF (p_PInstance_ID IS NOT NULL) THEN
    v_ResultStr:= '@ERROR=' || SQLERRM;
    RAISE NOTICE '%',v_ResultStr ;
    -- ROLLBACK;
    PERFORM AD_UPDATE_PINSTANCE(p_PInstance_ID, NULL, 'N', 0, v_ResultStr);
  ELSE
    RAISE EXCEPTION '%', SQLERRM;
  END IF;
END ; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION m_requisition_createpo(character varying)
  OWNER TO tad;












-- Function: m_requisitionline_trg()

-- DROP FUNCTION m_requisitionline_trg();

CREATE OR REPLACE FUNCTION m_requisitionline_trg()
  RETURNS trigger AS
$BODY$ DECLARE 

/*************************************************************************
* The contents of this file are subject to the Openbravo  Public  License
* Version  1.1  (the  "License"),  being   the  Mozilla   Public  License
* Version 1.1  with a permitted attribution clause; you may not  use this
* file except in compliance with the License. You  may  obtain  a copy of
* the License at http://www.openbravo.com/legal/license.html
* Software distributed under the License  is  distributed  on  an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
* License for the specific  language  governing  rights  and  limitations
* under the License.
* The Original Code is Openbravo ERP.
* The Initial Developer of the Original Code is Openbravo SLU
* All portions are Copyright (C) 2008-2014 Openbravo SLU
* All Rights Reserved.
* Contributor(s):  ______________________________________.
************************************************************************/
  v_DocStatus VARCHAR(60);
  v_ReqStatus VARCHAR(60);
  v_OrderedQty NUMERIC;
  v_productname m_product.name%TYPE;
  v_isgeneric   CHAR(1);
  v_Prdct_Base_UOM VARCHAR(32);
  v_Prec   NUMERIC;

BEGIN
    
    IF AD_isTriggerEnabled()='N' THEN IF TG_OP = 'DELETE' THEN RETURN OLD; ELSE RETURN NEW; END IF; 
    END IF;


  IF TG_OP = 'INSERT' THEN
    SELECT DocStatus, new.ReqStatus, 0 INTO v_DocStatus, v_ReqStatus, v_OrderedQty
    FROM M_Requisition
    WHERE M_Requisition_ID = new.M_Requisition_ID;
  ELSE
    SELECT DocStatus, old.ReqStatus, old.OrderedQty INTO v_DocStatus, v_ReqStatus, v_OrderedQty
    FROM M_Requisition
    WHERE M_Requisition_ID = old.M_Requisition_ID;
  END IF;

  IF (v_DocStatus = 'CL') THEN 
    RAISE EXCEPTION '%', '@20527@'; --OBTG:-20000--
  END IF;

  IF (v_DocStatus = 'CO' AND TG_OP = 'INSERT') THEN
    RAISE EXCEPTION '%', '@20525@'; --OBTG:-20000--
  END IF;
  
  IF (v_DocStatus = 'CO' AND TG_OP = 'DELETE') THEN
    RAISE EXCEPTION '%', '@20501@'; --OBTG:-20000--
  END IF;

  IF (v_ReqStatus = 'P') THEN
    RAISE EXCEPTION '%', '@20526@'; --OBTG:-20000--
  END IF;

  IF (v_ReqStatus <> 'O' 
      AND NOT (TG_OP = 'UPDATE' AND new.reqstatus = 'O')) THEN
    RAISE EXCEPTION '%', '@20520@'; --OBTG:-20000--
  END IF;

  IF (TG_OP = 'DELETE' AND v_OrderedQty <> 0 )THEN
    RAISE EXCEPTION '%', '@20521@'; --OBTG:-20000--
  END IF;

  IF TG_OP = 'UPDATE' THEN
    IF ((COALESCE(old.M_Requisition_ID, '0') <> COALESCE(new.M_Requisition_ID,'0'))
       OR (COALESCE(old.M_Product_ID, '-1') <> COALESCE(new.M_Product_ID, '-1'))
       OR (COALESCE(old.M_PriceList_ID, '-1') <> COALESCE(new.M_PriceList_ID, '-1'))
       OR (COALESCE(old.C_Currency_ID, '-1') <> COALESCE(new.C_Currency_ID, '-1'))
       OR (COALESCE(old.Qty, -1) <> COALESCE(new.Qty, -1))
       OR (COALESCE(old.PriceList, -1) <> COALESCE(new.PriceList, -1))
       OR (COALESCE(old.PriceActual, -1) <> COALESCE(new.PriceActual, -1 ))
       OR (COALESCE(old.Discount, -1) <> COALESCE(new.Discount, -1 ))
       OR (COALESCE(old.LineNetAmt, -1) <> COALESCE(new.LineNetAmt, -1 ))
       OR (COALESCE(old.C_BPartner_ID, '0') <> COALESCE(new.C_BPartner_ID, '0' ))
       OR (COALESCE(old.C_UOM_ID, '0') <> COALESCE(new.C_UOM_ID, '0' ))
       OR (COALESCE(old.M_Product_UOM_ID, '0') <> COALESCE(new.M_Product_UOM_ID, '0' ))
       OR (COALESCE(old.QuantityOrder, -1) <> COALESCE(new.QuantityOrder, -1 ))
       OR (COALESCE(old.M_AttributeSetInstance_ID, '-1') <> COALESCE(new.M_AttributeSetInstance_ID, '-1' ))
       OR (COALESCE(old.NeedByDate, TO_DATE('01-01-1900', 'DD-MM-YYYY')) <> COALESCE(new.NeedByDate, TO_DATE('01-01-1900', 'DD-MM-YYYY')))) THEN
      IF (v_DocStatus = 'CO') THEN
        RAISE EXCEPTION '%', '@20522@'; --OBTG:-20000--
      ELSIF (v_OrderedQty <> 0 ) THEN
        RAISE EXCEPTION '%', '@20523@'; --OBTG:-20000--
      END IF;
    END IF;
  END IF;

  IF (TG_OP = 'INSERT' OR TG_OP = 'UPDATE') THEN
  --Added by Usha
   --For uom conversion movement qty logic
  SELECT StdPrecision
 INTO v_Prec
 FROM C_Currency
 WHERE C_Currency.ISO_CODE ='INR';
  --Get Product Base UOM
   SELECT C_UOM_ID INTO v_Prdct_Base_UOM From M_Product Where M_Product_ID=NEW.M_Product_ID;

   IF(new.em_exs_user_uom_id = v_Prdct_Base_UOM)THEN
      new.C_UOM_ID := new.em_exs_user_uom_id;
      new.qty := new.em_exs_user_qty;

   ELSE
 
       new.C_UOM_ID := v_Prdct_Base_UOM;
       new.qty := c_uom_convert(new.em_exs_user_qty,new.em_exs_user_uom_id,v_Prdct_Base_UOM, to_char(v_Prec));
  
    END IF;--End  IF(new.em_exs_user_uom_id == v_Prdct_Base_UOM)THEN  

  --Ends by Usha
    IF (NEW.m_product_id IS NOT NULL) THEN
      SELECT isgeneric, name INTO v_isgeneric, v_productname
      FROM m_product
      WHERE m_product_id = NEW.m_product_id;
      IF (v_isgeneric = 'Y') THEN
        RAISE EXCEPTION '%', '@CannotUseGenericProduct@'; --OBTG:-20000--
      END IF;
    END IF;
  END IF;
IF TG_OP = 'DELETE' THEN RETURN OLD; ELSE RETURN NEW; END IF; 

END 

; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION m_requisitionline_trg()
  OWNER TO tad;




-- Function: m_inout_post(character varying, character varying)

-- DROP FUNCTION m_inout_post(character varying, character varying);

CREATE OR REPLACE FUNCTION m_inout_post(p_pinstance_id character varying, p_inout_id character varying)
  RETURNS void AS
$BODY$ DECLARE 
/*************************************************************************
  * The contents of this file are subject to the Compiere Public
  * License 1.1 ("License"); You may not use this file except in
  * compliance with the License. You may obtain a copy of the License in
  * the legal folder of your Openbravo installation.
  * Software distributed under the License is distributed on an
  * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing rights
  * and limitations under the License.
  * The Original Code is  Compiere  ERP &  Business Solution
  * The Initial Developer of the Original Code is Jorg Janke and ComPiere, Inc.
  * Portions created by Jorg Janke are Copyright (C) 1999-2001 Jorg Janke,
  * parts created by ComPiere are Copyright (C) ComPiere, Inc.;
  * All Rights Reserved.
  * Contributor(s): Openbravo SLU
  * Contributions are Copyright (C) 2001-2015 Openbravo, S.L.U.
  *
  * Specifically, this derivative work is based upon the following Compiere
  * file and version.
  *************************************************************************
  * $Id: M_InOut_Post.sql,v 1.8 2003/09/05 04:58:06 jjanke Exp $
  ***
  * Title: Post M_InOut_ID
  * Description:
  *  Action: COmplete
  *  - Create Transaction
  *    (only stocked products)
  *  - Update Inventory (QtyReserved, QtyOnHand)
  *    (only stocked products)
  *  - Update OrderLine (QtyDelivered)
  *
  *  Action: Reverse Correction
  *  - Create Header and lines with negative Quantities (and header amounts)
  *  - Post it
  ************************************************************************/
  -- Logistice
  v_ResultStr VARCHAR(2000):=''; --OBTG:VARCHAR2--
  v_Message VARCHAR(2000):=''; --OBTG:VARCHAR2--
  v_Message_aux VARCHAR(2000):=''; --OBTG:VARCHAR2--
  v_Record_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_User VARCHAR(32); --OBTG:VARCHAR2--
  v_PUser VARCHAR(32); --OBTG:VARCHAR2--
  v_DocStatus VARCHAR(60); --OBTG:VARCHAR2--
  v_is_included NUMERIC:=0;
  v_DocType_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_isreturndoctype CHAR(1);
  v_available_period NUMERIC:=0;
  v_is_ready AD_Org.IsReady%TYPE;
  v_is_tr_allow AD_OrgType.IsTransactionsAllowed%TYPE;
  v_DateAcct TIMESTAMP;
  v_DateDelivered C_OrderLine.DateDelivered%TYPE;
  v_isacctle AD_OrgType.IsAcctLegalEntity%TYPE;
  v_org_bule_id AD_Org.AD_Org_ID%TYPE;
  v_locator VARCHAR(32);
  -- Parameter
  --TYPE RECORD IS REFCURSOR;
    Cur_Parameter RECORD;
    --
    Cur_InOut RECORD;
    Cur_InOutLine RECORD;
    Cur_Order RECORD;
    Cur_OrderLine RECORD;
    Cur_Lines RECORD;
    --
    v_Result NUMERIC:=1;
    v_AD_Org_ID VARCHAR(32); --OBTG:VARCHAR2--
    v_Warehouse_Org VARCHAR(32); --OBTG:VARCHAR2--
    v_AD_Client_ID VARCHAR(32); --OBTG:VARCHAR2--
    v_NextNo VARCHAR(32); --OBTG:VARCHAR2--
    v_Qty NUMERIC;
    v_QtyPO NUMERIC;
    v_QtySO NUMERIC;
    v_QuantityOrder NUMERIC;
    v_QuantityOrderPO NUMERIC;
    v_QuantityOrderSO NUMERIC;
    v_RDocumentNo VARCHAR(40) ; --OBTG:VARCHAR2--
    v_RInOut_ID VARCHAR(32); --OBTG:VARCHAR2--
    v_IsStocked NUMERIC;
    v_DoctypeReversed_ID VARCHAR(32); --OBTG:VARCHAR2--
    --MODIFIED BY F.IRIAZABAL
    v_QtyOrder NUMERIC;
    v_ProductUOM NUMERIC;
    v_BreakDown VARCHAR(60) ; --OBTG:VARCHAR2--
    v_ActualQty NUMERIC;
    v_QtyAux NUMERIC;
    v_Count NUMERIC:=0;
    v_Line VARCHAR(10) ; --OBTG:VARCHAR2--
    v_OrderID_old VARCHAR(32); --OBTG:VARCHAR2--
    Cur_MILines RECORD;
    FINISH_PROCESS BOOLEAN:=false;
    v_Aux NUMERIC;
    v_isSoTrx CHAR(1);
    v_ProductName M_Product.name%TYPE;
    v_reservation_id    VARCHAR(32); --OBTG:VARCHAR2--
    v_M_Warehouse_ID    VARCHAR(32); --OBTG:VARCHAR2--
    v_voidmovementdate M_Inout.MovementDate%TYPE;
    v_voiddate_acct M_Inout.DateAcct%TYPE;
    v_bpartner_blocked VARCHAR(1):='N'; --OBTG:VARCHAR2--
    v_goods_blocked VARCHAR(1):='N'; --OBTG:VARCHAR2--
    v_bpartner_name c_bpartner.name%TYPE;
    v_DocAction VARCHAR(60); --OBTG:VARCHAR2--
    v_voiddoccount NUMERIC:=0;
    CUR_MINOUT RECORD;
    v_penqty NUMERIC;
    v_qtysumorders NUMERIC;
    v_released  NUMERIC;
    
    v_bp_isactive c_bpartner.isactive%Type;
    v_IsQtyVariable M_Product.IsQuantityVariable%TYPE;
    v_IsReversedDoc CHAR(1);
    v_productid varchar(32);
    v_uomid varchar(32);
    v_mid varchar(32);
    v_recbags CHAR(1);
    v_sotrx CHAR(1);
    CUR_Minout_Mtrx RECORD;
    V_TRXCOST NUMERIC :=0;
    v_MTransaction_Id   VARCHAR(32); --OBTG:VARCHAR2--
    v_Movementtype  VARCHAR(60); --OBTG:VARCHAR2--
    CUR_VOIDtrxCost_Update RECORD;
    v_C_Currency_ID VARCHAR(32); --OBTG:VARCHAR2--
    v_iscostcalculated VARCHAR(1);
    cur_tolerance RECORD;
    V_IsFeed CHAR(1);
    v_res BOOLEAN:=false;

    v_MovementDate TIMESTAMP;
    Cur_Check  RECORD;
    V_checkissotrx BOOLEAN:=false;
    v_MovementQty NUMERIC;
    v_Isintegration CHAR(1);
    CUR_transactions RECORD;
    v_corderid VARCHAR(32);
    v_corderdocstat VARCHAR(60);
    v_corderdocno VARCHAR(40);
    v_layerhatchery CHAR(1);
    v_broilerhatchery CHAR(1);
    v_countcheck NUMERIC;
    v_feed CHAR(1);
    v_return CHAR(1);
    v_blanklinecount NUMERIC;
v_retfrmcustlineid VARCHAR(32);
v_shipmntofretfrmcust_id VARCHAR(32);
v_shipmntofretfrmcust_trx_id VARCHAR(32);
v_shipmntofretfrmcust_trx_cost NUMERIC;
v_shipmntofretfrmcust_qty NUMERIC;
v_shipmntofretfrmcust_currency VARCHAR(32);
v_shipmntofretfrmcust_unitcost NUMERIC;



  BEGIN
  
    IF(p_PInstance_ID IS NOT NULL) THEN
      --  Update AD_PInstance
      RAISE NOTICE '%','Updating PInstance - Processing ' || p_PInstance_ID ;
      v_ResultStr:='PInstanceNotFound';
      PERFORM AD_UPDATE_PINSTANCE(p_PInstance_ID, NULL, 'Y', NULL, NULL) ;
      -- Get Parameters
      v_ResultStr:='ReadingParameters';
      FOR Cur_Parameter IN
        (SELECT i.Record_ID,
          i.AD_User_ID,
          p.ParameterName,
          p.P_String,
          p.P_Number,
          p.P_Date
        FROM AD_PInstance i
        LEFT JOIN AD_PInstance_Para p
          ON i.AD_PInstance_ID=p.AD_PInstance_ID
        WHERE i.AD_PInstance_ID=p_PInstance_ID
        ORDER BY p.SeqNo
        )
      LOOP
        v_Record_ID:=Cur_Parameter.Record_ID;
        v_User:=Cur_Parameter.AD_User_ID;
        IF (Cur_Parameter.parametername = 'voidedDocumentDate') THEN
          v_voidmovementdate := TO_DATE(Cur_Parameter.p_string, 'YYYY-MM-DD');
        ELSIF (Cur_Parameter.parametername = 'voidedDocumentAcctDate') THEN
          v_voiddate_acct := TO_DATE(Cur_Parameter.p_string, 'YYYY-MM-DD');
        END IF;
      END LOOP; -- Get Parameter
      RAISE NOTICE '%','  Record_ID=' || v_Record_ID ;
    ELSE
      RAISE NOTICE '%','--<<M_InOut_Post>>' ;
      v_Record_ID:=p_InOut_ID;
      SELECT count(*),updatedby
        INTO v_Count,v_User
        FROM M_InOut
        WHERE M_InOut_ID=v_Record_ID
        GROUP BY updatedby;
      IF v_Count=0 THEN
        FINISH_PROCESS:=true;
      END IF;
    END IF;
    
  BEGIN --BODY

	--Added by jhansi for retricting blank line before completing goods receipt on 29th july 2019

        select count(*) into v_blanklinecount from m_inoutline where m_inout_id = v_Record_ID and m_product_id is null and MovementQty = 0 ;

         IF (v_blanklinecount > 0) THEN

         v_Message := 'Please delete the blank line before completing the receipt';
	 raise exception '%', v_Message ;

         END IF;
         
	--Ended by jhansi for retricting blank line before completing goods receipt

        select  IsReturn into v_return from c_doctype where c_doctype_id = (Select c_doctype_id from m_inout where m_inout_id = v_Record_ID);

	FOR CUR_MINOUT IN (Select * from m_inoutline where m_inout_id = v_Record_ID)

	LOOP

	

	SELECT m_product_id INTO v_productid FROM exs_bagtype WHERE exs_bagtype_id = CUR_MINOUT.em_exs_bagtype_id; 
	SELECT 	c_uom_id INTO v_uomid FROM m_product WHERE m_product_id = v_productid; 

	select issotrx into v_sotrx from m_inout where m_inout_id = v_Record_ID;

	select EM_Expur_Isreceived into v_recbags from m_product where m_product_id = CUR_MINOUT.m_product_id;
--Added by jhansi

--IF( v_sotrx ='Y') THEN

		                
		select c_order_id into v_corderid from c_orderline where c_orderline_id = CUR_MINOUT.c_orderline_id;

		select docstatus,documentno into v_corderdocstat,v_corderdocno from c_order where c_order_id = v_corderid;

				IF (v_corderdocstat = 'CL') THEN

			      --Raise exception '%','Cannot complete the shipment because the selected sales order ' || v_corderdocno ||' is closed'; 
				Raise exception '%','Cannot complete the Shipment or Receipt because the selected order ' || v_corderdocno ||' is closed'; 

				END IF;

			--END IF;

	--Ended by jhansi
	
	IF(upper(v_recbags) = 'Y' and v_sotrx ='N' and CUR_MINOUT.movementqty>0) THEN

		IF((CUR_MINOUT.em_exs_bagno IS NULL) OR (CUR_MINOUT.EM_Exs_Bagtype_ID IS NULL)) THEN

			Raise exception 'Please enter the no of bags and bag type in %',CUR_MINOUT.line; 

		END IF;

	END IF;


	
	--IF(CUR_MINOUT.em_exs_bagtype_id IS NOT NULL AND CUR_MINOUT.em_exs_bagno IS NOT NULL AND CUR_MINOUT.em_exs_bagno != 0 ) THEN --commented and added by jhansi
	IF(CUR_MINOUT.em_exs_bagtype_id IS NOT NULL AND CUR_MINOUT.em_exs_bagno IS NOT NULL AND CUR_MINOUT.em_exs_bagno != 0 and CUR_MINOUT.EM_Exs_Recvdqty > 0 ) THEN

	IF(CUR_MINOUT.em_exs_minoulineid IS NULL) THEN
	v_mid := get_uuid();

	select m_locator_id into v_locator from m_locator where 
	m_warehouse_id = (select m_warehouse_id from m_locator where m_locator_id = CUR_MINOUT.m_locator_id)  and EM_Expur_Use_Pak = 'Y' and ad_org_id = CUR_MINOUT.ad_org_id ;

	
	IF(v_sotrx ='N') THEN


	IF(v_locator is null) THEN

		Raise exception 'Please select Used Packing Material Godown';
	
	END IF;

 

	insert into m_inoutline(
	m_inoutline_id,ad_client_id,ad_org_id,isactive,created,
	createdby,updated,updatedby,line,m_inout_id,
	m_locator_id,m_product_id,movementqty,
	isinvoiced,isdescription,manage_prereservation,explode,em_expur_isreceived,
	em_exs_recvdqty,
	em_exs_receiveduom_id,em_exs_type,c_uom_id,em_exs_minoulineid)
	values(
	v_mid,CUR_MINOUT.ad_client_id,CUR_MINOUT.ad_org_id,CUR_MINOUT.isactive,CUR_MINOUT.created,CUR_MINOUT.createdby,
	CUR_MINOUT.updated,CUR_MINOUT.updatedby,CUR_MINOUT.line,CUR_MINOUT.m_inout_id,v_locator,
	v_productid,CUR_MINOUT.em_exs_bagno,CUR_MINOUT.isinvoiced,
	CUR_MINOUT.isdescription,CUR_MINOUT.manage_prereservation,CUR_MINOUT.explode,CUR_MINOUT.em_expur_isreceived,
	CUR_MINOUT.em_exs_bagno,
	v_uomid,'Free Item',v_uomid,v_mid
	);

	UPDATE m_inoutline SET em_exs_minoulineid=v_mid where m_inoutline_id=CUR_MINOUT.m_inoutline_id;

	END IF; --v_sotrx ='N'

   END IF;
   END IF;

--Added by jhansi for inserting bag line for return shipments

IF(v_return ='Y') THEN

	--IF(upper(v_recbags) = 'Y' and v_sotrx ='N' and CUR_MINOUT.movementqty>0) THEN 
	IF(upper(v_recbags) = 'Y' and v_sotrx ='N' ) THEN 

		IF((CUR_MINOUT.em_exs_bagno IS NULL) OR (CUR_MINOUT.EM_Exs_Bagtype_ID IS NULL)) THEN

			Raise exception 'Please enter the no of bags and bag type in %',CUR_MINOUT.line; 

		END IF;

	END IF;


	
	--IF(CUR_MINOUT.em_exs_bagtype_id IS NOT NULL AND CUR_MINOUT.em_exs_bagno IS NOT NULL AND CUR_MINOUT.em_exs_bagno != 0 ) THEN --commented and added by jhansi
	--IF(CUR_MINOUT.em_exs_bagtype_id IS NOT NULL AND CUR_MINOUT.em_exs_bagno IS NOT NULL AND CUR_MINOUT.em_exs_bagno != 0 and CUR_MINOUT.EM_Exs_Recvdqty > 0 ) THEN
	IF(CUR_MINOUT.em_exs_bagtype_id IS NOT NULL AND CUR_MINOUT.em_exs_bagno IS NOT NULL AND CUR_MINOUT.em_exs_bagno != 0 ) THEN 

	IF(CUR_MINOUT.em_exs_minoulineid IS NULL) THEN
	v_mid := get_uuid();

	select m_locator_id into v_locator from m_locator where 
	m_warehouse_id = (select m_warehouse_id from m_locator where m_locator_id = CUR_MINOUT.m_locator_id)  and EM_Expur_Use_Pak = 'Y' and ad_org_id = CUR_MINOUT.ad_org_id ;

	
	IF(v_sotrx ='N') THEN


	IF(v_locator is null) THEN

		Raise exception 'Please select Used Packing Material Godown';
	
	END IF;

 

	insert into m_inoutline(
	m_inoutline_id,ad_client_id,ad_org_id,isactive,created,
	createdby,updated,updatedby,line,m_inout_id,
	m_locator_id,m_product_id,movementqty,
	isinvoiced,isdescription,manage_prereservation,explode,em_expur_isreceived,
	em_exs_recvdqty,
	em_exs_receiveduom_id,em_exs_type,c_uom_id,em_exs_minoulineid)
	values(
	v_mid,CUR_MINOUT.ad_client_id,CUR_MINOUT.ad_org_id,CUR_MINOUT.isactive,CUR_MINOUT.created,CUR_MINOUT.createdby,
	CUR_MINOUT.updated,CUR_MINOUT.updatedby,CUR_MINOUT.line,CUR_MINOUT.m_inout_id,v_locator,
	v_productid,CUR_MINOUT.em_exs_bagno,CUR_MINOUT.isinvoiced,
	CUR_MINOUT.isdescription,CUR_MINOUT.manage_prereservation,CUR_MINOUT.explode,CUR_MINOUT.em_expur_isreceived,
	--CUR_MINOUT.em_exs_bagno,
	-CUR_MINOUT.em_exs_bagno,
	v_uomid,'Free Item',v_uomid,v_mid
	);

	UPDATE m_inoutline SET em_exs_minoulineid=v_mid where m_inoutline_id=CUR_MINOUT.m_inoutline_id;

	END IF; --v_sotrx ='N'

   END IF;
   END IF;



END IF; -- IF(v_return ='Y')

--Ended by jhansi for inserting bag line for return shipments

   END LOOP;


  
  	IF(NOT FINISH_PROCESS) THEN
  	  v_PUser:=v_User;
      SELECT io.AD_Client_ID, io.AD_Org_ID, io.CreatedBy, io.C_DocType_ID, io.DateAcct, dt.isreturn, io.m_warehouse_id, io.issotrx,docaction
        INTO v_AD_Client_ID, v_AD_Org_ID, v_User, v_DocType_ID, v_DateAcct, v_isreturndoctype, v_M_Warehouse_ID, v_isSoTrx,v_DocAction
        FROM M_InOut io JOIN c_doctype dt ON io.c_doctype_id = dt.c_doctype_id
        WHERE io.M_InOut_ID=v_Record_ID;
        IF(v_PUser IS NOT NULL) THEN
        	v_User:=v_PUser;
        END IF;
      SELECT count(*)
      INTO v_Count
      FROM AD_CLIENTINFO
      WHERE AD_CLIENT_ID=v_AD_Client_ID
        AND CHECKINOUTORG='Y';
      IF (v_Count>0) THEN
        v_ResultStr:='CheckingRestrictions - M_INOUT ORG IS IN C_BPARTNER ORG TREE';
        SELECT count(*)
        INTO v_Count
        FROM M_InOut m,
          C_BPartner bp
        WHERE m.M_InOut_ID=v_Record_ID
          AND m.C_BPARTNER_ID=bp.C_BPARTNER_ID
          AND AD_IsOrgIncluded(m.AD_ORG_ID, bp.AD_ORG_ID, bp.AD_CLIENT_ID)=-1;
        IF v_Count>0 THEN
          RAISE EXCEPTION '%', '@NotCorrectOrgBpartnerInout@' ; --OBTG:-20000--
        END IF;
      END IF;
       Declare
       v_Message_product VARCHAR(2000) :='';
       Begin
          FOR Cur_Lines IN (
                             SELECT M.line
                             FROM M_InOut I,
                                  M_InOutLine M
                             WHERE I.M_InOut_ID=M.M_InOut_ID
                               AND I.M_INOUT_ID=v_Record_ID
                               AND (M.M_PRODUCT_ID IS NULL AND M.MOVEMENTQTY <> 0)
                               ORDER BY M.line
                            ) LOOP
               v_Message_product:=v_Message_product||Cur_Lines.line||', ';
          END LOOP;
          if v_Message_product != '' then
             RAISE EXCEPTION '%', '@Inline@ '||v_Message_product||' '||'@ProductNullAndMovementQtyGreaterZero@' ; --OBTG:-20000--
          end if ;
	     End ;
	     Declare
       v_Message_Qty VARCHAR(2000) :='';
	     BEGIN

 					FOR Cur_Lines IN (
                             SELECT M.line
                             FROM M_InOut I,
                                  M_InOutLine M
                             WHERE I.M_InOut_ID=M.M_InOut_ID
                               AND I.M_INOUT_ID=v_Record_ID
                               AND (M.M_PRODUCT_ID IS NOT NULL AND M.MOVEMENTQTY = 0)
                               ORDER BY M.line
                            ) LOOP
                                      v_Message_Qty:=10;

          v_Message_Qty:=v_Message_Qty||Cur_Lines.line||', ';
          END LOOP;
          IF v_Message_Qty != '' THEN
             RAISE EXCEPTION '%', '@Inline@ '||v_Message_Qty||' '||'@ProductNotNullAndMovementQtyZero@' ; --OBTG:-20000--
          END IF;
	     End ; 
      SELECT CASE WHEN COALESCE(instr(M_INOUT.Description,'*R*:'),0) = 0 THEN 'N' ELSE 'Y' END
            INTO v_IsReversedDoc
            FROM M_INOUT
            WHERE M_INOUT.M_INOUT_id = v_Record_ID;
      -- Skip MovementQtyCheck when it is reversed document
      if(v_isreturndoctype = 'N' AND v_isSoTrx = 'Y' and v_DocAction<>'RC' AND v_IsReversedDoc='N') then
        v_message := null;
        for Cur_OrderLine in (
          select c_orderline_id, line, m_product_id
          from m_inoutline
          where m_inout_id = v_Record_ID
          and c_orderline_id is not null
          order by line
        ) loop
          select COALESCE(sum(ABS(movementqty)), 0)
          into v_qty
          from m_inoutline
          where m_inout_id = v_Record_ID
          and c_orderline_id = Cur_OrderLine.c_orderline_id;
 
          select ABS(qtyordered), (coalesce(ABS(qtydelivered), 0) + v_qty)
          into v_QuantityOrder, v_qty
          from c_orderline
          where c_orderline_id = Cur_OrderLine.c_orderline_id;

          SELECT IsQuantityVariable INTO v_IsQtyVariable
          FROM M_Product
          WHERE M_Product_ID = Cur_OrderLine.M_Product_ID;

         
          IF(v_IsQtyVariable='N') THEN
            if(v_QuantityOrder < v_qty) then
              if v_message is null THEN
                v_message := Cur_OrderLine.line;
              ELSE
                v_message := v_message || ', ' || Cur_OrderLine.line;
              END IF;
            end if;
          END IF;

        end loop;

        if v_message is not null then
          RAISE EXCEPTION '%', '@MovementQtyCheck@'||' '||'@Inlines@'||' '||v_message; --OBTG:-20000--
        end if;
      end if;
    
    
    /* Check active business partner*/
      select bp.isactive into v_bp_isactive
      from m_inout io 
      left join c_bpartner bp on io.C_BPARTNER_ID = bp.C_BPARTNER_ID
      where io.M_INOUT_ID = v_Record_ID;

      IF(v_bp_isactive = 'N') THEN
        RAISE EXCEPTION '%', '@InActiveBusinessPartner@'; --OBTG:-20000--
      END IF;

      --Check whether warehouse belongs to the organization.
      SELECT count(AD_ORG_ID)
      INTO v_count
      FROM AD_Org_Warehouse
      WHERE M_Warehouse_ID=v_M_Warehouse_ID
      AND AD_Org_ID = v_AD_Org_ID;

      IF v_count = 0 AND v_isSoTrx = 'Y' THEN
        RAISE EXCEPTION '%','@WrongWarehouse@'; --OBTG:-20000--
      END IF;

      SELECT AD_Org_ID
      INTO v_Warehouse_Org
      FROM M_Warehouse
      WHERE M_Warehouse_ID = v_M_Warehouse_ID;

      IF(ad_org_isinnaturaltree(v_Warehouse_Org, v_AD_Org_ID, v_AD_Client_ID) = 'N' AND v_isSoTrx = 'N') THEN
        RAISE EXCEPTION '%','@WrongWarehouse@'; --OBTG:-20000--
      END IF;

      SELECT CASE WHEN (m.ISSOTRX='Y') THEN customer_blocking ELSE vendor_blocking END, CASE WHEN (m.ISSOTRX='Y') 
      THEN so_goods_blocking ELSE po_goods_blocking END, name, DocAction
      INTO v_bpartner_blocked, v_goods_blocked, v_bpartner_name, v_DocAction
      FROM M_InOut m, C_BPartner bp
      WHERE m.c_bpartner_id = bp.c_bpartner_id
      AND m.M_InOut_ID=v_Record_ID
      AND m.C_BPARTNER_ID=bp.C_BPARTNER_ID;
      
      IF (v_DocAction = 'CO' AND v_bpartner_blocked = 'Y' AND v_goods_blocked = 'Y' AND v_isreturndoctype='N') THEN
        RAISE EXCEPTION '%', '@ThebusinessPartner@'||' '|| v_bpartner_name ||' '||'@BusinessPartnerBlocked@'; --OBTG:-20000--
      END IF;
      
     v_ResultStr:='CheckingRestrictions';
     SELECT COUNT(*)
     INTO v_Count
     FROM C_DocType,
          M_InOut M
     WHERE M_Inout_ID = v_Record_ID
       AND C_DocType.DocBaseType IN ('MMR', 'MMS')
      AND C_DocType.IsSOTrx=M.IsSOTrx
      AND AD_ISORGINCLUDED(m.AD_Org_ID,C_DocType.AD_Org_ID, m.AD_Client_ID) <> -1
       AND M.C_DOCTYPE_ID=C_DocType.C_DOCTYPE_ID;
        IF (v_Count=0) THEN
          RAISE EXCEPTION '%', '@NotCorrectOrgDoctypeShipment@' ; --OBTG:-20000--
        END IF;
        SELECT COUNT(*), MAX(M.line)
        INTO v_Count, v_line
        FROM M_InOutLine M,
          M_Product P
        WHERE M.M_PRODUCT_ID=P.M_PRODUCT_ID
          AND P.M_ATTRIBUTESET_ID IS NOT NULL
          AND (P.ATTRSETVALUETYPE IS NULL OR P.ATTRSETVALUETYPE <> 'F')
          AND (SELECT ISONEATTRSETVALREQUIRED FROM M_ATTRIBUTESET WHERE M_ATTRIBUTESET_ID = P.M_ATTRIBUTESET_ID) = 'Y'
          AND COALESCE(M.M_ATTRIBUTESETINSTANCE_ID, '0') = '0'
          AND M.M_INOUT_ID=v_Record_ID;
        IF v_Count<>0 THEN
          RAISE EXCEPTION '%', '@Inline@'||' '||v_line||' '||'@productWithoutAttributeSet@' ; --OBTG:-20000--
        END IF;
        SELECT COUNT(*), MAX(M.line)
        INTO v_Count, v_Line
        FROM M_InOut I,
          M_InOutLine M,
          M_AttributeSetInstance P
        WHERE I.M_InOut_ID=M.M_InOut_ID
          AND M.M_AttributeSetInstance_ID=P.M_AttributeSetInstance_ID
          AND P.ISLOCKED='Y'
          AND I.ISSOTRX='Y'
          AND I.M_INOUT_ID=v_Record_ID;
        IF (v_Count<>0) THEN
          RAISE EXCEPTION '%', '@Inline@'||v_line||' '||'@lockedProduct@' ; --OBTG:-20000--
        END IF;
      -- check inout line instance location
        SELECT COUNT(*), MAX(M.line)
        INTO v_Count, v_Line
        FROM M_InOutLine M,
          M_Product P
        WHERE M.M_InOut_ID=v_Record_ID
          AND M.M_Locator_ID IS NULL
          AND p.m_product_id = m.m_product_id
          AND p.isstocked = 'Y'
          AND p.producttype = 'I';
        IF (v_Count <> 0) THEN
          RAISE EXCEPTION '%', '@Inline@'||v_line||' '||'@InoutLineWithoutLocator@' ; --OBTG:-20000--
        END IF;	  
      --check if bom non-stockable is exploded
        SELECT COUNT(*), MAX(M.line)
        INTO v_Count, v_Line
        FROM M_InOutLine M,    
          M_Product P
        WHERE M.M_InOut_ID=v_Record_ID
          AND P.isBOM='Y' 
          AND P.isstocked='N'
          AND M.explode='N'
          AND p.m_product_id = m.m_product_id;
        IF (v_Count <> 0) THEN
          RAISE EXCEPTION '%', '@Inline@'||v_line||' '||'@InoutLineNotExploded@' ; --OBTG:-20000--
        END IF;
    --Check negative quantities on return inouts
    IF (v_isreturndoctype = 'Y') THEN
      SELECT count(*) INTO v_count
      FROM m_inoutline iol JOIN c_orderline ol ON iol.c_orderline_id = ol.c_orderline_id
      WHERE iol.m_inout_id = v_record_id
        AND iol.movementqty > 0
        AND canceled_inoutline_id IS NULL
        AND ol.c_order_discount_id IS NULL;
      IF (v_Count <> 0) THEN
        RAISE EXCEPTION '%', '@ReturnInOutNegativeQty@'; --OBTG:-20000--
      END IF;
    END IF;
      SELECT count(*) INTO v_count
      FROM dual
      WHERE EXISTS (
          SELECT 1
          FROM m_inoutline il JOIN m_product p ON il.m_product_id = p.m_product_id
          WHERE il.m_inout_id = v_record_id
            AND p.isgeneric = 'Y');
      IF (v_count > 0) THEN
        SELECT max(p.name) INTO v_productname
        FROM m_inoutline il JOIN m_product p ON il.m_product_id = p.m_product_id
        WHERE il.m_inout_id = v_record_id
          AND p.isgeneric = 'Y';
        RAISE EXCEPTION '%', '@CannotUseGenericProduct@ ' || v_productName; --OBTG:-20000--
      END IF;
      
        -- Process Shipments
      SELECT COUNT(*) INTO v_Aux
      FROM M_InOutLine
      WHERE M_InOut_ID = v_Record_ID;

      IF v_Aux > 0 THEN  
        SELECT COUNT(*)
        INTO v_Count
        FROM M_INOUT IO, M_INOUTLINE IOL
        WHERE IO.M_INOUT_ID = IOL.M_INOUT_ID
        AND AD_ISORGINCLUDED(IOL.AD_Org_ID, IO.AD_Org_ID, IO.AD_Client_ID) = -1
        AND IO.M_INOUT_ID = v_Record_ID;
        IF (v_Count>0) THEN
          RAISE EXCEPTION '%', '@NotCorrectOrgLines@' ; --OBTG:-20000--
        END IF;
      END IF;
      
      -- Check the header belongs to a organization where transactions are posible and ready to use
      SELECT AD_Org.IsReady, Ad_OrgType.IsTransactionsAllowed
      INTO v_is_ready, v_is_tr_allow
      FROM M_INOUT, AD_Org, AD_OrgType
      WHERE AD_Org.AD_Org_ID=M_INOUT.AD_Org_ID
      AND AD_Org.AD_OrgType_ID=AD_OrgType.AD_OrgType_ID
      AND M_INOUT.M_INOUT_ID=v_Record_ID;
      IF (v_is_ready='N') THEN
        RAISE EXCEPTION '%', '@OrgHeaderNotReady@'; --OBTG:-20000--
      END IF;
      IF (v_is_tr_allow='N') THEN
        RAISE EXCEPTION '%', '@OrgHeaderNotTransAllowed@'; --OBTG:-20000--
      END IF;
        
      SELECT AD_ORG_CHK_DOCUMENTS('M_INOUT', 'M_INOUTLINE', v_Record_ID, 'M_INOUT_ID', 'M_INOUT_ID') INTO v_is_included FROM dual;
      IF (v_is_included=-1) THEN
        RAISE EXCEPTION '%', '@LinesAndHeaderDifferentLEorBU@'; --OBTG:-20000--
      END IF;
      
      -- Check the period control is opened (only if it is legal entity with accounting)
      -- Gets the BU or LE of the document
      SELECT AD_GET_DOC_LE_BU('M_INOUT', v_Record_ID, 'M_INOUT_ID', 'LE')
      INTO v_org_bule_id
      FROM DUAL;
      
      SELECT AD_OrgType.IsAcctLegalEntity
      INTO v_isacctle
      FROM AD_OrgType, AD_Org
      WHERE AD_Org.AD_OrgType_ID = AD_OrgType.AD_OrgType_ID
      AND AD_Org.AD_Org_ID=v_org_bule_id;
      
      IF (v_isacctle='Y') THEN    
        SELECT C_CHK_OPEN_PERIOD(v_AD_Org_ID, v_DateAcct, NULL, v_DocType_ID) 
        INTO v_available_period
        FROM DUAL;

        IF (v_available_period<>1) THEN
          IF (v_docAction <> 'RC') THEN
             RAISE EXCEPTION '%', '@PeriodNotAvailable@'; --OBTG:-20000--
          END IF;
        END IF;
      END IF;  
  
        FOR Cur_InOut IN
          (SELECT *
          FROM M_INOUT
          WHERE(M_InOut_ID=v_Record_ID
            OR(v_Record_ID IS NULL
            AND DocAction='CO'))
            AND IsActive='Y'  FOR UPDATE
          )
        LOOP
          RAISE NOTICE '%','Shipment_ID=' || Cur_InOut.M_InOut_ID || ', Doc=' || Cur_InOut.DocumentNo || ', Status=' || Cur_InOut.DocStatus || ', Action=' || Cur_InOut.DocAction ;
          v_ResultStr:='HeaderLoop';
          /**
          * Shipment not processed
          */
          IF(Cur_InOut.Processed='N' AND Cur_InOut.DocStatus='DR' AND Cur_InOut.DocAction='CO') THEN
            -- For all active shipment lines
            v_ResultStr:='HeaderLoop-1';
            
        IF v_Aux=0 THEN
        RAISE EXCEPTION '%', '@ReceiptWithoutLines@'; --OBTG:-20000--
        END IF;

       --Added by jhansi for resolving insufficient stock issue
       IF(CUR_MINOUT.ad_org_id != '1D2962C9D0D74808B9C223B15797BE15' and CUR_MINOUT.ad_org_id != 'AC82185478A748469AA6B09357CA173C' and 
       CUR_MINOUT.ad_org_id != 'B47744BA3B364153809DC7280498B597' and CUR_MINOUT.ad_org_id != 'BD73955127E4442C96CC59D4FCFDE8E4' and
       CUR_MINOUT.ad_org_id != 'EF311B7833674B61BA06BB270017BE55' and CUR_MINOUT.ad_org_id != '7FDFFCB2D2284E8D8E0EB3FFCDA073C1'and
       CUR_MINOUT.ad_org_id != 'C764C6D619B04C539B354296016F9988') THEN

IF(p_pinstance_id is not null) THEN


   -- IF (v_sotrx = 'Y') THEN 

select em_exs_islayerhatchery, em_exs_isbroilerhatchery, EM_Cwpf_Is_Feed into v_layerhatchery, v_broilerhatchery, v_feed from ad_org 
where ad_org_id = CUR_MINOUT.ad_org_id ;

--select  IsReturn into v_return from c_doctype where c_doctype_id = Cur_InOut.c_doctype_id;

            IF ((v_layerhatchery = 'Y' OR v_broilerhatchery = 'Y' or v_feed = 'Y') and v_sotrx = 'Y' and v_return = 'N') THEN

select count(*) into v_countcheck from m_inoutline where M_InOut_ID=v_record_id and M_AttributeSetInstance_ID is not null;

 IF (v_countcheck > 0) THEN

                 --  PERFORM exs_attributeallocation( v_record_id );

                         END IF;

            END IF;
            END IF;
            END IF;

         --   END IF; -- IF(CUR_MINOUT.ad_org_id !=


       --Ended by jhansi   

          FOR Cur_InOutLine IN
            (SELECT *
            FROM M_INOUTLINE
            WHERE M_InOut_ID=Cur_InOut.M_InOut_ID
              AND IsActive='Y'  FOR UPDATE
            )
          LOOP
            -- Incomming or Outgoing :1:2
            v_Qty:=Cur_InOutLine.MovementQty;
            v_QuantityOrder:=Cur_InOutLine.QuantityOrder;
            IF(SUBSTR(Cur_InOut.MovementType, 2)='-') THEN
              v_Qty:=- Cur_InOutLine.MovementQty;
              v_QuantityOrder:=-Cur_InOutLine.QuantityOrder;
            END IF;
            IF(Cur_InOut.IsSOTrx='N') THEN
              v_QtySO:=0;
              v_QtyPO:=Cur_InOutLine.MovementQty;
              v_QuantityOrderSO:=0;
              v_QuantityOrderPO:=Cur_InOutLine.QuantityOrder;
            ELSE
              v_QtySO:=Cur_InOutLine.MovementQty;
              v_QtyPO:=0;
              v_QuantityOrderSO:=Cur_InOutLine.QuantityOrder;
              v_QuantityOrderPO:=0;
            END IF;
            -- UOM Conversion
            -- Is it a standard stocked product:3
            SELECT COUNT(*)
            INTO v_IsStocked
            FROM M_PRODUCT
            WHERE M_Product_ID=Cur_InOutLine.M_Product_ID
              AND IsStocked='Y'
              AND ProductType='I';
            -- Create Transaction for stocked product
            IF(Cur_InOutLine.M_Product_ID IS NOT NULL AND v_IsStocked=1 AND Cur_InOutLine.IsDescription <> 'Y') THEN
              IF (cur_inout.issotrx = 'Y' AND cur_inoutline.c_orderline_id IS NOT NULL AND v_qty < 0 AND cur_inoutline.canceled_inoutline_id IS NULL) THEN
                -- Manage reservations.
                SELECT count(*), max(m_reservation_id)
                  INTO v_aux, v_reservation_id
                FROM m_reservation
                WHERE c_orderline_id = cur_inoutline.c_orderline_id
                AND res_status NOT IN ('DR', 'CL');
                IF (v_aux > 1) THEN
                  RAISE EXCEPTION '%', '@SOLineWithMoreThanOneOpenReservation@'; --OBTG:-20000--
                ELSIF (v_aux = 1) THEN
                  SELECT * INTO  v_result, v_message FROM M_RESERVATION_CONSUMPTION(v_reservation_id, cur_inoutline.m_locator_id, cur_inoutline.m_attributesetinstance_id, cur_inoutline.movementqty, v_user);
                END IF;
              ELSIF (cur_inout.issotrx = 'Y' AND cur_inoutline.c_orderline_id IS NOT NULL AND v_qty > 0 AND cur_inoutline.canceled_inoutline_id IS NOT NULL) THEN
                -- Undo reservation
                DECLARE
                  cur_released_stock RECORD;
                  v_qtyaux NUMERIC;
                  v_undoqty NUMERIC;
                BEGIN
                  SELECT count(*), max(m_reservation_id)
                    INTO v_aux, v_reservation_id
                  FROM m_reservation
                  WHERE c_orderline_id = cur_inoutline.c_orderline_id
                  AND res_status NOT IN ('DR', 'CL');
                  IF (v_aux > 1) THEN
                    RAISE EXCEPTION '%', '@SOLineWithMoreThanOneOpenReservation@'; --OBTG:-20000--
                  ELSIF (v_aux = 1) THEN
                    v_qtyaux := v_qty;
                    FOR cur_released_stock IN (
                        SELECT m_reservation_stock_id, quantity, releasedqty
                        FROM m_reservation_stock
                        WHERE m_locator_id = cur_inoutline.m_locator_id
                          AND COALESCE(m_attributesetinstance_id, '0') = COALESCE(cur_inoutline.m_attributesetinstance_id, '0')
                          AND m_reservation_id = v_reservation_id
                          AND COALESCE(releasedqty, 0) > 0
                        ORDER BY CASE isallocated WHEN 'N' THEN 0 ELSE 1 END
                    ) LOOP
                      v_undoqty := LEAST(v_qtyaux, cur_released_stock.releasedqty);
                      UPDATE m_reservation_stock
                      SET releasedqty = releasedqty - v_undoqty
                      WHERE m_reservation_stock_id = cur_released_stock.m_reservation_stock_id;
                      v_qtyaux := v_qtyaux - v_undoqty;
                    END LOOP;
                  END IF;
                END;
              ELSIF (cur_inout.issotrx = 'N' AND cur_inoutline.canceled_inoutline_id IS NULL) THEN
                -- Manage pre-reserves
                DECLARE
                  cur_reserve_stock RECORD;
                  v_pendingqty NUMERIC;
                  v_qtyaux NUMERIC;
                  v_res_stock_id VARCHAR(32); --OBTG:VARCHAR2--
                BEGIN
                  v_pendingqty := v_qty;
                  FOR cur_reserve_stock IN (
                      SELECT rs.*
                      FROM m_reservation_stock rs JOIN m_reservation r ON rs.m_reservation_id = r.m_reservation_id
                      WHERE rs.c_orderline_id = cur_inoutline.c_orderline_id
                        AND rs.quantity <> COALESCE(rs.releasedqty, 0)
                        AND rs.m_locator_id IS NULL
                        AND r.res_status NOT IN ('DR', 'CL')
                  ) LOOP
                    v_qtyaux := LEAST(cur_reserve_stock.quantity - COALESCE(cur_reserve_stock.releasedqty, 0), v_pendingqty);
                    -- Check if exists a reserved stock for the same orderline, attributes and locator in the reservation
                    SELECT count(*), max(m_reservation_stock_id) INTO v_aux, v_res_stock_id
                    FROM m_reservation_stock
                    WHERE c_orderline_id = cur_inoutline.c_orderline_id
                      AND m_locator_id = cur_inoutline.m_locator_id
                      AND m_reservation_id = cur_reserve_stock.m_reservation_id
                      AND isallocated = cur_reserve_stock.isallocated
                      AND COALESCE(m_attributesetinstance_id, '0') = COALESCE(Cur_InOutLine.M_AttributeSetInstance_ID, '0');
                    -- Update existing prereserved stock to decrease reserved qty
                    UPDATE m_reservation_stock
                    SET quantity = quantity - v_qtyaux
                    WHERE m_reservation_stock_id = cur_reserve_stock.m_reservation_stock_id;
                    -- Insert or update reserved stock by same quantity
                    IF (v_aux > 0) THEN
                      UPDATE m_reservation_stock
                      SET quantity = quantity + v_qtyaux
                      WHERE m_reservation_stock_id = v_res_stock_id;
                    ELSE
                      INSERT INTO m_reservation_stock(
                        m_reservation_stock_id, ad_client_id, ad_org_id, isactive,
                        created, createdby, updated, updatedby,
                        m_reservation_id, m_attributesetinstance_id, m_locator_id, c_orderline_id,
                        quantity, releasedqty, isallocated
                      ) VALUES (
                        get_uuid(), cur_reserve_stock.ad_client_id, cur_reserve_stock.ad_org_id, 'Y',
                        TO_DATE(NOW()), v_user, TO_DATE(NOW()), v_user,
                        cur_reserve_stock.m_reservation_id, coalesce(cur_inoutline.m_attributesetinstance_id,'0'), cur_inoutline.m_locator_id, cur_inoutline.c_orderline_id,
                        v_qtyaux, 0, cur_reserve_stock.isallocated
                      );
                    END IF;
                    v_pendingqty := v_pendingqty - v_qtyaux;
                    IF (v_pendingqty <= 0) THEN
                      EXIT;
                    END IF;
                  END LOOP;
                  DELETE FROM m_reservation_stock
                  WHERE c_orderline_id = cur_inoutline.c_orderline_id
                    AND quantity = 0
                    AND COALESCE(releasedqty, 0) = 0;
                END;
              ELSIF (cur_inout.issotrx = 'N' AND cur_inoutline.canceled_inoutline_id IS NOT NULL AND v_qty < 0) THEN
                -- Revert to pre-reservations

		BEGIN
                  select  sum(iol.movementqty)
                  into v_qtysumorders
                  from m_inoutline iol
                  WHERE  iol.c_orderline_id=cur_inoutline.c_orderline_id
                  and iol.m_locator_id=cur_inoutline.m_locator_id;

                  select rs.quantity
                  into v_released
                  from m_reservation_stock rs
                  where c_orderline_id=cur_inoutline.c_orderline_id
                  and rs.m_locator_id=cur_inoutline.m_locator_id;

                EXCEPTION
                  WHEN DATA_EXCEPTION THEN
                  v_qtysumorders:=0;
                  v_released:=0;
                END;
                  v_penqty := -v_qty - ((v_qtysumorders+(-cur_inoutline.movementqty))-v_released);

                DECLARE
                  cur_reserve_stock     RECORD;
                  v_pendingqty          NUMERIC;
                  v_qtyaux              NUMERIC;
                  v_res_stock_id        VARCHAR(32); --OBTG:VARCHAR2--
                  v_aux_released NUMERIC:= 0;
                BEGIN
                  v_pendingqty:=v_penqty;
                  FOR cur_reserve_stock IN (
                      SELECT rs.quantity, COALESCE(rs.releasedqty,0) AS releasedqty, rs.m_reservation_stock_id, rs.m_reservation_id,
                          rs.ad_org_id, rs.ad_client_id, rs.isallocated
                      FROM m_reservation_stock rs JOIN m_reservation r ON rs.m_reservation_id = r.m_reservation_id
                      WHERE rs.c_orderline_id = cur_inoutline.c_orderline_id
                        AND rs.m_locator_id = cur_inoutline.m_locator_id
                        AND r.res_status NOT IN ('DR', 'CL')
                  ) LOOP
                    v_qtyaux := LEAST((cur_reserve_stock.quantity - COALESCE(cur_reserve_stock.releasedqty, 0)), v_pendingqty);
                    v_aux_released := v_aux_released + COALESCE(cur_reserve_stock.releasedqty, 0);
                    IF (cur_reserve_stock.quantity <> COALESCE(cur_reserve_stock.releasedqty, 0)) THEN
                      -- Check if exists a prereservation for the same orderline, attributes and locator in the reservation
                      SELECT count(*), max(m_reservation_stock_id) INTO v_aux, v_res_stock_id
                      FROM m_reservation_stock
                      WHERE c_orderline_id = cur_inoutline.c_orderline_id
                        AND m_locator_id IS NULL
                        AND m_reservation_id = cur_reserve_stock.m_reservation_id;
                      -- Update existing prereserved stock to decrease reserved qty

                      UPDATE m_reservation_stock
                      SET quantity = quantity - v_qtyaux
                      WHERE m_reservation_stock_id = cur_reserve_stock.m_reservation_stock_id;
                      -- Insert or update reserved stock by same quantity
                      IF (v_aux > 0) THEN
                        UPDATE m_reservation_stock
                        SET quantity = quantity + v_qtyaux
                        WHERE m_reservation_stock_id = v_res_stock_id;
                      ELSE
                        INSERT INTO m_reservation_stock (
                          m_reservation_stock_id, ad_client_id, ad_org_id, isactive,
                          created, createdby, updated, updatedby,
                          m_reservation_id, m_attributesetinstance_id, m_locator_id, c_orderline_id,
                          quantity, releasedqty, isallocated
                        ) VALUES (
                          get_uuid(), cur_reserve_stock.ad_client_id, cur_reserve_stock.ad_org_id, 'Y',
                          TO_DATE(NOW()), v_user, TO_DATE(NOW()), v_user,
                          cur_reserve_stock.m_reservation_id, '0', NULL, cur_inoutline.c_orderline_id,
                          v_qtyaux, 0, cur_reserve_stock.isallocated
                        );
                      END IF;
                      v_pendingqty := v_pendingqty - v_qtyaux;
                      IF (v_pendingqty <= 0) THEN
                        EXIT;
                      END IF;
                    END IF;
                  END LOOP;
                  IF (v_pendingqty > 0 AND v_aux_released > 0) THEN
                    -- Not all quantity has been reverted to pre-reservation having released quantity.
                    RAISE EXCEPTION '%', '@ReceiptVoidReleasedQtyFound@'; --OBTG:-20000--
                  END IF;
                  DELETE FROM m_reservation_stock
                  WHERE c_orderline_id = cur_inoutline.c_orderline_id
                    AND quantity = 0
                    AND COALESCE(releasedqty, 0) = 0;
                END;

              END IF;

     /*  IF(Cur_InOutLine.ad_org_id != '1D2962C9D0D74808B9C223B15797BE15' and Cur_InOutLine.ad_org_id != 'AC82185478A748469AA6B09357CA173C' and 
       Cur_InOutLine.ad_org_id != 'B47744BA3B364153809DC7280498B597' and Cur_InOutLine.ad_org_id != 'BD73955127E4442C96CC59D4FCFDE8E4' and
       Cur_InOutLine.ad_org_id != 'EF311B7833674B61BA06BB270017BE55' and Cur_InOutLine.ad_org_id != '7FDFFCB2D2284E8D8E0EB3FFCDA073C1'and
       Cur_InOutLine.ad_org_id != 'C764C6D619B04C539B354296016F9988') THEN

        IF ((v_layerhatchery = 'Y' or v_broilerhatchery = 'Y' or v_feed = 'Y') and v_sotrx='Y' and v_return = 'N') THEN -- Added by jhansi for skipping inserting transaction here for insufficient stock issue for hatchery


 IF(p_pinstance_id is not null and Cur_InOutLine.M_AttributeSetInstance_ID is null) THEN

select MovementDate,issotrx into v_MovementDate , V_checkissotrx from m_inout where m_inout_id = v_Record_ID;
select MovementQty into v_MovementQty from m_inoutline where m_inout_id=v_Record_ID and  M_Product_ID = Cur_InOutLine.M_Product_ID 
                                                             and m_inoutline_id =Cur_InOutLine.m_inoutline_id ;


  PERFORM Exs_Check(Cur_InOutLine.AD_Org_ID,Cur_InOutLine.AD_Client_ID,Cur_InOutLine.M_Product_ID,v_MovementQty,v_MovementDate,
Cur_InOutLine.M_Locator_ID,Cur_InOutLine.M_AttributeSetInstance_ID);



 v_ResultStr:='CreateTransaction';

     

              SELECT * INTO  v_NextNo FROM Ad_Sequence_Next('M_Transaction', Cur_InOutLine.AD_Org_ID) ;
                INSERT
              INTO M_TRANSACTION
                (
                  M_Transaction_ID, M_InOutLine_ID, AD_Client_ID, AD_Org_ID,
                  IsActive, Created, CreatedBy, Updated,
                  UpdatedBy, MovementType, M_Locator_ID, M_Product_ID,
                  M_AttributeSetInstance_ID, MovementDate, MovementQty, M_Product_UOM_ID,
                  QuantityOrder, C_UOM_ID
                )
                VALUES
                (
                  v_NextNo, Cur_InOutLine.M_InOutLine_ID, Cur_InOutLine.AD_Client_ID, Cur_InOutLine.AD_Org_ID,
                   'Y', TO_DATE(NOW()), v_User, TO_DATE(NOW()),
                  v_User, Cur_InOut.MovementType, Cur_InOutLine.M_Locator_ID, Cur_InOutLine.M_Product_ID,
                  COALESCE(Cur_InOutLine.M_AttributeSetInstance_ID, '0'), Cur_InOut.MovementDate, v_Qty, Cur_InOutLine.M_Product_UOM_ID,
                  v_QuantityOrder, Cur_InOutLine.C_UOM_ID
                )
                ;


END IF;

IF(p_pinstance_id is null ) THEN

 v_ResultStr:='CreateTransaction';

     

              SELECT * INTO  v_NextNo FROM Ad_Sequence_Next('M_Transaction', Cur_InOutLine.AD_Org_ID) ;
                INSERT
              INTO M_TRANSACTION
                (
                  M_Transaction_ID, M_InOutLine_ID, AD_Client_ID, AD_Org_ID,
                  IsActive, Created, CreatedBy, Updated,
                  UpdatedBy, MovementType, M_Locator_ID, M_Product_ID,
                  M_AttributeSetInstance_ID, MovementDate, MovementQty, M_Product_UOM_ID,
                  QuantityOrder, C_UOM_ID
                )
                VALUES
                (
                  v_NextNo, Cur_InOutLine.M_InOutLine_ID, Cur_InOutLine.AD_Client_ID, Cur_InOutLine.AD_Org_ID,
                   'Y', TO_DATE(NOW()), v_User, TO_DATE(NOW()),
                  v_User, Cur_InOut.MovementType, Cur_InOutLine.M_Locator_ID, Cur_InOutLine.M_Product_ID,
                  COALESCE(Cur_InOutLine.M_AttributeSetInstance_ID, '0'), Cur_InOut.MovementDate, v_Qty, Cur_InOutLine.M_Product_UOM_ID,
                  v_QuantityOrder, Cur_InOutLine.C_UOM_ID
                )
                ;


END IF;
ELSE  --IF (v_layerhatchery = 'Y' or v_broilerhatchery = 'Y' )

              -- Added by jhansi for Negative Stock Control
 IF(p_pinstance_id is not null) THEN
select MovementDate,issotrx into v_MovementDate , V_checkissotrx from m_inout where m_inout_id = v_Record_ID;
select MovementQty into v_MovementQty from m_inoutline where m_inout_id=v_Record_ID and  M_Product_ID = Cur_InOutLine.M_Product_ID 
                                                             and m_inoutline_id =Cur_InOutLine.m_inoutline_id ;

-- IF (V_checkissotrx = 'Y' ) THEN 

    IF (V_checkissotrx = 'Y' and v_return = 'N') THEN 
    
      select EM_Cwpm_Isintegration into v_Isintegration from ad_org where ad_org_id = Cur_InOutLine.AD_Org_ID;

            IF (v_Isintegration = 'Y') THEN 

             PERFORM Exma_IntStockCheck(Cur_InOutLine.AD_Org_ID,Cur_InOutLine.AD_Client_ID, Cur_InOutLine.M_Product_ID,v_MovementQty,v_MovementDate,Cur_InOutLine.M_Locator_ID,Cur_InOutLine.M_AttributeSetInstance_ID);

        ELSE

              PERFORM Exs_Check(Cur_InOutLine.AD_Org_ID,Cur_InOutLine.AD_Client_ID,Cur_InOutLine.M_Product_ID,v_MovementQty,v_MovementDate,
Cur_InOutLine.M_Locator_ID,Cur_InOutLine.M_AttributeSetInstance_ID);


            END IF;


     END IF;

END IF; --if(p_pinstance_id is not null) ends

-- Ended by jhansi
     v_ResultStr:='CreateTransaction';

     

              SELECT * INTO  v_NextNo FROM Ad_Sequence_Next('M_Transaction', Cur_InOutLine.AD_Org_ID) ;
                INSERT
              INTO M_TRANSACTION
                (
                  M_Transaction_ID, M_InOutLine_ID, AD_Client_ID, AD_Org_ID,
                  IsActive, Created, CreatedBy, Updated,
                  UpdatedBy, MovementType, M_Locator_ID, M_Product_ID,
                  M_AttributeSetInstance_ID, MovementDate, MovementQty, M_Product_UOM_ID,
                  QuantityOrder, C_UOM_ID
                )
                VALUES
                (
                  v_NextNo, Cur_InOutLine.M_InOutLine_ID, Cur_InOutLine.AD_Client_ID, Cur_InOutLine.AD_Org_ID,
                   'Y', TO_DATE(NOW()), v_User, TO_DATE(NOW()),
                  v_User, Cur_InOut.MovementType, Cur_InOutLine.M_Locator_ID, Cur_InOutLine.M_Product_ID,
                  COALESCE(Cur_InOutLine.M_AttributeSetInstance_ID, '0'), Cur_InOut.MovementDate, v_Qty, Cur_InOutLine.M_Product_UOM_ID,
                  v_QuantityOrder, Cur_InOutLine.C_UOM_ID
                )
                ;
                         END IF; --closed IF (v_layerhatchery = 'Y' or v_broilerhatchery = 'Y' )

                         ELSE --IF(Cur_InOutLine.ad_org_id != 'C764C6D619B04C539B354296016F9988') THEN */

                          -- Added by jhansi for Negative Stock Control
 IF(p_pinstance_id is not null) THEN
select MovementDate,issotrx into v_MovementDate , V_checkissotrx from m_inout where m_inout_id = v_Record_ID;
select MovementQty into v_MovementQty from m_inoutline where m_inout_id=v_Record_ID and  M_Product_ID = Cur_InOutLine.M_Product_ID 
                                                             and m_inoutline_id =Cur_InOutLine.m_inoutline_id ;

    IF (V_checkissotrx = 'Y') THEN 

      select EM_Cwpm_Isintegration into v_Isintegration from ad_org where ad_org_id = Cur_InOutLine.AD_Org_ID;

            IF (v_Isintegration = 'Y') THEN 

             PERFORM Exma_IntStockCheck(Cur_InOutLine.AD_Org_ID,Cur_InOutLine.AD_Client_ID, Cur_InOutLine.M_Product_ID,v_MovementQty,v_MovementDate,Cur_InOutLine.M_Locator_ID,Cur_InOutLine.M_AttributeSetInstance_ID);

        ELSE

              PERFORM Exs_Check(Cur_InOutLine.AD_Org_ID,Cur_InOutLine.AD_Client_ID,Cur_InOutLine.M_Product_ID,v_MovementQty,v_MovementDate,
Cur_InOutLine.M_Locator_ID,Cur_InOutLine.M_AttributeSetInstance_ID);


            END IF;


     END IF;

END IF; --if(p_pinstance_id is not null) ends

-- Ended by jhansi
     v_ResultStr:='CreateTransaction';

     

              SELECT * INTO  v_NextNo FROM Ad_Sequence_Next('M_Transaction', Cur_InOutLine.AD_Org_ID) ;
                INSERT
              INTO M_TRANSACTION
                (
                  M_Transaction_ID, M_InOutLine_ID, AD_Client_ID, AD_Org_ID,
                  IsActive, Created, CreatedBy, Updated,
                  UpdatedBy, MovementType, M_Locator_ID, M_Product_ID,
                  M_AttributeSetInstance_ID, MovementDate, MovementQty, M_Product_UOM_ID,
                  QuantityOrder, C_UOM_ID
                )
                VALUES
                (
                  v_NextNo, Cur_InOutLine.M_InOutLine_ID, Cur_InOutLine.AD_Client_ID, Cur_InOutLine.AD_Org_ID,
                   'Y', TO_DATE(NOW()), v_User, TO_DATE(NOW()),
                  v_User, Cur_InOut.MovementType, Cur_InOutLine.M_Locator_ID, Cur_InOutLine.M_Product_ID,
                  COALESCE(Cur_InOutLine.M_AttributeSetInstance_ID, '0'), Cur_InOut.MovementDate, v_Qty, Cur_InOutLine.M_Product_UOM_ID,
                  v_QuantityOrder, Cur_InOutLine.C_UOM_ID
                )
                ;

                           -- END IF; --IF(Cur_InOutLine.ad_org_id != 'C764C6D619B04C539B354296016F9988') THEN 

-----------return material receipt started by jhansi

IF(v_return ='Y' and v_sotrx ='Y' and p_pinstance_id is not null) THEN


select c_orderline_id into v_retfrmcustlineid from m_inoutline where m_inoutline_id = Cur_InOutLine.m_inoutline_id;

select m_inoutline_id into v_shipmntofretfrmcust_id from c_orderline where c_orderline_id = v_retfrmcustlineid;


select m_transaction_id,MovementQty,C_CURRENCY_ID into v_shipmntofretfrmcust_trx_id,v_shipmntofretfrmcust_qty,v_shipmntofretfrmcust_currency from m_transaction where M_InOutLine_ID = v_shipmntofretfrmcust_id ;

select cost into v_shipmntofretfrmcust_trx_cost from m_transaction_cost where m_transaction_id = v_shipmntofretfrmcust_trx_id;


v_shipmntofretfrmcust_unitcost := (v_shipmntofretfrmcust_trx_cost/v_shipmntofretfrmcust_qty) ; 

INSERT INTO M_TRANSACTION_COST
( m_transaction_cost_id,ad_client_id ,ad_org_id ,created ,createdby,updated ,updatedby,isactive ,
m_transaction_id,cost,costdate ,c_currency_id,m_costadjustmentline_id, isunitcost,dateacct)
VALUES
(get_uuid(),Cur_InOutLine.ad_client_id, Cur_InOutLine.ad_org_id,TO_DATE(NOW()), Cur_InOutLine.CreatedBy, TO_DATE(NOW()), Cur_InOutLine.UpdatedBy,'Y',
v_NextNo,(v_shipmntofretfrmcust_unitcost*Cur_InOutLine.MovementQty),TO_DATE(NOW()),v_shipmntofretfrmcust_currency,null,'Y',TO_DATE(NOW()));

         

      UPDATE M_TRANSACTION 
      SET ISCOSTPERMANENT='Y',iscostcalculated='Y',transactioncost=(v_shipmntofretfrmcust_unitcost*Cur_InOutLine.MovementQty),c_currency_id=v_shipmntofretfrmcust_currency
      WHERE m_inoutline_id =Cur_InOutLine.M_InOutLine_ID;
     


END IF; -- IF(v_return ='Y' and v_sotrx ='Y' ) THEN

-----------return material receipt ended by jhansi

            END IF;

            -- Create Asset
            IF(Cur_InOutLine.M_Product_ID IS NOT NULL AND Cur_InOut.IsSOTrx='Y') THEN
              PERFORM A_ASSET_CREATE(NULL, Cur_InOutLine.M_InOutLine_ID) ;
            END IF;
            v_ResultStr:='UpdateOrderLine';
            IF(Cur_InOutLine.C_OrderLine_ID IS NOT NULL) THEN
              if(Cur_InOut.ISSOTRX='Y') THEN
                -- Sets DateDelivered with the recent shipment date
                -- of the shipment/s done for the orderline.
                SELECT MAX(M.MOVEMENTDATE) INTO v_DateDelivered
                FROM M_INOUTLINE ML, M_INOUT M
                WHERE ML.C_OrderLine_ID = Cur_InOutLine.C_OrderLine_ID
                AND ML.M_INOUT_ID = M.M_INOUT_ID
                AND M.DOCSTATUS='CO';
              ELSE
                v_DateDelivered := null;
              END IF;

              IF(v_QtySO > 0) THEN
                IF(v_DateDelivered IS NULL OR v_DateDelivered < Cur_InOut.MovementDate ) THEN
                  v_DateDelivered:=Cur_InOut.MovementDate;
                END IF;
              END IF;
              
              -- stocked product
              IF(Cur_InOutLine.M_Product_ID IS NOT NULL AND v_IsStocked=1) THEN
                -- Update OrderLine (if C-, Qty is negative)
                SELECT DOCSTATUS into v_DocStatus
                FROM C_ORDER
                WHERE C_ORDER_ID = (SELECT C_ORDER_ID
                                    FROM C_ORDERLINE 
                                    WHERE C_ORDERLINE_ID=Cur_InOutLine.C_OrderLine_ID);
                IF (v_DocStatus = 'DR') THEN
                  UPDATE C_ORDERLINE
                    SET QtyDelivered=QtyDelivered + v_QtySO,
                    DATEDELIVERED=(CASE WHEN (QtyDelivered + v_QtySO) > 0 THEN v_DateDelivered ELSE NULL END),
                    Updated=TO_DATE(NOW()),
                    UpdatedBy=v_User
                  WHERE C_OrderLine_ID=Cur_InOutLine.C_OrderLine_ID;
                ELSE 
                  UPDATE C_ORDERLINE
                    SET QtyReserved=QtyReserved - v_QtyPO - v_QtySO,
                    DATEDELIVERED=(CASE WHEN (QtyReserved - v_QtyPO - v_QtySO) > 0 THEN v_DateDelivered ELSE NULL END),
                    QtyDelivered=QtyDelivered + v_QtySO,
                    Updated=TO_DATE(NOW()),
                    UpdatedBy=v_User
                   WHERE C_OrderLine_ID=Cur_InOutLine.C_OrderLine_ID;
                END IF;
                -- Products not stocked
              ELSE
                -- Update OrderLine (if C-, Qty is negative)
                UPDATE C_ORDERLINE
                  SET QtyDelivered=QtyDelivered + v_QtySO,
                  DATEDELIVERED=(CASE WHEN (QtyDelivered + v_QtySO) > 0 THEN v_DateDelivered ELSE NULL END),
                  Updated=TO_DATE(NOW()),
                  UpdatedBy=v_User
                WHERE C_OrderLine_ID=Cur_InOutLine.C_OrderLine_ID;
              END IF;
            END IF;
            /*IF(Cur_InOutLine.M_Product_ID IS NOT NULL AND v_IsStocked=1) THEN
              SELECT * INTO  v_Result, v_Message FROM M_Check_Stock(Cur_InOutLine.M_Product_ID, v_AD_Client_ID, v_AD_Org_ID) ;
              IF v_Result=0 THEN
                SELECT name INTO v_ProductName FROM M_Product WHERE M_Product_id = Cur_InOutLine.M_Product_ID;
			    RAISE EXCEPTION '%', v_Message||' '||'@line@'||' '||Cur_InOutLine.line||', '||'@Product@'||' '||v_ProductName ; --OBTG:-20000--
              END IF;
            END IF;*/
          END LOOP; -- For all InOut Lines


 
          
          /*******************
          * PO Matching
          ******************/
          IF(Cur_InOut.IsSOTrx='N') THEN
            DECLARE
              Cur_SLines RECORD;
              Cur_ILines RECORD;
              v_Qty NUMERIC;
              v_MatchPO_ID VARCHAR(32) ; --OBTG:VARCHAR2--
              v_MatchInv_ID VARCHAR(32) ; --OBTG:VARCHAR2--
            BEGIN
              v_ResultStr:='MatchPO';
              FOR Cur_SLines IN
                (SELECT sl.AD_Client_ID,
                  sl.AD_Org_ID,
                  ol.C_OrderLine_ID,
                  sl.M_InOutLine_ID,
                  sl.M_Product_ID,
                  sl.M_AttributeSetInstance_ID,
                  sl.MovementQty,
                  ol.QtyOrdered
                FROM M_INOUTLINE sl,
                  C_ORDERLINE ol
                WHERE sl.C_OrderLine_ID=ol.C_OrderLine_ID
                  AND sl.M_Product_ID=ol.M_Product_ID  --    AND   sl.M_AttributeSetInstance_ID=ol.M_AttributeSetInstance_ID
                  AND sl.M_InOut_ID=Cur_InOut.M_InOut_ID
                )
              LOOP          

                v_Qty:=Cur_SLines.MovementQty;
                --IF (ABS(Cur_SLines.MovementQty) > ABS(Cur_SLines.QtyOrdered)) THEN
                -- v_Qty := Cur_SLines.QtyOrdered;
                --END IF;

                  SELECT * INTO  v_MatchPO_ID FROM Ad_Sequence_Next('M_MatchPO', Cur_SLines.AD_Org_ID) ;
                  -- The min qty. Modified by Ismael Ciordia
                  v_ResultStr:='InsertMatchPO ' || v_MatchPO_ID;
                  INSERT
                  INTO M_MATCHPO
                    (
                      M_MatchPO_ID, AD_Client_ID, AD_Org_ID, IsActive,
                      Created, CreatedBy, Updated, UpdatedBy,
                      M_InOutLine_ID, C_OrderLine_ID, M_Product_ID, DateTrx,
                      Qty, Processing, Processed, Posted
                    )
                    VALUES
                    (
                      v_MatchPO_ID, Cur_SLines.AD_Client_ID, Cur_SLines.AD_Org_ID, 'Y',
                      TO_DATE(NOW()), v_User, TO_DATE(NOW()), v_User,
                      Cur_SLines.M_InOutLine_ID, Cur_SLines.C_OrderLine_ID, Cur_SLines.M_Product_ID, TO_DATE(NOW()),
                      v_Qty, 'N', 'Y', 'N'
                    )
                  ;
                  
              END LOOP;
              v_ResultStr:='MatchInv';
              FOR Cur_ILines IN
                (SELECT sl.AD_Client_ID,
                  sl.AD_Org_ID,
                  il.C_InvoiceLine_ID,
                  sl.M_InOutLine_ID,
                  sl.M_Product_ID,
                  sl.M_AttributeSetInstance_ID,
                  sl.MovementQty,
                  il.QTYINVOICED,
                  i.DateAcct
                FROM M_INOUTLINE sl,
                  C_INVOICE i,
                  C_INVOICELINE il
                WHERE sl.M_InOutLine_ID=il.M_InOutLine_ID
                  AND sl.M_InOut_ID=Cur_InOut.M_InOut_ID
                  AND i.C_INVOICE_ID = il.C_INVOICE_ID
                )
              LOOP
                SELECT * INTO  v_MatchInv_ID FROM Ad_Sequence_Next('M_MatchInv', Cur_ILines.AD_Org_ID) ;
                -- The min qty. Modified by Ismael Ciordia
                v_Qty:=Cur_ILines.MovementQty;
                --IF (ABS(Cur_ILines.MovementQty) > ABS(Cur_ILines.QtyInvoiced)) THEN
                -- v_Qty := Cur_ILines.QtyInvoiced;
                --END IF;
                v_ResultStr:='InsertMatchPO ' || v_MatchPO_ID;
                INSERT
                INTO M_MATCHINV
                  (
                    M_MATCHINV_ID, AD_CLIENT_ID, AD_ORG_ID, ISACTIVE,
                    CREATED, CREATEDBY, UPDATED, UPDATEDBY,
                    M_INOUTLINE_ID, C_INVOICELINE_ID, M_PRODUCT_ID, DATETRX,
                    QTY, PROCESSING, PROCESSED, POSTED
                  )
                  VALUES
                  (
                    v_MatchInv_ID, Cur_ILines.AD_Client_ID, Cur_ILines.AD_Org_ID, 'Y',
                    TO_DATE(NOW()), v_User, TO_DATE(NOW()), v_User,
                    Cur_ILines.M_InOutLine_ID, Cur_ILines.C_InvoiceLine_ID, Cur_ILines.M_Product_ID, Cur_ILines.DateAcct,
                    v_Qty, 'N', 'Y', 'N'
                  )
                  ;
              END LOOP;
              -- Set check price difference to true in case the receipt line has a related invoice.
              UPDATE M_TRANSACTION
              SET checkpricedifference = 'Y'
              WHERE M_INOUTLINE_ID IN (SELECT DISTINCT il.m_inoutline_id
                                       FROM m_inoutline il
                                          JOIN m_matchinv mi ON il.m_inoutline_id = mi.m_inoutline_id
                                       WHERE il.m_inout_id = Cur_InOut.M_InOut_ID);
            END;
          ELSE
            --Void document is created automatically from main document . 
            --during completion of void document , we have to skip delivery rule for void document .
            select COALESCE(instr(M_INOUT.Description,'*R*:'),0) 
            into v_voiddoccount 
            from M_INOUT
            where M_INOUT.M_INOUT_id =v_Record_ID;
            if v_voiddoccount = 0 then
              v_ResultStr:='Check delivery rule for sales orders';
              v_Message_aux:='';
              v_orderid_old:='0';
              FOR Cur_Order IN 
                (SELECT c_order.deliveryrule, m_inoutline.line, c_order.c_order_id,
                        c_order.documentno, c_orderline.line as orderline
                 FROM M_InOutLine, C_Orderline, C_Order
                 WHERE M_Inoutline.c_orderline_id = c_orderline.c_orderline_id
                   AND c_orderline.c_order_id = c_order.c_order_id
                   AND m_inoutline.m_inout_id = cur_inout.m_inout_id
                   AND ((c_order.deliveryrule = 'O'
                        AND EXISTS (SELECT 1 FROM C_OrderLine ol
                                    WHERE ol.C_Order_ID = C_order.c_order_id
                                      and ol.qtyordered > ol.qtydelivered ))
                        OR (c_order.deliveryrule = 'L' 
                            AND c_orderline.qtyordered > c_orderline.qtydelivered))
                 ORDER BY c_order.c_order_id, c_orderline.line) LOOP
                --Order lines not completely delivered with delivery rule O or L
                IF (v_orderid_old <> cur_order.c_order_id OR cur_order.deliveryrule <> 'O' ) THEN
                  v_Message_aux := COALESCE(v_Message_aux,'') || '@Shipment@' || ' ' || cur_inout.documentno;
                  v_Message_aux := v_Message_aux || ' ' || '@line@' || ' ' || cur_order.line || ': ';
                  v_Message_aux := v_Message_aux || '@SalesOrderDocumentno@' || cur_order.documentno;
                  IF (cur_order.deliveryrule = 'O') THEN
                    v_Message_aux := v_Message_aux || ' ' || '@notCompleteDeliveryRuleOrder@' || '<br>';
                  ELSE
                    v_Message_aux := v_Message_aux || ' ' || '@line@' || ' ' || cur_order.orderline;
                    v_Message_aux := v_Message_aux || ' ' || '@notCompleteDeliveryRuleLine@' || '<br>';
                  END IF;
                END IF;
                v_orderid_old := cur_order.c_order_id;
              END LOOP;
              IF (v_Message_aux IS NOT NULL AND v_Message_aux <> '') THEN
                RAISE EXCEPTION '%', v_Message_aux; --OBTG:-20000--
              END IF;
            END IF;
          END IF;
          -- Close Shipment
          v_ResultStr:='CloseShipment';
          UPDATE M_INOUT
            SET Processed='Y',
            DocStatus='CO',
            DocAction='--',
            Process_Goods_Java='--',
            Updated=TO_DATE(NOW()),
            UpdatedBy=v_User
          WHERE M_INOUT.M_INOUT_ID=Cur_InOut.M_INOUT_ID;
          --
          
         
          -- Not Processed + Complete --
          /**
          * Reverse Correction
          */
        ELSIF(Cur_InOut.DocStatus='CO' AND Cur_InOut.DocAction='RC') THEN
          --Check if the m_inoutlines has an invoice lines related. In this case is not possible to void the m_inout.
	  SELECT COUNT(*)
          INTO v_count
          FROM M_INOUTLINE MIOL 
              JOIN C_INVOICELINE CIL ON MIOL.M_INOUTLINE_ID=CIL.M_INOUTLINE_ID 
              JOIN C_INVOICE CI ON CI.C_INVOICE_ID=CIL.C_INVOICE_ID
          WHERE M_INOUT_ID=Cur_InOut.m_inout_id
          AND CI.DOCSTATUS <> 'VO';
          IF (v_count <> 0) THEN
	     RAISE EXCEPTION '%','@VoidShipmentWithRelatedInvoice@'; --OBTG:-20000--
          END IF;
          --Check that there isn't any line with an invoice if the order's 
          --invoice rule is after delivery
          select count(*), max(line) into v_count, v_line
          from (
          SELECT m_inoutline.m_inoutline_id, m_inoutline.line
          from m_inoutline, c_order, c_orderline, c_invoiceline, m_inout, c_invoice
          where m_inoutline.c_orderline_id = c_orderline.c_orderline_id
            and c_orderline.c_order_id = c_order.c_order_id
            and c_orderline.c_orderline_id = c_invoiceline.c_orderline_id
            and m_inoutline.m_inout_id = m_inout.m_inout_id
            and c_invoiceline.c_invoice_id = c_invoice.c_invoice_id
            and m_inout.m_inout_id = Cur_InOut.m_inout_id
            and m_inout.issotrx = 'Y'
            and c_order.invoicerule in ('D', 'O', 'S')
            and c_invoice.processed='Y'
          group by m_inoutline.m_inoutline_id, m_inoutline.line
          having sum(c_invoiceline.qtyinvoiced) <> 0
          ) a;
          IF (v_count > 0 ) THEN
            v_Message := '@InoutDocumentno@' || ': ' || Cur_InOut.DocumentNo || ' ' || '@line@' || ': ' || v_line || '. ';
            v_Message := v_Message || '@VoidShipmentInvoiced@';
            RAISE EXCEPTION '%', v_Message; --OBTG:-20000--
          END IF;
          v_ResultStr:='CreateInOut';
          SELECT COALESCE(C_DOCTYPE_REVERSED_ID, C_DOCTYPE_ID)
          INTO v_DoctypeReversed_ID
          FROM C_DOCTYPE
          WHERE C_DOCTYPE_ID=Cur_InOut.C_DocType_ID;
          SELECT * INTO  v_RInOut_ID FROM Ad_Sequence_Next('M_InOut', Cur_InOut.M_InOut_ID) ; -- Get RInOut_ID
          SELECT * INTO  v_RDocumentNo FROM Ad_Sequence_Doctype(v_DoctypeReversed_ID, Cur_InOut.M_InOut_ID, 'Y') ; -- Get RDocumentNo
          IF(v_RDocumentNo IS NULL) THEN
            SELECT * INTO  v_RDocumentNo FROM AD_Sequence_Doc('DocumentNo_M_InOut', Cur_InOut.AD_Client_ID, 'Y') ;
          END IF;
          -- Indicate that it is invoiced (i.e. not printed on invoices)
          v_ResultStr:='SetInvoiced';
          UPDATE M_INOUTLINE  SET IsInvoiced='Y',Updated=TO_DATE(NOW()),UpdatedBy=v_User  WHERE M_InOut_ID=Cur_InOut.M_InOut_ID;
          --
          RAISE NOTICE '%','Reverse InOut_ID=' || v_RInOut_ID || ' DocumentNo=' || v_RDocumentNo ;
          v_ResultStr:='InsertInOut Reverse ' || v_RInOut_ID;
          --Added usha logic on 16-10-2017 for voided transaction update original m_inout id and add cost at the time of insertion itself 
        --  i)cost get from original m_transaction id and insert record into m_transaction_cost as well as update cost into m_transaction


       
          INSERT
          INTO M_INOUT
            (
              M_InOut_ID, C_Order_ID, IsSOTrx, AD_Client_ID,
              AD_Org_ID, IsActive, Created, CreatedBy,
              Updated, UpdatedBy, DocumentNo, C_DocType_ID,
              Description, IsPrinted, MovementType, MovementDate,
              DateAcct, C_BPartner_ID, C_BPartner_Location_ID, AD_User_ID,
              M_Warehouse_ID, POReference, DateOrdered, DeliveryRule,
              FreightCostRule, FreightAmt, C_Project_ID, C_Activity_ID,
              C_Campaign_ID, AD_OrgTrx_ID, User1_ID, User2_ID,
              C_Costcenter_ID, A_Asset_ID,
              DeliveryViaRule, M_Shipper_ID, C_Charge_ID, ChargeAmt,
              PriorityRule, DocStatus, DocAction, Processing,
              Processed, ISLOGISTIC, salesrep_id, Process_Goods_Java,
              calculate_freight, m_freightcategory_id, freight_currency_id,em_expur_void_m_inout_id 
            )
            VALUES
            (
              v_RInOut_ID, Cur_InOut.C_Order_ID, Cur_InOut.IsSOTrx, Cur_InOut.AD_Client_ID,
              Cur_InOut.AD_Org_ID, 'Y', TO_DATE(NOW()), v_User,
              TO_DATE(NOW()), v_User, v_RDocumentNo, v_DoctypeReversed_ID,
               '(*R*: ' || Cur_InOut.DocumentNo || ') ' || COALESCE(TO_CHAR(Cur_InOut.Description), ''), 'N', Cur_InOut.MovementType, Cur_InOut.MovementDate,
              Cur_InOut.DateAcct, Cur_InOut.C_BPartner_ID, Cur_InOut.C_BPartner_Location_ID, Cur_InOut.AD_User_ID,
              Cur_InOut.M_Warehouse_ID, Cur_InOut.POReference, Cur_InOut.DateOrdered, Cur_InOut.DeliveryRule,
              Cur_InOut.FreightCostRule, Cur_InOut.FreightAmt * -1, Cur_InOut.C_Project_ID, Cur_InOut.C_Activity_ID,
              Cur_InOut.C_Campaign_ID, Cur_InOut.AD_OrgTrx_ID, Cur_InOut.User1_ID, Cur_InOut.User2_ID,
              Cur_InOut.C_Costcenter_ID, Cur_InOut.A_Asset_ID,
              Cur_InOut.DeliveryViaRule, Cur_InOut.M_Shipper_ID, Cur_InOut.C_Charge_ID, Cur_InOut.ChargeAmt * -1,
              Cur_InOut.PriorityRule, 'DR', 'CO', 'N',
               'N', Cur_InOut.islogistic, Cur_InOut.salesrep_id, 'CO',
              Cur_InOut.calculate_freight, Cur_InOut.m_freightcategory_id, Cur_InOut.freight_currency_id,Cur_InOut.m_inout_id 
            )
            ;
          v_ResultStr:='InsertInOutLine';
          ---Added by usha
          FOR Cur_InOutLine IN
            (SELECT *
            FROM M_INOUTLINE
            WHERE M_InOut_ID=Cur_InOut.M_InOut_ID
              AND IsActive='Y'  FOR UPDATE
            )
          LOOP
         
          
            -- Create InOut Line
            SELECT * INTO  v_NextNo FROM Ad_Sequence_Next('M_InOutLine', Cur_InOut.M_InOut_ID) ;
            v_ResultStr:='CreateInOutLine';


                   

            INSERT
            INTO M_INOUTLINE
              (
                M_InOutLine_ID, Line, M_InOut_ID, C_OrderLine_ID,
                AD_Client_ID, AD_Org_ID, IsActive, Created,
                CreatedBy, Updated, UpdatedBy, M_Product_ID,
                M_AttributeSetInstance_ID, C_UOM_ID, M_Locator_ID, MovementQty,
                Description, IsInvoiced,  --MODIFIED BY F.IRIAZABAL
                QuantityOrder, M_Product_UOM_ID, IsDescription,
                canceled_inoutline_id, A_Asset_ID, C_Project_ID, C_BPartner_ID,
                User1_ID, User2_ID, C_CostCenter_ID, 
                explode,EM_Exs_Receiveduom_ID,EM_Exs_Recvdqty,
                EM_Exs_Bagtype_ID,EM_Exs_Bagno,em_exs_type
              )
              VALUES
              (
                v_NextNo, Cur_InOutLine.Line, v_RInOut_ID, Cur_InOutLine.C_OrderLine_ID,
                Cur_InOut.AD_Client_ID, Cur_InOut.AD_Org_ID, 'Y', TO_DATE(NOW()),
                v_User, TO_DATE(NOW()), v_User, Cur_InOutLine.M_Product_ID,
                Cur_InOutLine.M_AttributeSetInstance_ID, Cur_InOutLine.C_UOM_ID, Cur_InOutLine.M_Locator_ID, Cur_InOutLine.MovementQty * -1,
                 '*R*: ' || COALESCE(TO_CHAR(Cur_InOutLine.Description), ''), Cur_InOutLine.IsInvoiced, --MODIFIED BY F.IRIAZABAL
                Cur_InOutLine.QuantityOrder * -1, Cur_InOutLine.M_PRODUCT_UOM_ID, Cur_InOutLine.IsDescription,
                Cur_InOutLine.M_InOutLine_ID, Cur_InOutLine.A_Asset_ID, Cur_InOutLine.C_Project_ID, Cur_InOutLine.C_BPartner_ID,
                Cur_InOutLine.User1_ID, Cur_InOutLine.User2_ID, Cur_InOutLine.C_CostCenter_ID, 
                Cur_InOutLine.explode ,Cur_InOutLine.EM_Exs_Receiveduom_ID,Cur_InOutLine.EM_Exs_Recvdqty * -1,
                --null,null,Cur_InOutLine.em_exs_type --commented and added by jhansi
                Cur_InOutLine.EM_Exs_Bagtype_ID,Cur_InOutLine.EM_Exs_Bagno * -1,Cur_InOutLine.em_exs_type
                             
              )
              ;

  -- Added by jhansi for Negative Stock Control

 IF(p_pinstance_id is not null) THEN

    IF (Cur_InOut.IsSOTrx = 'N') THEN 

      select EM_Cwpm_Isintegration into v_Isintegration from ad_org where ad_org_id = Cur_InOutLine.AD_Org_ID;

            IF (v_Isintegration = 'Y') THEN 

             PERFORM Exma_IntStockCheck(Cur_InOutLine.AD_Org_ID,Cur_InOutLine.AD_Client_ID, Cur_InOutLine.M_Product_ID,Cur_InOutLine.MovementQty,Cur_InOut.MovementDate,Cur_InOutLine.M_Locator_ID,Cur_InOutLine.M_AttributeSetInstance_ID);

        ELSE

              PERFORM Exs_Check(Cur_InOutLine.AD_Org_ID,Cur_InOutLine.AD_Client_ID,Cur_InOutLine.M_Product_ID,Cur_InOutLine.MovementQty,Cur_InOut.MovementDate,
Cur_InOutLine.M_Locator_ID,Cur_InOutLine.M_AttributeSetInstance_ID);


            END IF;


     END IF;

END IF; --if(p_pinstance_id is not null) ends

-- Ended by jhansi

            -- Create InOut acctounting dimension
            v_ResultStr:='CreateInOutLineAcctDimension';
            INSERT
            INTO M_INOUTLINE_ACCTDIMENSION
              (
                M_InOutLine_Acctdimension_ID, M_InOutLine_ID, Quantity,
                AD_Client_ID, AD_Org_ID, IsActive, Created,
                CreatedBy, Updated, UpdatedBy, M_Product_ID, C_BPartner_ID,
                C_Project_ID, C_Campaign_ID, C_Activity_ID, A_Asset_ID,
                User1_ID, User2_ID, C_CostCenter_ID
              )
              SELECT
                get_uuid(), v_NextNo, Quantity * -1,
                AD_Client_ID, AD_Org_ID, 'Y', TO_DATE(NOW()),
                v_User, TO_DATE(NOW()), v_User, M_Product_ID, C_BPartner_ID,
                C_Project_ID, C_Campaign_ID, C_Activity_ID , A_Asset_ID,
                User1_ID, User2_ID, C_CostCenter_ID
              FROM M_INOUTLINE_ACCTDIMENSION where M_INOUTLINE_ID=Cur_InOutLine.M_INOUTLINE_ID
              and IsActive = 'Y';
         --  raise exception '%',Cur_InOutLine.EM_Exs_Recvdqty||'-h1h'||Cur_InOutLine.MovementQty;

            INSERT INTO M_MATCHINV
              (M_MATCHINV_ID, AD_CLIENT_ID, AD_ORG_ID, ISACTIVE, CREATED, CREATEDBY, UPDATED, UPDATEDBY,
              M_INOUTLINE_ID, C_INVOICELINE_ID, M_PRODUCT_ID, DATETRX, QTY, PROCESSING, PROCESSED, POSTED)
            SELECT
              GET_UUID(), MI.AD_CLIENT_ID, MI.AD_ORG_ID, MI.ISACTIVE, TO_DATE(NOW()), '0', TO_DATE(NOW()), '0',
              v_NextNo, MI.C_INVOICELINE_ID, MI.M_PRODUCT_ID, MI.DATETRX, -MI.QTY, 'N', 'Y', 'N'
            FROM M_MATCHINV MI
            WHERE MI.M_INOUTLINE_ID = Cur_InOutLine.M_InOutLine_ID;

          END LOOP;

          -- Close Order
          v_ResultStr:='CloseInOut';
          UPDATE M_INOUT
            SET Description=COALESCE(TO_CHAR(Description), '') || ' (*R*=' || v_RDocumentNo || ')',
            Processed='Y',
            DocStatus='VO', -- it IS reversed
            DocAction='--',
            Process_Goods_Java='--',
            Updated=TO_DATE(NOW()),
            UpdatedBy=v_User
          WHERE M_INOUT.M_INOUT_ID=Cur_InOut.M_INOUT_ID;

	   FOR Cur_InOutLine IN
            (SELECT *
            FROM M_INOUTLINE
            WHERE M_InOut_ID=Cur_InOut.M_InOut_ID
              AND IsActive='Y'  FOR UPDATE
            )
	  LOOP

 
          
            UPDATE M_INOUTLINE
              SET Description=COALESCE(TO_CHAR(Cur_InOutLine.Description), '') || ' : *R*',
              Updated=TO_DATE(NOW()),
              UpdatedBy=v_User
            WHERE M_INOUTLINE.M_INOUTLINE_ID=Cur_InOutLine.M_INOUTLINE_ID;


          END LOOP;
          
          -- Post Reversal
          v_ResultStr:='PostReversal';
          -- Update reversal goods dates
          IF (v_voidmovementdate IS NOT NULL) THEN
            UPDATE M_INOUT SET MovementDate = v_voidmovementdate WHERE M_INOUT_ID = v_RInOut_ID;
          END IF;
          IF (v_voiddate_acct IS NOT NULL) THEN
            UPDATE M_INOUT SET DateAcct = v_voiddate_acct WHERE M_INOUT_ID = v_RInOut_ID;
          END IF;
          PERFORM M_INOUT_POST(NULL, v_RInOut_ID) ;
          -- Indicate as Reversal Transaction
          v_ResultStr:='IndicateReversal';
          UPDATE M_INOUT
            SET Updated=TO_DATE(NOW()),
            UpdatedBy=v_User,
            DocStatus='VO' -- the reversal transaction
          WHERE M_InOut_ID=v_RInOut_ID;
--Added logic by usha on 16-10-2017 for cost insertion and updation for voided transactions 
 FOR CUR_Minout_Mtrx IN

    
       (SELECT *FROM m_inoutline WHERE m_inout_id=Cur_InOut.M_INOUT_ID)  
     -- (SELECT *FROM m_inoutline WHERE m_inout_id=Cur_InOut.M_INOUT_ID AND C_OrderLine_ID is not null)
      LOOP
      SELECT transactioncost,m_transaction_id,movementtype,iscostcalculated INTO V_TRXCOST ,v_MTransaction_Id,v_Movementtype,v_iscostcalculated
      FROM m_transaction
      WHERE m_inoutline_id=CUR_Minout_Mtrx.m_inoutline_id;

          
    IF(v_Movementtype ='C-' or v_Movementtype ='V+')THEN
    --IF(V_TRXCOST IS NULL OR V_TRXCOST =0 )THEN --commented by Asutosh on 21-Nov-2017 for checking iscostcalculated instead of transaction cost 0
    IF(v_iscostcalculated = 'N' )THEN
      RAISE EXCEPTION '%', '@EXPUR_Cannot Void As Prvious Record CostNotCal@'; --OBTG:-20000--

    ELSE
      FOR CUR_VOIDtrxCost_Update IN
      (SELECT * 
      FROM m_inoutline
      WHERE m_inout_id=v_RInOut_ID 
      AND Movementqty=-(CUR_Minout_Mtrx.Movementqty) AND M_Product_ID=CUR_Minout_Mtrx.M_Product_ID)
      LOOP
       ---INSERT INTO M_TRANSACTION_COST
       v_C_Currency_ID :=(select C_CURRENCY_ID from m_transaction where m_inoutline_id =CUR_Minout_Mtrx.m_inoutline_id);
       
INSERT INTO M_TRANSACTION_COST
( m_transaction_cost_id,ad_client_id ,ad_org_id ,created ,createdby,updated ,updatedby,isactive ,
m_transaction_id,cost,costdate ,c_currency_id,m_costadjustmentline_id, isunitcost,dateacct)
VALUES
(get_uuid(),CUR_VOIDtrxCost_Update.ad_client_id, CUR_VOIDtrxCost_Update.ad_org_id,TO_DATE(NOW()),  CUR_VOIDtrxCost_Update.CreatedBy, TO_DATE(NOW()), CUR_VOIDtrxCost_Update.UpdatedBy,'Y',(select m_transaction_id from m_transaction where m_inoutline_id =CUR_VOIDtrxCost_Update.m_inoutline_id),V_TRXCOST,TO_DATE(NOW()),v_C_Currency_ID,null,'Y',TO_DATE(NOW()));

         

      -- transactions related with original inout and with voided inout will be mark as is cost permanent
      UPDATE M_TRANSACTION 
      SET ISCOSTPERMANENT='Y',iscostcalculated='Y',transactioncost=V_TRXCOST,c_currency_id=v_C_Currency_ID
      WHERE m_inoutline_id =CUR_VOIDtrxCost_Update.m_inoutline_id;
     
       END LOOP;--ENDS CUR_VOIDtrxCost_Update     
END IF;--ends   IF(V_TRXCOST IS NULL OR V_TRXCOST =0 )THEN

       END IF;--Ends       IF(v_Movementtype ='C-')THEN

                       
     END LOOP;--Ends CUR_InterConsm_Mtrx
     --Ends usha logic
          -- transactions related with original inout and with voided inout will be mark as is cost permanent
          UPDATE M_TRANSACTION TRX
          SET ISCOSTPERMANENT='Y'
          WHERE TRX.M_INOUTLINE_ID IN (SELECT M_INOUTLINE_ID 
                                       FROM M_INOUTLINE
                                       WHERE (M_INOUT_ID = v_RInOut_ID 
                                              OR M_INOUT_ID = Cur_InOut.m_inout_id));
        END IF; -- ReverseCorrection

        --M_Inout_Post - Finish_Process Extension Point
        --Extension point at the end of the M_Inout_Post. It has 5 available parameters Record_ID, DocAction, User, Message and Result
        SELECT count(*) INTO v_count
        FROM DUAL
        where exists (select 1 from ad_ep_procedures where ad_extension_points_id = '5A7C6972321E42C2A5A8E9D6D73E6A7C');
        IF (v_count=1) THEN
          DECLARE
            v_ep_instance VARCHAR(32); --OBTG:VARCHAR2--
            v_extension_point_id VARCHAR(32) := '5A7C6972321E42C2A5A8E9D6D73E6A7C'; --OBTG:VARCHAR2--
          BEGIN
            v_ep_instance := get_uuid();
            PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'Record_ID',
              v_record_id, NULL, NULL, NULL, NULL, NULL, NULL);
            PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'DocAction',
              Cur_InOut.DocAction, NULL, NULL, NULL, NULL, NULL, NULL);
            PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'User',
              v_User, NULL, NULL, NULL, NULL, NULL, NULL);
            PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'Message',
              NULL, NULL, NULL, NULL, NULL, NULL, v_Message);
            PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'Result',
              NULL, NULL, v_Result, NULL, NULL, NULL, NULL);
            PERFORM AD_EXTENSION_POINT_HANDLER(v_ep_instance, v_extension_point_id);
            SELECT p_number INTO v_Result
            FROM ad_ep_instance_para
            WHERE ad_ep_instance_id = v_ep_instance
              AND parametername LIKE 'Result';
            SELECT p_text INTO v_Message
            FROM ad_ep_instance_para
            WHERE ad_ep_instance_id = v_ep_instance
              AND parametername LIKE 'Message';

            DELETE FROM ad_ep_instance_para
            WHERE ad_ep_instance_id = v_ep_instance;
          END;
        END IF;

      END LOOP; -- InOut Header
      /**
      * Transaction End
      */
      v_ResultStr:='Fini';
    END IF; --FINISH_PROCESS
    ---- <<FINISH_PROCESS>>
    IF(p_PInstance_ID IS NOT NULL) THEN
      --  Update AD_PInstance
      RAISE NOTICE '%','Updating PInstance - Finished ' || v_Message ;
      PERFORM AD_UPDATE_PINSTANCE(p_PInstance_ID, NULL, 'N', v_Result, v_Message) ;
    ELSE
      RAISE NOTICE '%','--<<M_InOut_Post finished>>' ;
    END IF;
    RETURN;
  END; --BODY
EXCEPTION
WHEN OTHERS THEN
  v_ResultStr:= '@ERROR=' || SQLERRM;
  RAISE NOTICE '%',v_ResultStr ;
  IF(p_PInstance_ID IS NOT NULL) THEN
    -- ROLLBACK;
    PERFORM AD_UPDATE_PINSTANCE(p_PInstance_ID, NULL, 'N', 0, v_ResultStr) ;
  ELSE
    RAISE EXCEPTION '%', SQLERRM;
  END IF;
  RETURN;
END ; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION m_inout_post(character varying, character varying)
  OWNER TO tad;





-- DROP FUNCTION c_orderlinetax_insert(character varying, character varying, character varying, character varying, character varying, character varying, numeric, numeric, numeric);

CREATE OR REPLACE FUNCTION c_orderlinetax_insert(p_org_id character varying, p_order_id character varying, p_orderline_id character varying, p_user_id character varying, p_originaltax_id character varying, p_tax_id character varying, p_linenetamt numeric, p_alternatetaxbaseamt numeric, p_stdprecision numeric)
  RETURNS void AS
$BODY$ DECLARE 
/*************************************************************************
* The contents of this file are subject to the Openbravo  Public  License
* Version  1.1  (the  "License"),  being   the  Mozilla   Public  License
* Version 1.1  with a permitted attribution clause; you may not  use this
* file except in compliance with the License. You  may  obtain  a copy of
* the License at http://www.openbravo.com/legal/license.html
* Software distributed under the License  is  distributed  on  an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
* License for the specific  language  governing  rights  and  limitations
* under the License.
* The Original Code is Openbravo ERP.
* The Initial Developer of the Original Code is Openbravo SLU
* All portions are Copyright (C) 2010-2012 Openbravo SLU
* All Rights Reserved.
* Contributor(s):  ______________________________________.
************************************************************************/
  -- Logistice
  v_ResultStr VARCHAR(2000):=''; --OBTG:VARCHAR2--
  v_Message VARCHAR(2000):=''; --OBTG:VARCHAR2--
  v_Result NUMERIC:=1; -- 0=failure
  v_IsSummary C_TAX.ISSUMMARY%TYPE;
  v_Cascade C_TAX.CASCADE%TYPE;
  v_TaxBaseAmount NUMERIC;
  v_BaseAmount C_TAX.BASEAMOUNT%TYPE;
  v_AlreadyExists NUMERIC;
  v_C_TaxBase_ID C_TAX.C_TAXBASE_ID%TYPE;
  v_LineNet NUMERIC;
  v_AlternateTaxBaseAmt NUMERIC;
  v_LineNo C_INVOICETAX.LINE%TYPE;
  v_Rate C_TAX.RATE%TYPE;
  v_Client_ID VARCHAR(32) ; --OBTG:VARCHAR2--
  v_istaxincluded CHAR(1);
  --TYPE RECORD IS REFCURSOR;
    Cur_Taxes RECORD;
    FINISH_PROCESS BOOLEAN:=false;
  BEGIN --BODY
    v_TaxBaseAmount:=0;
    --Adde by usha for rounding off line tax
    p_StdPrecision :=0;
    --Ends by Usha
    SELECT ISSUMMARY, CASCADE, RATE, BASEAMOUNT, AD_CLIENT_ID, C_TAXBASE_ID
    INTO v_IsSummary, v_Cascade, v_Rate, v_BaseAmount, v_Client_ID, v_C_TaxBase_ID
    FROM C_TAX
    WHERE C_TAX_ID = p_tax_id;
    IF(v_BaseAmount='LNA' OR v_BaseAmount='LNATAX') THEN
      v_TaxBaseAmount:=p_LineNetAmt;
    ELSIF (v_BaseAmount='TBA' OR v_BaseAmount='TBATAX') THEN
      SELECT pl.istaxincluded INTO v_istaxincluded
      FROM c_order o JOIN m_pricelist pl ON o.m_pricelist_id = pl.m_pricelist_id
      WHERE o.c_order_id = p_order_id;
      IF (v_istaxincluded = 'Y') THEN
        RAISE EXCEPTION '%', '@AlternateAndTaxInclusiveNotSupported@'; --OBTG:-20000--
      END IF;
      v_TaxBaseAmount:=p_AlternateTaxBaseAmt;
    END IF;
    IF (v_TaxBaseAmount IS NULL) THEN
      v_TaxBaseAmount:=0;
    END IF;
    IF (v_BaseAmount='TAX' OR v_BaseAmount='LNATAX' OR v_BaseAmount='TBATAX') THEN
      SELECT COALESCE(SUM(TAXAMT),0) + v_TaxBaseAmount
      INTO v_TaxBaseAmount
      FROM C_ORDERLINETAX, C_TAX
      WHERE C_ORDERLINETAX.C_TAX_ID = C_TAX.C_TAX_ID
      AND C_TAX_ISMEMBER(v_C_TaxBase_ID,C_TAX.C_TAX_ID) = 1
      AND C_ORDERLINE_ID = p_orderline_id
      AND C_TAX.ISSUMMARY='N';
    END IF;
    IF(v_Cascade='Y') THEN
      SELECT COALESCE(SUM(TAXAMT), 0) + v_TaxBaseAmount
      INTO v_TaxBaseAmount
      FROM C_ORDERLINETAX
      WHERE C_ORDERLINE_ID = p_orderline_id;
    END IF;
    IF(v_IsSummary='N') THEN
      SELECT COALESCE(MAX(LINE),0) + 10
      INTO v_LineNo
      FROM C_ORDERLINETAX
      WHERE C_ORDERLINE_ID = p_orderline_id;
      IF(p_order_id IS NULL OR p_orderline_id IS NULL) THEN
         RAISE EXCEPTION '%', '@20200@'; --OBTG:-20000--
      END IF;
      INSERT
      INTO C_ORDERLINETAX (
      C_OrderLineTax_ID, C_OrderLine_ID, C_Order_ID, C_Tax_ID, AD_Client_ID, AD_Org_ID,
      IsActive, Created, CreatedBy, Updated,
      UpdatedBy, TaxBaseAmt, TaxAmt, Line)
      VALUES (
      GET_UUID(), p_orderline_id, p_order_id, p_tax_id, v_Client_ID, p_org_id,
      'Y', TO_DATE(NOW()), p_user_id, TO_DATE(NOW()),
      p_user_id, v_TaxBaseAmount, ROUND(v_TaxBaseAmount*v_Rate / 100, p_StdPrecision), v_LineNo);
    ELSE
      FOR Cur_Taxes IN
        (SELECT C_Tax_ID, RATE
         FROM C_TAX
        WHERE Parent_Tax_ID=p_tax_id
        ORDER BY Line)
      LOOP
        PERFORM C_ORDERLINETAX_INSERT(p_org_id, p_order_id, p_orderline_id, p_user_id, p_originaltax_id, Cur_Taxes.C_Tax_ID, p_LineNetAmt, p_AlternateTaxBaseAmt, p_StdPrecision);
      END LOOP;
    END IF;
    RETURN;
    ---- <<FINISH_PROCESS>>
EXCEPTION
WHEN OTHERS THEN
  v_ResultStr:= '@ERROR=' || SQLERRM;
  RAISE NOTICE '%',v_ResultStr ;
  ---- ROLLBACK;
  RAISE EXCEPTION '%', SQLERRM;
END ; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION c_orderlinetax_insert(character varying, character varying, character varying, character varying, character varying, character varying, numeric, numeric, numeric)
  OWNER TO tad;













-- DROP FUNCTION c_invoicelinetax_insert(character varying, character varying, character varying, character varying, character varying, character varying, numeric, numeric, numeric);

CREATE OR REPLACE FUNCTION c_invoicelinetax_insert(p_org_id character varying, p_invoice_id character varying, p_invoiceline_id character varying, p_user_id character varying, p_originaltax_id character varying, p_tax_id character varying, p_linenetamt numeric, p_alternatetaxbaseamt numeric, p_stdprecision numeric)
  RETURNS void AS
$BODY$ DECLARE 
/*************************************************************************
* The contents of this file are subject to the Openbravo  Public  License
* Version  1.1  (the  "License"),  being   the  Mozilla   Public  License
* Version 1.1  with a permitted attribution clause; you may not  use this
* file except in compliance with the License. You  may  obtain  a copy of
* the License at http://www.openbravo.com/legal/license.html
* Software distributed under the License  is  distributed  on  an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
* License for the specific  language  governing  rights  and  limitations
* under the License.
* The Original Code is Openbravo ERP.
* The Initial Developer of the Original Code is Openbravo SLU
* All portions are Copyright (C) 2010-2012 Openbravo SLU
* All Rights Reserved.
* Contributor(s):  ______________________________________.
************************************************************************/
  -- Logistice
  v_ResultStr VARCHAR(2000):=''; --OBTG:VARCHAR2--
  v_Message VARCHAR(2000):=''; --OBTG:VARCHAR2--
  v_Result NUMERIC:=1; -- 0=failure
  v_IsSummary C_TAX.ISSUMMARY%TYPE;
  v_Cascade C_TAX.CASCADE%TYPE;
  v_TaxBaseAmount NUMERIC;
  v_BaseAmount C_TAX.BASEAMOUNT%TYPE;
  v_AlreadyExists NUMERIC;
  v_C_TaxBase_ID C_TAX.C_TAXBASE_ID%TYPE;
  v_LineNet NUMERIC;
  v_AlternateTaxBaseAmt NUMERIC;
  v_LineNo C_INVOICETAX.LINE%TYPE;
  v_Rate C_TAX.RATE%TYPE;
  v_Client_ID VARCHAR(32) ; --OBTG:VARCHAR2--
  V_istaxincluded CHAR(1);
  --TYPE RECORD IS REFCURSOR;
    Cur_Taxes RECORD;
    FINISH_PROCESS BOOLEAN:=false;
  BEGIN --BODY
    v_TaxBaseAmount:=0;
    --Added by usha for roung off linetax amount on 27-04-2017
  --p_StdPrecision:=0;
  --Ends usha logic
    SELECT ISSUMMARY, CASCADE, RATE, BASEAMOUNT, AD_CLIENT_ID, C_TAXBASE_ID
    INTO v_IsSummary, v_Cascade, v_Rate, v_BaseAmount, v_Client_ID, v_C_TaxBase_ID
    FROM C_TAX
    WHERE C_TAX_ID = p_tax_id;
    IF(v_BaseAmount='LNA' OR v_BaseAmount='LNATAX') THEN
      v_TaxBaseAmount:=p_LineNetAmt;
    ELSIF (v_BaseAmount='TBA' OR v_BaseAmount='TBATAX') THEN
      SELECT pl.istaxincluded INTO v_istaxincluded
      FROM c_invoice i JOIN m_pricelist pl ON i.m_pricelist_id = pl.m_pricelist_id
      WHERE i.c_invoice_id = p_invoice_id;
      IF (v_istaxincluded = 'Y') THEN
        RAISE EXCEPTION '%', '@AlternateAndTaxInclusiveNotSupported@'; --OBTG:-20000--
      END IF;
      v_TaxBaseAmount:=p_AlternateTaxBaseAmt;
    END IF;
    IF (v_TaxBaseAmount IS NULL) THEN
      v_TaxBaseAmount:=0;
    END IF;
    IF (v_BaseAmount='TAX' OR v_BaseAmount='LNATAX' OR v_BaseAmount='TBATAX') THEN
      SELECT COALESCE(SUM(TAXAMT),0) + v_TaxBaseAmount
      INTO v_TaxBaseAmount
      FROM C_INVOICELINETAX, C_TAX
      WHERE C_INVOICELINETAX.C_TAX_ID = C_TAX.C_TAX_ID
      AND C_TAX_ISMEMBER(v_C_TaxBase_ID,C_TAX.C_TAX_ID) = 1
      AND C_INVOICELINE_ID = p_invoiceline_id
      AND C_TAX.ISSUMMARY='N';
    END IF;
    IF(v_Cascade='Y') THEN
      SELECT COALESCE(SUM(TAXAMT), 0) + v_TaxBaseAmount
      INTO v_TaxBaseAmount
      FROM C_INVOICELINETAX
      WHERE C_INVOICELINE_ID = p_invoiceline_id;
    END IF;
    IF(v_IsSummary='N') THEN
      SELECT COALESCE(MAX(LINE),0) + 10
      INTO v_LineNo
      FROM C_INVOICELINETAX
      WHERE C_INVOICELINE_ID = p_invoiceline_id;
      IF(p_invoice_id IS NULL OR p_invoiceline_id IS NULL) THEN
         RAISE EXCEPTION '%', '@20200@'; --OBTG:-20000--
      END IF;
      INSERT
      INTO C_INVOICELINETAX (
      C_InvoiceLineTax_ID, C_InvoiceLine_ID, C_Invoice_ID, C_Tax_ID, AD_Client_ID, AD_Org_ID,
      IsActive, Created, CreatedBy, Updated,
      UpdatedBy, TaxBaseAmt, TaxAmt, Line)
      VALUES (
      GET_UUID(), p_invoiceline_id, p_invoice_id, p_tax_id, v_Client_ID, p_org_id,
      'Y', TO_DATE(NOW()), p_user_id, TO_DATE(NOW()),
      p_user_id, v_TaxBaseAmount, ROUND(v_TaxBaseAmount*v_Rate / 100, p_StdPrecision), v_LineNo);
    ELSE
      FOR Cur_Taxes IN
        (SELECT C_Tax_ID, RATE
         FROM C_TAX
        WHERE Parent_Tax_ID=p_tax_id
        ORDER BY Line)
      LOOP
        PERFORM C_INVOICELINETAX_INSERT(p_org_id, p_invoice_id, p_invoiceline_id, p_user_id, p_originaltax_id, Cur_Taxes.C_Tax_ID, p_LineNetAmt, p_AlternateTaxBaseAmt, p_StdPrecision);
      END LOOP;
    END IF;
    RETURN;
    ---- <<FINISH_PROCESS>>
EXCEPTION
WHEN OTHERS THEN
  v_ResultStr:= '@ERROR=' || SQLERRM;
  RAISE NOTICE '%',v_ResultStr ;
  -- ROLLBACK;
  RAISE EXCEPTION '%', SQLERRM;
END ; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION c_invoicelinetax_insert(character varying, character varying, character varying, character varying, character varying, character varying, numeric, numeric, numeric)
  OWNER TO tad;









-- Function: c_invoiceline_trg3()

-- DROP FUNCTION c_invoiceline_trg3();

CREATE OR REPLACE FUNCTION c_invoiceline_trg3()
  RETURNS trigger AS
$BODY$ DECLARE 

/*************************************************************************
* The contents of this file are subject to the Openbravo  Public  License
* Version  1.1  (the  "License"),  being   the  Mozilla   Public  License
* Version 1.1  with a permitted attribution clause; you may not  use this
* file except in compliance with the License. You  may  obtain  a copy of
* the License at http://www.openbravo.com/legal/license.html
* Software distributed under the License  is  distributed  on  an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
* License for the specific  language  governing  rights  and  limitations
* under the License.
* The Original Code is Openbravo ERP.
* The Initial Developer of the Original Code is Openbravo SLU
* All portions are Copyright (C) 2001-2009 Openbravo SLU
* All Rights Reserved.
* Contributor(s):  ______________________________________.
************************************************************************/
--Invoice
vwithholdingtotal NUMERIC;
vBusPartId VARCHAR(32); --OBTG:varchar2--
vIsSalesInvoice CHAR(1);
vProcessed  VARCHAR(60);
--InvoiceLine
v_invoiceid VARCHAR(32); --OBTG:varchar2--
vexcludeforwh CHAR(1);
vlinebaseamountnew NUMERIC;
vlinebaseamountold NUMERIC;
-- BP_Withholding
isbaseamountpercent CHAR(1);
baseamountpercent NUMERIC;
includetaxinps CHAR(1);
taxinps_ID VARCHAR(32); --OBTG:VARCHAR2--
-- Tax
vTaxAmount  NUMERIC;
-- Withholding
withpercent NUMERIC;
--Calculated Variable
vwithholdingnew NUMERIC;
vwithholdingold NUMERIC;
taxamountwith  NUMERIC;
vwithholdingtax NUMERIC;
vwithid VARCHAR(32); --OBTG:varchar2--
finish_process BOOLEAN := FALSE;
    
BEGIN
    
    IF AD_isTriggerEnabled()='N' THEN IF TG_OP = 'DELETE' THEN RETURN OLD; ELSE RETURN NEW; END IF; 
    END IF;


  IF(TG_OP = 'INSERT') THEN
    v_invoiceid := NEW.c_invoice_id;
    vexcludeforwh := NEW.excludeforwithholding;
    vlinebaseamountnew := NEW.linenetamt;
    vlinebaseamountold := 0;

    ELSIF(TG_OP = 'UPDATE') THEN
      v_invoiceid := NEW.c_invoice_id;
      vexcludeforwh := NEW.excludeforwithholding;
      vlinebaseamountnew := NEW.linenetamt;
      vlinebaseamountold := OLD.linenetamt;
	--addded by asutosh on 26 april 2017
	--update roundoff amt in header if line updated
	update c_invoice 
	set em_expur_roundoff_amt = (select sum(em_expur_diff_amt) from c_invoiceline where c_invoice_id=new.c_invoice_id) 
	where c_invoice_id=new.c_invoice_id;

      ELSIF(TG_OP = 'DELETE') THEN
        v_invoiceid := OLD.c_invoice_id;
        vexcludeforwh := OLD.excludeforwithholding;
        vlinebaseamountnew := 0;
        vlinebaseamountold := OLD.linenetamt;
	--addded by asutosh on 26 april 2017
	--update roundoff amt in header if line deleted
	update c_invoice 
	set em_expur_roundoff_amt = (select sum(em_expur_diff_amt) from c_invoiceline where c_invoice_id=old.c_invoice_id) 
	where c_invoice_id=old.c_invoice_id;

      END IF;

      -- If The lines is excluded for calculate the witholding --> exit
      IF vexcludeforwh = 'Y' THEN
        finish_process:= true;
      END IF;
  IF (NOT finish_process) THEN
      SELECT COALESCE(withholdingamount,   0), c_bpartner_id, IsSOTrx , coalesce(processed,'N') ,c_withholding_id
      INTO vwithholdingtotal,vBusPartId, vIsSalesInvoice, vProcessed  ,vwithid
      FROM c_invoice
      WHERE c_invoice_id = v_invoiceid;
  END IF;
  IF (NOT finish_process) THEN
      -- Se the invoice isn't purchase exit from trigger
      if (vIsSalesInvoice <> 'N') then
        finish_process:= true;
      end if;
  END IF;
  IF (NOT finish_process) THEN
    BEGIN
      select bpwh.is_percent_wh, bpwh.wh_percent, bpwh.include_tax, bpwh.c_tax_id,wh.rate
      into isbaseamountpercent, baseamountpercent,  includetaxinps, taxinps_id,withpercent
        from c_bp_withholding bpwh, c_withholding wh
       where bpwh.c_bpartner_id = vBusPartId
       and bpwh.c_withholding_id = wh.c_withholding_id
       and bpwh.c_withholding_id = vwithid;

    EXCEPTION
    When DATA_EXCEPTION THEN
      finish_process:= true;
    end;
  END IF;
  IF (NOT finish_process) THEN
   -- ReadOnly Check
    IF (vProcessed = 'N') THEN

      IF(isbaseamountpercent <> 'Y') THEN
        baseamountpercent := 100;
      END IF;
      -- New WithHolding For LineAmount
      vlinebaseamountnew := vlinebaseamountnew *baseamountpercent / 100;
      vwithholdingnew :=(withpercent * vlinebaseamountnew) / 100;
      -- Old WithHolding For LineAmount
      vlinebaseamountold := vlinebaseamountold *baseamountpercent / 100;
      vwithholdingold :=(withpercent *vlinebaseamountold) / 100;


      -- WithHolding Tax
      vTaxAmount := 0;
      IF (includetaxinps = 'Y') THEN
       select coalesce(sum(taxamt),0) into vTaxAmount
        from c_invoicetax invtax , c_tax tax
       where tax.c_tax_id = invtax.c_tax_id
        and tax.iswithholdingtax='Y'
        and invtax.c_invoice_id = v_invoiceid
        and tax.c_tax_id=taxinps_id;
      END IF;

      taxamountwith := baseamountpercent * (vTaxAmount)/100;
      vwithholdingtax :=  withpercent*taxamountwith/100 ;

      -- Update WITHHOLDINGAMOUNT della c_invoice = totale+(new valore wh of line) -(old valore wh of line)
      vwithholdingtotal := vwithholdingtotal + vwithholdingnew -vwithholdingold+ vwithholdingtax;

      UPDATE c_invoice
      SET withholdingamount = vwithholdingtotal
      WHERE c_invoice_id = v_invoiceid;
    END IF;
  END IF;

IF TG_OP = 'DELETE' THEN RETURN OLD; ELSE RETURN NEW; END IF; 

END 

; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION c_invoiceline_trg3()
  OWNER TO tad;


/***********************************************************************
-> Changes For C_Invoice_Post Stored Procedure
-> Last Changes Added On 31-July-2019 For Adding TDS In Expense Invoice
   and Deleting TDS on Reactivation
*************************************************************************/
CREATE OR REPLACE FUNCTION c_invoice_post(p_pinstance_id character varying, p_invoice_id character varying)
  RETURNS void AS
$BODY$ DECLARE 
/*************************************************************************
  * The contents of this file are subject to the Compiere Public
  * License 1.1 ("License"); You may not use this file except in
  * compliance with the License. You may obtain a copy of the License in
  * the legal folder of your Openbravo installation.
  * Software distributed under the License is distributed on an
  * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing rights
  * and limitations under the License.
  * The Original Code is  Compiere  ERP &  Business Solution
  * The Initial Developer of the Original Code is Jorg Janke and ComPiere, Inc.
  * Portions created by Jorg Janke are Copyright (C) 1999-2001 Jorg Janke,
  * parts created by ComPiere are Copyright (C) ComPiere, Inc.;
  * All Rights Reserved.
  * Contributor(s): Openbravo SLU
  * Contributions are Copyright (C) 2001-2015 Openbravo, S.L.U.
  *
  * Specifically, this derivative work is based upon the following Compiere
  * file and version.
  *************************************************************************
  * $Id: C_Invoice_Post.sql,v 1.32 2003/07/22 05:41:27 jjanke Exp $
  ***
  * Title:  Post single Invoice
  * Description:
  *  Actions: COmplete, APprove, Reverse Correction, Void
  *
  * OpenItem Amount:
  *  - C_BPartner.SO_CreditUsed is increased
  *  - if C_CashLine entry is created
  *  - C_Cash_Post creates C_Allocation
  *  - C_Allocation_Trg decreases C_BPartner.SO_CreditUsed
  *
  ************************************************************************/
  -- Logistice
  v_ResultStr VARCHAR(2000):=''; --OBTG:VARCHAR2--
  v_Message VARCHAR(2000):=''; --OBTG:VARCHAR2--
  v_Record_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_Result NUMERIC:=1; -- Success
  v_totalqty NUMERIC:=0; 
  -- Parameter
  --TYPE RECORD IS REFCURSOR;
  Cur_Parameter RECORD;
  Cur_line RECORD;
  Cur_InvoiceLine RECORD;
  Cur_InvoiceLineAcctDim RECORD;
  Cur_Discount RECORD;
  Cur_CInvoiceDiscount RECORD;
  Cur_TaxDiscount RECORD;
  Cur_ReactivateInvoiceLine RECORD;
  Cur_LastContact RECORD;
  Cur_lineqty RECORD;
  Cur_InvoiceTax RECORD;
  Cur_TaxMAct RECORD;
  Cur_Offer RECORD;
--Added by Asutosh
Cur_TDSLine RECORD;
v_lineno numeric;
v_tdsamt numeric;
v_costcenter VARCHAR(32);
v_doctypeName VARCHAR(60);
  -- Record Info
  v_Client_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_User_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_Org_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_UpdatedBy C_INVOICE.UpdatedBy%TYPE;
  v_Processing C_INVOICE.Processing%TYPE;
  v_Processed C_INVOICE.Processed%TYPE;
  v_DocAction C_INVOICE.DocAction%TYPE;
  v_DocStatus C_INVOICE.DocStatus%TYPE;
  v_DoctypeReversed_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_DocType_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_DocTypeTarget_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_isreturndoctype CHAR(1);
  v_PaymentRule C_INVOICE.PaymentRule%TYPE;
  v_PaymentTerm C_INVOICE.C_PaymentTerm_ID%TYPE;
  v_Order_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_DateAcct TIMESTAMP;
  v_DateInvoiced TIMESTAMP;
  v_DocumentNo C_INVOICE.DocumentNo%TYPE;
  v_BPartner_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_bp_isactive c_bpartner.isactive%TYPE;
  v_BPartner_User_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_IsSOTrx C_INVOICE.IsSOTrx%TYPE;
  v_Posted C_INVOICE.Posted%TYPE;
  v_istaxincluded CHAR(1);
  --Added by P.SAROBE
  v_documentno_Settlement VARCHAR(40); --OBTG:VARCHAR2--
  v_dateSettlement TIMESTAMP;
  v_Cancel_Processed CHAR(1);
  v_nameBankstatement VARCHAR (60); --OBTG:VARCHAR2--
  v_dateBankstatement TIMESTAMP;
  v_nameCash VARCHAR (60); --OBTG:VARCHAR2--
  v_dateCash TIMESTAMP;
  v_Bankstatementline_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_Debtpayment_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_CashLine_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_ispaid CHAR(1);
  v_Settlement_Cancel_ID VARCHAR(32); --OBTG:VARCHAR2--
  --Finish added by P.Sarobe
  --
  v_GrandTotal NUMERIC:=0;
  v_TotalLines NUMERIC:=0;
  v_Currency_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_Multiplier NUMERIC:=1;
  v_paymentcheck NUMERIC;
  --
  v_RInvoice_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_RDocumentNo C_INVOICE.DocumentNo%TYPE;
  v_NextNo VARCHAR(32); --OBTG:VARCHAR2--
  v_count NUMERIC;
  v_POReference VARCHAR(40) ; --OBTG:NVARCHAR2--
  --
  v_SettlementDocType_ID VARCHAR(32) ; --OBTG:VARCHAR2--
  v_SDocumentNo C_SETTLEMENT.DocumentNo%TYPE;
  v_settlementID VARCHAR(32):=NULL; --OBTG:varchar2--
  --
  v_FirstSales C_BPARTNER.FirstSale%TYPE;
  v_REInOutStatus M_INOUT.DocStatus%TYPE;
  v_REDateInvoiced TIMESTAMP;
  v_REtotalQtyInvoiced NUMERIC:=0;
  v_REdeliveredQty NUMERIC:=0;
  --
  v_CumDiscount NUMERIC;
  v_OldCumDiscount NUMERIC;
  v_InvoiceLineSeqNo NUMERIC;
  v_InvoiceLine VARCHAR(32); --OBTG:VARCHAR2--
  v_Discount NUMERIC;
  v_Line NUMERIC;
  v_InvoiceDiscount NUMERIC;
  v_C_Project_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_acctAmount NUMERIC;
  v_partialAmount NUMERIC;
  FINISH_PROCESS BOOLEAN:=FALSE;
  END_PROCESSING BOOLEAN:=FALSE;
  v_TargetDocBaseType C_DOCTYPE.DocBaseType%TYPE;
  v_isReversal C_DOCTYPE.IsReversal%TYPE;
  v_MultiplierARC NUMERIC:=1;
  v_is_included NUMERIC:=0;
  v_available_period NUMERIC:=0;
  v_is_ready AD_Org.IsReady%TYPE;
  v_is_tr_allow AD_OrgType.IsTransactionsAllowed%TYPE;
  v_isacctle AD_OrgType.IsAcctLegalEntity%TYPE;
  v_org_bule_id AD_Org.AD_Org_ID%TYPE;
  
  v_PeriodStartDate TIMESTAMP;
  v_PeriodEndDate TIMESTAMP;
  v_DocNo_Org_ID AD_Sequence.AD_Org_ID%TYPE;
  withholdamount NUMERIC(10,2);
  cWithHoldId VARCHAR(32); --OBTG:varchar2--
  Cur_InvoiceNetLine RECORD;

  v_LineMax NUMERIC:=0;
  v_precision NUMERIC;
  v_gross_unit_price NUMERIC;
  v_line_gross_amount NUMERIC;
  v_Isquantityvariable CHAR(1);
  
  v_isdeferred_inv C_InvoiceLine.IsDeferred%TYPE;
  v_defplantype_inv C_InvoiceLine.DefPlanType%TYPE;
  v_periodnumber_inv C_InvoiceLine.periodnumber%TYPE;
  v_period_inv C_InvoiceLine.c_period_id%TYPE;

  v_voiddate_inv C_Invoice.DateInvoiced%TYPE;
  v_voiddate_acct C_Invoice.DateAcct%TYPE;

  v_bpartner_blocked VARCHAR(1):='N'; --OBTG:VARCHAR2--
  v_invoiceBlocking VARCHAR(1):='N'; --OBTG:VARCHAR2--
  v_bpartner_name c_bpartner.name%TYPE;
  v_productname m_product.name%TYPE;

  v_iscashvat C_Invoice.IsCashVat%TYPE;
  v_invoiceline_qtysum NUMERIC;
  v_PriceList_ID VARCHAR(32); --OBTG:varchar2--
  v_prepaymentamt NUMERIC;
  v_hasTaxes NUMERIC;
  --Added by usha
  v_Gross_DecimalValue  NUMERIC;
v_lineno_round NUMERIC;
v_tax varchar(32);
v_Rounding_Account varchar(32);
   
V_Validate_Reactivation VARCHAR(60);
V_FactAccount_Count NUMERIC:=0;
v_Org_As_Location_ID VARCHAR(32);
v_TrxO_rg_SearchKey VARCHAR(100);
v_CostCenter_ID VARCHAR(32);
v_CostCenter_SearchKey VARCHAR(100);			

  Cur_WithHoldingTax_Data RECORD;


BEGIN
  IF (p_PInstance_ID IS NOT NULL) THEN
    --  Update AD_PInstance
    RAISE NOTICE '%','Updating PInstance - Processing ' || p_PInstance_ID ;
    v_ResultStr:='PInstanceNotFound';
    PERFORM AD_UPDATE_PINSTANCE(p_PInstance_ID, NULL, 'Y', NULL, NULL) ;
    -- Get Parameters
    v_ResultStr:='ReadingParameters';
    FOR Cur_Parameter IN
      (SELECT i.Record_ID,
        i.AD_User_ID,
        p.ParameterName,
        p.P_String,
        p.P_Number,
        p.P_Date
      FROM AD_PINSTANCE i
      LEFT JOIN AD_PINSTANCE_PARA p
        ON i.AD_PInstance_ID=p.AD_PInstance_ID
      WHERE i.AD_PInstance_ID=p_PInstance_ID
      ORDER BY p.SeqNo
      )
    LOOP
      v_Record_ID:=Cur_Parameter.Record_ID;
      v_User_ID:=Cur_Parameter.AD_User_ID;
      IF (Cur_Parameter.parametername = 'voidedDocumentDate') THEN
        v_voiddate_inv := TO_DATE(Cur_Parameter.p_string, 'YYYY-MM-DD');
      ELSIF (Cur_Parameter.parametername = 'voidedDocumentAcctDate') THEN
        v_voiddate_acct := TO_DATE(Cur_Parameter.p_string, 'YYYY-MM-DD');
      END IF;
    END LOOP; -- Get Parameter
    RAISE NOTICE '%','  v_Record_ID=' || v_Record_ID ;
  ELSE
    RAISE NOTICE '%','--<<C_Invoive_Post>>' ;
    v_Record_ID:=p_Invoice_ID;
  END IF;
BEGIN --BODY

	   /*Invoiceline acct dimension*/
	  SELECT C_INVOICE.ISSOTRX , C_INVOICE.c_bpartner_id, docAction
	  INTO v_IsSOTrx, v_BPartner_ID, V_Validate_Reactivation
	  FROM C_INVOICE
	  WHERE C_INVOICE_ID = v_Record_ID;

	  -- Code Added On 11-Dec-2018 For Blocking Reactivation Of Record If The Purchase Invoice Record
	  -- Is Already Posted
		SELECT count(*) INTO V_FactAccount_Count FROM fact_acct WHERE record_id  = v_Record_ID;

		IF(V_Validate_Reactivation = 'RE') THEN
			IF(V_FactAccount_Count > 0) THEN
				v_Message:=' Record is already posted, please unpost this record before Reactivation('||V_Validate_Reactivation||')';
				RAISE EXCEPTION '%', v_Message;
			END IF;	-- IF(V_FactAccount_Count > 0) Ends
		END IF;	-- IF(V_FactAccount_Count = 'RE') Ends
	
  SELECT CASE WHEN (m.ISSOTRX='Y') THEN customer_blocking  ELSE vendor_blocking END ,  
  CASE WHEN (m.ISSOTRX='Y') THEN so_invoice_blocking ELSE po_invoice_blocking  END, name, DocAction
  INTO v_bpartner_blocked, v_invoiceBlocking, v_bpartner_name, v_DocAction
  FROM C_INVOICE m, C_BPartner bp
  WHERE m.c_bpartner_id=bp.c_bpartner_id
  AND m.C_INVOICE_ID=v_Record_ID
  AND m.C_BPARTNER_ID=v_BPartner_ID;
  IF (v_DocAction = 'CO' AND v_bpartner_blocked = 'Y' AND v_invoiceBlocking = 'Y') THEN
    RAISE EXCEPTION '%','@ThebusinessPartner@'||' '|| v_bpartner_name ||' '||'@BusinessPartnerBlocked@'; --OBTG:-20000--
  END IF;

  IF (v_IsSOTrx = 'N') THEN
    FOR Cur_line IN
      (SELECT C_INVOICELINE.C_InvoiceLine_ID,
       C_INVOICELINE.LinenetAmt
       FROM C_INVOICELINE
       WHERE C_Invoice_ID = v_Record_ID
      )
    LOOP
      SELECT SUM(Amt) INTO v_acctAmount
      FROM C_INVOICELINE_ACCTDIMENSION
      WHERE C_InvoiceLine_ID = Cur_line.C_InvoiceLine_ID;
      IF (v_acctAmount <> Cur_line.LinenetAmt) THEN
        v_Message:='@QuantitiesNotMatch@';
        RAISE EXCEPTION '%', '@QuantitiesNotMatch@' ; --OBTG:-20000--
      END IF;
    END LOOP;
  END IF;
  /**
   * Read Invoice
   */
  v_ResultStr:='ReadingInvoice';
   SELECT i.Processing, i.Processed, i.DocAction, i.DocStatus,
      i.C_DocType_ID, i.C_DocTypeTarget_ID,
      i.PaymentRule, i.C_PaymentTerm_ID, i.DateAcct, i.DateInvoiced,
      i.AD_Client_ID, i.AD_Org_ID, i.UpdatedBy, i.DocumentNo,
      i.C_Order_ID, i.IsSOTrx, i.C_BPartner_ID, i.AD_User_ID,
      i.C_Currency_ID, i.POReference, i.Posted,
      i.c_Project_Id, i.C_WithHolding_ID, i.IsCashVat, i.M_PriceList_ID, i.prepaymentamt
  INTO v_Processing, v_Processed, v_DocAction, v_DocStatus,
      v_DocType_ID, v_DocTypeTarget_ID,
      v_PaymentRule, v_PaymentTerm, v_DateAcct, v_DateInvoiced,
      v_Client_ID, v_Org_ID, v_UpdatedBy, v_DocumentNo,
      v_Order_ID, v_IsSOTrx, v_BPartner_ID, v_BPartner_User_ID,
      v_Currency_ID, v_POReference, v_Posted,
      v_C_Project_Id, cWithHoldID, v_iscashvat, v_PriceList_ID, v_prepaymentamt
  FROM C_INVOICE i
  WHERE i.C_Invoice_ID=v_Record_ID FOR UPDATE;

  SELECT dt.isreturn  
  INTO  v_isreturndoctype    
  FROM  c_doctype dt  
  WHERE dt.c_doctype_id= v_DocTypeTarget_ID;

  SELECT pl.istaxincluded
  INTO   v_istaxincluded
  FROM   m_pricelist pl 
  WHERE pl.m_pricelist_id= v_PriceList_ID;
  
  RAISE NOTICE '%','Invoice_ID=' || v_Record_ID ||', DocAction=' || v_DocAction || ', DocStatus=' || v_DocStatus || ', DocType_ID=' || v_DocType_ID || ', DocTypeTarget_ID=' || v_DocTypeTarget_ID ;
  /**
   * Invoice Voided, Closed, or Reversed - No Action
   */
  IF (v_User_ID IS NOT NULL) THEN
    v_UpdatedBy:=v_User_ID;
  END IF;
  IF (v_DocStatus IN('VO', 'CL', 'RE')) THEN
    RAISE EXCEPTION '%', '@AlreadyPosted@'; --OBTG:-20000--
  END IF;
  --Allow to complete an invoice only in these cases:
  --* There are invoice lines
  --* There are tax lines
  --* There are both invoice and tax lines 
  IF (v_DocStatus='DR' AND v_DocAction='CO') THEN
    SELECT COUNT(*) INTO v_count
    FROM C_INVOICE
    WHERE C_INVOICE_ID=v_Record_ID 
      AND (EXISTS (SELECT 1
                   FROM C_INVOICELINE
                   WHERE C_INVOICE_ID=v_Record_ID)
           OR EXISTS (SELECT 1
                      FROM C_INVOICETAX
                      WHERE C_INVOICE_ID=v_Record_ID));

    IF (v_count=0) THEN
      RAISE EXCEPTION '%', '@InvoicesNeedLines@'; --OBTG:-20000--
    END IF;
    SELECT count(*) INTO v_count
    FROM dual
    WHERE EXISTS (
        SELECT 1
        FROM c_invoiceline il JOIN m_product p ON il.m_product_id = p.m_product_id
        WHERE p.isgeneric = 'Y'
          AND il.c_invoice_id = v_record_id);
    IF (v_count > 0) THEN
      SELECT max(p.name) INTO v_productname
      FROM c_invoiceline il JOIN m_product p ON il.m_product_id = p.m_product_id
      WHERE p.isgeneric = 'Y'
        AND il.c_invoice_id = v_record_id;
      RAISE EXCEPTION '%', '@CannotUseGenericProduct@ ' || v_productName; --OBTG:-20000--
    END IF;

    -- Check the cash vat flag for all the taxes matches the invoice one
    select count(1)
    into v_count
    from c_invoicetax it inner join c_tax t on (it.c_tax_id = t.c_tax_id)
    where it.c_invoice_id = v_Record_ID
    and t.iswithholdingtax = 'N'
    and t.rate <> 0
    and t.IsCashVat <> v_iscashvat;

    IF (v_count > 0) THEN
      RAISE EXCEPTION '%', '@CashVATNotMatch@'; --OBTG:-20000--
    END IF;
  
    /* Check active business partner*/
    SELECT isactive INTO v_bp_isactive
    FROM C_Bpartner
    WHERE C_Bpartner_ID = v_BPartner_ID;

    IF(v_bp_isactive = 'N') THEN
      RAISE EXCEPTION '%', '@InActiveBusinessPartner@'; --OBTG:-20000--
    END IF;

    /*
     * Avoids repeating the same documentno for the same organization tree within the same fiscal year
     */
    SELECT COUNT(*) INTO v_count
    FROM (SELECT Y.C_CALENDAR_ID, Y.C_YEAR_ID,
              MIN(P.STARTDATE) AS PERIODSTARTDATE, MAX(P.ENDDATE) AS PERIODENDDATE
          FROM C_YEAR Y, C_PERIOD P
          WHERE Y.C_YEAR_ID = P.C_YEAR_ID
            AND Y.ISACTIVE = 'Y'
            AND P.ISACTIVE = 'Y'
            AND Y.C_CALENDAR_ID = (SELECT O.C_CALENDAR_ID 
                                   FROM AD_ORG O
                                   WHERE AD_ORG_ID = AD_ORG_GETCALENDAROWNER(v_Org_ID))
          GROUP BY Y.C_CALENDAR_ID, Y.C_YEAR_ID) A
    WHERE PERIODSTARTDATE <= v_DateInvoiced
      AND PERIODENDDATE+1 > v_DateInvoiced ;
    IF (v_count<>0) THEN
      SELECT PERIODSTARTDATE, PERIODENDDATE
        INTO v_PeriodStartDate, v_PeriodEndDate
      FROM (SELECT Y.C_CALENDAR_ID, Y.C_YEAR_ID,
                MIN(P.STARTDATE) AS PERIODSTARTDATE, MAX(P.ENDDATE) AS PERIODENDDATE
            FROM C_YEAR Y, C_PERIOD P
            WHERE Y.C_YEAR_ID = P.C_YEAR_ID
              AND Y.ISACTIVE = 'Y'
              AND P.ISACTIVE = 'Y'
              AND Y.C_CALENDAR_ID = (SELECT O.C_CALENDAR_ID 
                                     FROM AD_ORG O
                                     WHERE AD_ORG_ID = AD_ORG_GETCALENDAROWNER(v_Org_ID))
            GROUP BY Y.C_CALENDAR_ID, Y.C_YEAR_ID) A
      WHERE PERIODSTARTDATE <= v_DateInvoiced
        AND PERIODENDDATE+1 > v_DateInvoiced ;
      IF (v_PeriodStartDate IS NOT NULL AND v_PeriodEndDate IS NOT NULL) THEN
        SELECT D.AD_ORG_ID INTO v_DocNo_Org_ID
        FROM C_DOCTYPE D
        WHERE D.C_DOCTYPE_ID = v_DocTypeTarget_ID ;
        SELECT COUNT(*) INTO v_count
        FROM C_INVOICE I
        WHERE I.DOCUMENTNO = v_DocumentNo
          AND I.C_DOCTYPETARGET_ID = v_DocTypeTarget_ID
          AND I.DATEINVOICED >= v_PeriodStartDate
          AND I.DATEINVOICED < v_PeriodEndDate+1 
          AND I.C_INVOICE_ID <> v_Record_ID 
          AND AD_ISORGINCLUDED(I.AD_ORG_ID, v_DocNo_Org_ID, I.AD_CLIENT_ID) <> -1
          AND I.AD_CLIENT_ID = v_Client_ID ;
        IF (v_count<>0) THEN
          RAISE EXCEPTION '%', '@DifferentDocumentNo@'; --OBTG:-20000--
        END IF;
      END IF;
    END IF;
    -- Check that quantities are negative for return invoices
    IF (v_isreturndoctype = 'Y') THEN
      SELECT count(*) INTO v_count
      FROM c_invoiceline
      WHERE c_invoice_discount_id IS NULL
        AND qtyinvoiced > 0
        AND c_invoice_id = v_Record_ID
        AND NOT EXISTS (SELECT 1 FROM c_invoiceline L
			LEFT JOIN M_PRODUCT P ON L.M_PRODUCT_ID = P.M_PRODUCT_ID
			JOIN C_DISCOUNT CD ON CD.M_PRODUCT_ID=P.M_PRODUCT_ID
			WHERE P.M_PRODUCT_ID=C_INVOICELINE.M_PRODUCT_ID);

      IF (v_count <> 0) THEN
        RAISE EXCEPTION '%', '@ReturnInvoiceNegativeQty@'; --OBTG:-20000--
      END IF;
    END IF;
  END IF;
--------------------------------------------------Added by Asutosh on 19-01-17-------------------------------------
/*Insert Invoice Lines from Witholding Tax tab*/
IF (v_DocStatus='DR') THEN

PERFORM cwtx_invline_insertion(v_Record_ID);
--Added by usha on 17-10-2017 for rounding off line insert

--Added condition by Ashutosh on 25-10-17 i.e if it's Expense Invoice, this rounding block shouldn't execute
select name into v_doctypeName from c_doctype where c_doctype_id = v_DocTypeTarget_ID;


-- Code Commented/added 12-July-2019
-- For Expense Invoice Restriction for allowing rounding off difference for Expense Invoice
IF(v_doctypeName != 'Expense Invoice') then

SELECT '0.'||split_part(to_char(grandtotal),'.',2) INTO v_Gross_DecimalValue 
FROM C_Invoice  WHERE c_invoice_id=v_Record_ID;

  select max(line) into v_lineno_round from c_invoiceline where c_invoice_id=v_Record_ID;
  select c_tax_id into v_tax from c_tax where name ='No Tax';

---Get Purchase/Sales Rounding Off account from c_AcctSchema_default(General Ledger configuration)
IF(v_IsSOTrx='Y')THEN
 SELECT CGA.C_GLItem_id INTO v_Rounding_Account
	FROM C_Glitem_Acct CGA
	LEFT JOIN c_validCombination cvc ON cvc.c_validCombination_id=CGA.Glitem_Credit_Acct
        LEFT JOIN c_elementvalue ev ON ev.c_elementvalue_id=cvc.account_id
	WHERE CGA.Glitem_Credit_Acct=(select EM_Expur_S_Rounding_Acct  from C_AcctSchema_Default limit 1);
 ELSE

  SELECT  CGA.C_GLItem_id INTO v_Rounding_Account
	FROM C_Glitem_Acct CGA
	LEFT JOIN c_validCombination cvc ON cvc.c_validCombination_id=CGA.Glitem_Credit_Acct
        LEFT JOIN c_elementvalue ev ON ev.c_elementvalue_id=cvc.account_id
	WHERE CGA.Glitem_Credit_Acct=(select EM_Expur_P_Rounding_Acct  from C_AcctSchema_Default limit 1);
	
END IF;--Ends IF(NEW.ISSoTrx='Y')THEN

IF(v_Rounding_Account IS NULL)THEN
RAISE EXCEPTION '%','Rounding Of Account/GL Item Not Defined';
ELSE
IF(v_Gross_DecimalValue >= 0.5)THEN
v_Gross_DecimalValue = ROUND(1-(v_Gross_DecimalValue),2);
insert into c_invoiceline(c_invoiceline_id,ad_client_id,ad_org_id,createdby,updatedby,c_invoice_id,line,
		financial_invoice_line,account_id,em_exs_user_qty,em_exs_user_uom_id,em_exs_unitprice,
		qtyinvoiced,priceactual,c_tax_id,linenetamt,em_expur_total_invamt) 
	values(get_uuid(),v_Client_ID, v_Org_ID, v_UpdatedBy,v_UpdatedBy,
	v_Record_ID,v_lineno_round+10,'Y',v_Rounding_Account,1,'100',v_Gross_DecimalValue,1,v_Gross_DecimalValue,
	v_tax,v_Gross_DecimalValue,v_Gross_DecimalValue);

ELSIF(v_Gross_DecimalValue < 0.5 OR v_Gross_DecimalValue != '0.' OR v_Gross_DecimalValue != '0.00')THEN
v_Gross_DecimalValue = -(v_Gross_DecimalValue);
 
IF(v_Gross_DecimalValue <> 0.00) THEN 

insert into c_invoiceline(c_invoiceline_id,ad_client_id,ad_org_id,createdby,updatedby,c_invoice_id,line,
		financial_invoice_line,account_id,em_exs_user_qty,em_exs_user_uom_id,em_exs_unitprice,
		qtyinvoiced,priceactual,c_tax_id,linenetamt,em_expur_total_invamt) 
	values(get_uuid(),v_Client_ID, v_Org_ID, v_UpdatedBy,v_UpdatedBy,
	v_Record_ID,v_lineno_round+10,'Y',v_Rounding_Account,1,'100',v_Gross_DecimalValue,1,v_Gross_DecimalValue,
	v_tax,v_Gross_DecimalValue,v_Gross_DecimalValue);
END IF;--Ends IF(v_Gross_DecimalValue <> 0.00) THEN 
END IF;--Ends IF(v_Gross_DecimalValue >= 0.5)THEN
END IF;--Ends IF(v_Rounding_Account IS NULL)THEN
 --Ends usha logic
  
	ELSE
	--Code Added On 26-July-2019 - For Adding Roudning Off Calculation For Expense Invoice And Inserting Line Trx Org Also
	----------------------------------------------------------------------------------------------------------------------
			SELECT '0.'||split_part(to_char(grandtotal),'.',2) INTO v_Gross_DecimalValue 
			FROM C_Invoice  WHERE c_invoice_id=v_Record_ID;

			select EM_Exfm_Trx_Ad_Org_ID into v_Org_As_Location_ID 
			from C_Invoice  WHERE c_invoice_id=v_Record_ID;

			--Get Cost Center For Above Transaction Organization	
			select value into v_TrxO_rg_SearchKey from ad_org where ad_org_id = v_Org_As_Location_ID;		

			v_CostCenter_SearchKey:= v_TrxO_rg_SearchKey||'01';



			select C_Costcenter_ID into v_CostCenter_ID from C_Costcenter where AD_Org_ID = v_Org_As_Location_ID 
			and Value = v_CostCenter_SearchKey limit 1;

			if(v_CostCenter_ID is null) then
				select C_Costcenter_ID into v_CostCenter_ID from C_Costcenter where AD_Org_ID = v_Org_As_Location_ID 
				order by Value limit 1;
			end if;


			  select max(line) into v_lineno_round from c_invoiceline where c_invoice_id=v_Record_ID;
			  select c_tax_id into v_tax from c_tax where name ='No Tax';

			---Get Purchase/Sales Rounding Off account from c_AcctSchema_default(General Ledger configuration)
			IF(v_IsSOTrx='Y')THEN
			 SELECT CGA.C_GLItem_id INTO v_Rounding_Account
				FROM C_Glitem_Acct CGA
				LEFT JOIN c_validCombination cvc ON cvc.c_validCombination_id=CGA.Glitem_Credit_Acct
				LEFT JOIN c_elementvalue ev ON ev.c_elementvalue_id=cvc.account_id
				WHERE CGA.Glitem_Credit_Acct=(select EM_Expur_S_Rounding_Acct  from C_AcctSchema_Default limit 1);
			 ELSE

			  SELECT  CGA.C_GLItem_id INTO v_Rounding_Account
				FROM C_Glitem_Acct CGA
				LEFT JOIN c_validCombination cvc ON cvc.c_validCombination_id=CGA.Glitem_Credit_Acct
				LEFT JOIN c_elementvalue ev ON ev.c_elementvalue_id=cvc.account_id
				WHERE CGA.Glitem_Credit_Acct=(select EM_Expur_P_Rounding_Acct  from C_AcctSchema_Default limit 1);
				
			END IF;--Ends IF(NEW.ISSoTrx='Y')THEN

			IF(v_Rounding_Account IS NULL)THEN
			RAISE EXCEPTION '%','Rounding Of Account/GL Item Not Defined';
			ELSE
			IF(v_Gross_DecimalValue >= 0.5)THEN
			v_Gross_DecimalValue = ROUND(1-(v_Gross_DecimalValue),2);
			insert into c_invoiceline(c_invoiceline_id,ad_client_id,ad_org_id,createdby,updatedby,c_invoice_id,line,
					financial_invoice_line,account_id,em_exs_user_qty,em_exs_user_uom_id,em_exs_unitprice,
					qtyinvoiced,priceactual,c_tax_id,linenetamt,em_expur_total_invamt, EM_Exfm_Ad_Org_ID, C_Costcenter_ID) 
				values(get_uuid(),v_Client_ID, v_Org_ID, v_UpdatedBy,v_UpdatedBy,
				v_Record_ID,v_lineno_round+10,'Y',v_Rounding_Account,1,'100',v_Gross_DecimalValue,1,v_Gross_DecimalValue,
				v_tax,v_Gross_DecimalValue,v_Gross_DecimalValue, v_Org_As_Location_ID, v_CostCenter_ID);

			ELSIF(v_Gross_DecimalValue < 0.5 OR v_Gross_DecimalValue != '0.' OR v_Gross_DecimalValue != '0.00')THEN
			v_Gross_DecimalValue = -(v_Gross_DecimalValue);
			 
			IF(v_Gross_DecimalValue <> 0.00) THEN 

			insert into c_invoiceline(c_invoiceline_id,ad_client_id,ad_org_id,createdby,updatedby,c_invoice_id,line,
					financial_invoice_line,account_id,em_exs_user_qty,em_exs_user_uom_id,em_exs_unitprice,
					qtyinvoiced,priceactual,c_tax_id,linenetamt,em_expur_total_invamt, EM_Exfm_Ad_Org_ID, C_Costcenter_ID) 
				values(get_uuid(),v_Client_ID, v_Org_ID, v_UpdatedBy,v_UpdatedBy,
				v_Record_ID,v_lineno_round+10,'Y',v_Rounding_Account,1,'100',v_Gross_DecimalValue,1,v_Gross_DecimalValue,
				v_tax,v_Gross_DecimalValue,v_Gross_DecimalValue, v_Org_As_Location_ID, v_CostCenter_ID);
			END IF;--Ends IF(v_Gross_DecimalValue <> 0.00) THEN 
			END IF;--Ends IF(v_Gross_DecimalValue >= 0.5)THEN
			END IF;--Ends IF(v_Rounding_Account IS NULL)THEN


	 END IF; --ends (Added condition by Ashutosh on 25-10-17 i.e if it's Expense Invoice, this rounding block shouldn't execute)




END IF; --end if commented for removing Expense Invoice Restriction For Rounding Off Line Insertion



------------------------------------------------Ends by Asutosh------------------------------------------------------

  IF (NOT FINISH_PROCESS) THEN
    /**
     * Unlock
     */
    IF (v_DocAction='XL') THEN
      UPDATE C_INVOICE
      SET Processing='N',
          DocAction='--',
          Updated=TO_DATE(NOW()),
          UpdatedBy=v_UpdatedBy
      WHERE C_Invoice_ID=v_Record_ID;
      FINISH_PROCESS:=TRUE;
    END IF;
  END IF;--FINISH_PROCESS
  IF (NOT FINISH_PROCESS) THEN
    IF (v_Processing='Y') THEN
      RAISE EXCEPTION '%', '@OtherProcessActive@'; --OBTG:-20000--
    END IF;
  END IF;--FINISH_PROCESS
  IF (NOT FINISH_PROCESS) THEN
    /**
     * Everything done
     */
    IF (v_Processed='Y' AND v_DocAction NOT IN('RC', 'RE')) THEN
      RAISE EXCEPTION '%', '@AlreadyPosted@'; --OBTG:-20000--
    END IF;
  END IF;--FINISH_PROCESS

IF (NOT FINISH_PROCESS) THEN
   --C_Invoice_Post - Valistaion Process Extension Point
    SELECT count(*) INTO v_count
    FROM DUAL
    where exists (select 1 from ad_ep_procedures where ad_extension_points_id = 'C3A4ABF2DF544F4694142DA9E79495F7');
    IF (v_count=1) THEN
      DECLARE
        v_ep_instance VARCHAR(32); --OBTG:VARCHAR2--
        v_extension_point_id VARCHAR(32) := 'C3A4ABF2DF544F4694142DA9E79495F7'; --OBTG:VARCHAR2--
      BEGIN
        v_ep_instance := get_uuid();
        PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'Record_ID',
          v_record_id, NULL, NULL, NULL, NULL, NULL, NULL);
        PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'DocAction',
          v_DocAction, NULL, NULL, NULL, NULL, NULL, NULL);
        PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'User',
          v_User_ID, NULL, NULL, NULL, NULL, NULL, NULL);
        PERFORM AD_EXTENSION_POINT_HANDLER(v_ep_instance, v_extension_point_id);

        DELETE FROM ad_ep_instance_para
        WHERE ad_ep_instance_id = v_ep_instance;
      END;
    END IF;
 END IF;
    

  --cbt taxpayment
  IF (NOT FINISH_PROCESS) THEN
    IF (v_docaction IN ('VO', 'RE', 'RC')
       AND v_docstatus IN('CO', 'CL')) THEN
      SELECT COUNT(*) INTO v_count
      FROM c_taxregisterline trl
           INNER JOIN c_invoicetax it ON trl.c_invoicetax_id = it.c_invoicetax_id
           INNER JOIN c_taxregister tr ON tr.c_taxregister_id= trl.c_taxregister_id
           INNER JOIN c_taxpayment tp ON tr.c_taxpayment_id=tp.c_taxpayment_id
      WHERE it.c_invoice_id = v_record_id
        AND tp.processed='Y';
      IF (v_count > 0) THEN
        RAISE EXCEPTION '%', '@20615@'; --OBTG:-20000--
      ELSE
        DELETE FROM c_taxregisterline 
        WHERE c_taxregisterline.c_invoicetax_id IN
              (SELECT trl.c_invoicetax_id
               FROM c_taxregisterline trl
                    INNER JOIN c_invoicetax it ON trl.c_invoicetax_id = it.c_invoicetax_id
                    INNER JOIN c_taxregister tr ON tr.c_taxregister_id= trl.c_taxregister_id
                    INNER JOIN c_taxpayment tp ON tr.c_taxpayment_id=tp.c_taxpayment_id
               WHERE it.c_invoice_id = v_record_id
                 AND tp.processed='N');
      END IF;
    END IF;
  END IF;

  --end cbt taxpaymant
  IF (NOT FINISH_PROCESS) THEN
  /**
    *Update Invoice Net Unit Price to Product purchasing Plan Table
    */
    IF(v_isSoTrx ='N') THEN
      FOR Cur_InvoiceNetLine IN (SELECT * FROM C_INVOICELINE WHERE C_Invoice_Id =  v_Record_ID)
      LOOP
          UPDATE M_PRODUCT_PO SET PriceLastInv=Cur_InvoiceNetLine.PriceActual 
          Where C_BPARTNER_ID = v_BPartner_ID AND M_PRODUCT_ID = Cur_InvoiceNetLine.M_PRODUCT_ID
          AND Ad_Isorgincluded(Cur_InvoiceNetLine.AD_ORG_ID,AD_ORG_ID, Cur_InvoiceNetLine.AD_Client_ID) <> -1;
      END LOOP;
    END IF;
    /**
     * Void if Document not processed
     */
    IF (v_DocAction='VO' AND v_DocStatus NOT IN('CO', 'RE')) THEN

        SELECT COUNT(*) INTO v_count
        FROM C_INVOICE
        WHERE C_INVOICE_ID=v_Record_ID
        AND (EXISTS (SELECT 1
            FROM C_INVOICELINE
            WHERE C_INVOICE_ID=v_Record_ID)
	    OR EXISTS (SELECT 1
            FROM C_INVOICETAX
            WHERE C_INVOICE_ID=v_Record_ID));
	IF (v_count=0) THEN
            RAISE EXCEPTION '%', '@InvoicesNeedLines@'; --OBTG:-20000--
        END IF;

      SELECT COUNT(*) INTO v_count
      FROM C_DEBT_PAYMENT
      WHERE C_Invoice_ID = v_Record_ID;
      IF (v_count>0) THEN
        RAISE EXCEPTION '%', '@InvoiceWithManualDP@'; --OBTG:-20000--
      ELSE
        -- Reset Lines to 0
        UPDATE C_INVOICELINE
        SET QtyInvoiced=0,
            LineNetAmt=0,
            line_gross_amount=0,
            Updated=TO_DATE(NOW()),
            UpdatedBy=v_UpdatedBy
        WHERE C_Invoice_ID=v_Record_ID;

        UPDATE C_INVOICE
        SET DocStatus='VO',
            DocAction='--',
            Processed='Y',
            Updated=TO_DATE(NOW()),
            UpdatedBy=v_UpdatedBy
        WHERE C_Invoice_ID=v_Record_ID;
      END IF;
      FINISH_PROCESS:=TRUE;
    END IF;
  END IF;--FINISH_PROCESS
--raise exception '%',FINISH_PROCESS;
  IF (NOT FINISH_PROCESS) THEN
    /**************************************************************************
     * Start Processing ------------------------------------------------------
     *************************************************************************/
    v_ResultStr:='LockingInvoice';
    BEGIN -- FOR COMMIT
      UPDATE C_INVOICE
      SET Processing='Y',
          Updated=TO_DATE(NOW()),
          UpdatedBy=v_UpdatedBy
      WHERE C_Invoice_ID=v_Record_ID;
      -- Now, needs to go to END_PROCESSING to unlock
      -- This Commit must remanin due differences between PL execution in Oracle and Postgres
      IF (p_PInstance_ID IS NOT NULL) THEN
        -- COMMIT;
      END IF;
     EXCEPTION WHEN OTHERS THEN RAISE EXCEPTION '%','DATA_EXCEPTION';
    END;--FOR  COMMIT
    BEGIN -- FOR COMMIT

      SELECT COUNT(*)
        INTO v_Count
      FROM C_INVOICE I, C_INVOICELINE IL
      WHERE I.C_INVOICE_ID = IL.C_INVOICE_ID
        AND AD_ISORGINCLUDED(IL.AD_Org_ID, I.AD_Org_ID, I.AD_Client_ID) = -1
        AND I.C_INVOICE_ID = v_Record_ID;
      IF (v_Count>0) THEN
        RAISE EXCEPTION '%', '@NotCorrectOrgLines@' ; --OBTG:-20000--
      END IF;


      SELECT COUNT(*) INTO v_Count
      FROM C_INVOICE C,
           C_DOCTYPE
      WHERE C_DOCTYPE.DocBaseType IN (
                                      select docbasetype
                                      from c_doctype
                                      where ad_table_id='318'
                                        and isactive='Y'
                                        and ad_client_id=C.AD_Client_ID)
        AND C_DOCTYPE.IsSOTrx=C.ISSOTRX
        AND Ad_Isorgincluded(C.AD_Org_ID,C_DOCTYPE.AD_Org_ID, C.AD_Client_ID) <> -1
        AND C.C_DOCTYPETARGET_ID = C_DOCTYPE.C_DOCTYPE_ID
        AND C.C_INVOICE_ID = V_RECORD_ID;
      IF (v_Count=0) THEN
        RAISE EXCEPTION '%', '@NotCorrectOrgDoctypeInvoice@'; --OBTG:-20000--
      END IF;

      /**
       * Reverse Correction requires completes invoice ========================
       */
      IF (v_DocAction='RC' AND v_DocStatus='CO') THEN
        v_ResultStr:='ReverseCorrection';
        -- Copy Invoice with reverese Quantities (or Amounts)
        v_RInvoice_ID:= get_uuid();
        SELECT COALESCE(C_DOCTYPE_REVERSED_ID, C_DOCTYPE_ID) INTO v_DoctypeReversed_ID
        FROM C_DOCTYPE
        WHERE C_DOCTYPE_ID=v_DocType_ID;
        SELECT * INTO  v_RDocumentNo FROM Ad_Sequence_Doctype(v_DoctypeReversed_ID, v_Record_ID, 'Y') ;
        IF (v_RDocumentNo IS NULL) THEN
          SELECT * INTO  v_RDocumentNo FROM Ad_Sequence_Doc('DocumentNo_C_Invoice', v_Client_ID, 'Y') ;
        END IF;
        v_Message:='@ReversedBy@: ' || v_RDocumentNo;
        --
        RAISE NOTICE '%','Reversal Invoice_ID=' || v_RInvoice_ID || ' DocumentNo=' || v_RDocumentNo ;
        v_ResultStr:='InsertInvoice ID=' || v_RInvoice_ID;
        -- Don't copy C_Payment_ID or C_CashLine_ID
        INSERT INTO C_INVOICE
            (
              C_Invoice_ID, C_Order_ID, AD_Client_ID, AD_Org_ID,
              IsActive, Created, CreatedBy, Updated,
              UpdatedBy, IsSOTrx, DocumentNo, DocStatus,
              DocAction, Processing, Processed, C_DocType_ID,
              C_DocTypeTarget_ID, Description, SalesRep_ID,
              DateInvoiced, DatePrinted, IsPrinted, TaxDate,
              DateAcct, C_PaymentTerm_ID, C_BPartner_ID, C_BPartner_Location_ID,
              AD_User_ID, POReference, DateOrdered, IsDiscountPrinted,
              C_Currency_ID, PaymentRule, C_Charge_ID, ChargeAmt,
              TotalLines, GrandTotal, M_PriceList_ID, C_Campaign_ID,
              C_Project_ID, C_Activity_ID, AD_OrgTrx_ID, User1_ID,
              User2_ID, fin_paymentmethod_id, C_CostCenter_ID,
              A_Asset_ID
            )
          SELECT v_RInvoice_ID, C_Order_ID, AD_Client_ID, AD_Org_ID,
            IsActive, TO_DATE(NOW()), v_UpdatedBy, TO_DATE(NOW()),
            v_UpdatedBy, IsSOTrx, v_RDocumentNo, 'DR',
             'CO', 'N', 'N', v_DoctypeReversed_ID,
            v_DoctypeReversed_ID, '(*R*: ' || DocumentNo || ') ' || COALESCE(TO_CHAR(Description), ''), SalesRep_ID,
            TO_DATE(NOW()), NULL, 'N', NULL,
            TO_DATE(NOW()), C_PaymentTerm_ID, C_BPartner_ID, C_BPartner_Location_ID,
            AD_User_ID, POReference, DateOrdered, IsDiscountPrinted,
            C_Currency_ID, PaymentRule, C_Charge_ID, ChargeAmt * -1,
            TotalLines * -1, GrandTotal * -1, M_PriceList_ID, C_Campaign_ID,
            C_Project_ID, C_Activity_ID, AD_OrgTrx_ID, User1_ID,
            User2_ID, fin_paymentmethod_id, C_CostCenter_ID,
            A_Asset_ID
          FROM C_INVOICE
          WHERE C_Invoice_ID=v_Record_ID;
        -- Create Reversed invoice relation
        INSERT INTO C_Invoice_Reverse
          (
           C_Invoice_Reverse_ID,AD_Client_ID, AD_Org_ID,
           IsActive, Created, CreatedBy, Updated,
           UpdatedBy, C_Invoice_ID, Reversed_C_Invoice_ID
          )
          SELECT get_uuid(), AD_Client_ID, AD_Org_ID,
              'Y', TO_DATE(NOW()), v_UpdatedBy, TO_DATE(NOW()),
              v_UpdatedBy, v_RInvoice_ID, C_Invoice_ID
          FROM C_INVOICE
          WHERE C_Invoice_ID=v_Record_ID;

        
        --  Delete C_Invoice_Discounts inserted by the trigger
        DELETE FROM C_INVOICE_DISCOUNT WHERE C_Invoice_ID=v_RInvoice_ID;
        --  Insert discounts as in the reversed invoice
        FOR Cur_Discount IN
          (SELECT *
           FROM C_INVOICE_DISCOUNT
           WHERE C_Invoice_ID=v_Record_ID
           ORDER BY LINE
          )
        LOOP
          INSERT INTO C_INVOICE_DISCOUNT
            (
              C_INVOICE_DISCOUNT_ID, AD_CLIENT_ID, AD_ORG_ID, ISACTIVE,
              CREATED, CREATEDBY, UPDATED, UPDATEDBY,
              C_INVOICE_ID, C_DISCOUNT_ID, LINE, CASCADE
            )
            VALUES
            (
              get_uuid(), Cur_Discount.AD_Client_ID, Cur_Discount.AD_Org_ID, 'Y',
              TO_DATE(NOW()), v_UpdatedBy, TO_DATE(NOW()), v_UpdatedBy,
              v_RInvoice_ID, Cur_Discount.C_Discount_ID, Cur_Discount.Line, Cur_Discount.CASCADE
            );
        END LOOP;
        -- Create Reversal Invoice Lines
        FOR Cur_InvoiceLine IN
          (SELECT *
           FROM C_INVOICELINE
           WHERE C_Invoice_ID=v_Record_ID
             AND C_INVOICE_DISCOUNT_ID IS NULL
           ORDER BY Line
          )
        LOOP
          v_NextNo := get_uuid();
          INSERT INTO C_INVOICELINE
            (
              C_InvoiceLine_ID, AD_Client_ID, AD_Org_ID, IsActive,
              Created, CreatedBy, Updated, UpdatedBy,
              C_Invoice_ID, C_OrderLine_ID, M_InOutLine_ID, Line,
              Description, M_Product_ID, QtyInvoiced, PriceList,
              PriceActual, LineNetAmt, C_Charge_ID, ChargeAmt,
              C_UOM_ID, C_Tax_ID, PriceStd, 
              Financial_Invoice_Line, Account_ID,Taxbaseamt,
              gross_unit_price, line_gross_amount,
              isdeferred, defplantype, periodnumber, c_period_id,
              c_bpartner_id, c_project_id, c_projectline_id, a_asset_id,
              user1_id, user2_id, c_costcenter_id)
            VALUES
            (
              v_NextNo, Cur_InvoiceLine.AD_Client_ID, Cur_InvoiceLine.AD_Org_ID, 'Y',
              TO_DATE(NOW()), v_UpdatedBy, TO_DATE(NOW()), v_UpdatedBy,
              v_RInvoice_ID, Cur_InvoiceLine.C_OrderLine_ID, Cur_InvoiceLine.M_InoutLine_ID, Cur_InvoiceLine.Line,
               '*R*: ' || Cur_InvoiceLine.Description, Cur_InvoiceLine.M_Product_ID, Cur_InvoiceLine.QtyInvoiced * -1, Cur_InvoiceLine.PriceList,
              Cur_InvoiceLine.PriceActual, Cur_InvoiceLine.LineNetAmt * -1, Cur_InvoiceLine.C_Charge_ID, Cur_InvoiceLine.ChargeAmt * -1,
              Cur_InvoiceLine.C_UOM_ID, Cur_InvoiceLine.C_Tax_ID, Cur_InvoiceLine.PriceStd, 
              Cur_InvoiceLine.Financial_Invoice_Line, Cur_InvoiceLine.Account_ID,Cur_InvoiceLine.Taxbaseamt * -1,
              Cur_InvoiceLine.gross_unit_price, Cur_InvoiceLine.line_gross_amount * -1,
              Cur_InvoiceLine.isdeferred, Cur_InvoiceLine.defplantype, Cur_InvoiceLine.periodnumber, Cur_InvoiceLine.c_period_id,
              Cur_InvoiceLine.c_bpartner_id, Cur_InvoiceLine.c_project_id, Cur_InvoiceLine.c_projectline_id, Cur_InvoiceLine.a_asset_id,
              Cur_InvoiceLine.user1_id, Cur_InvoiceLine.user2_id, Cur_InvoiceLine.C_CostCenter_ID
            );
          INSERT INTO M_MATCHINV
            (M_MATCHINV_ID, AD_CLIENT_ID, AD_ORG_ID, ISACTIVE, CREATED, CREATEDBY, UPDATED, UPDATEDBY,
            M_INOUTLINE_ID, C_INVOICELINE_ID, M_PRODUCT_ID, DATETRX, QTY, PROCESSING, PROCESSED, POSTED)
            SELECT
              get_uuid(), AD_CLIENT_ID, AD_ORG_ID, ISACTIVE, TO_DATE(NOW()), v_UpdatedBy, TO_DATE(NOW()), v_UpdatedBy,
              M_INOUTLINE_ID, v_NextNo, M_PRODUCT_ID, DATETRX, -QTY, 'N', 'Y', 'N'
            FROM M_MATCHINV
            WHERE C_INVOICELINE_ID = Cur_InvoiceLine.C_InvoiceLine_ID;
          /* OrderLine.qtyInvoiced is updated in c_invoicePost
          UPDATE C_OrderLine
          SET QtyInvoiced = QtyInvoiced - Cur_InvoiceLine.QtyInvoiced,
              Updated = TO_DATE(NOW()),
              UpdatedBy=v_UpdatedBy
          WHERE C_OrderLine_ID=Cur_InvoiceLine.C_OrderLine_ID; */

          -- Create Reversal Accounting Dimensions
          FOR Cur_InvoiceLineAcctDim IN
          (SELECT *
           FROM C_INVOICELINE_ACCTDIMENSION
           WHERE C_InvoiceLine_ID=Cur_InvoiceLine.C_InvoiceLine_ID)
            LOOP
                    
            INSERT INTO C_INVOICELINE_ACCTDIMENSION(
            c_invoiceline_acctdimension_id, ad_client_id, ad_org_id, isactive, created, createdby, updated, updatedby, c_invoiceline_id, 
            amt, c_project_id, c_campaign_id, user1_id, user2_id, c_costcenter_id, c_activity_id, c_bpartner_id, m_product_id) 
            values(
            get_uuid(), Cur_InvoiceLineAcctDim.ad_client_id, Cur_InvoiceLineAcctDim.ad_org_id, Cur_InvoiceLineAcctDim.isactive, TO_DATE(NOW()), v_UpdatedBy, TO_DATE(NOW()), v_UpdatedBy, v_NextNo,
            Cur_InvoiceLineAcctDim.amt * -1, Cur_InvoiceLineAcctDim.c_project_id, Cur_InvoiceLineAcctDim.c_campaign_id, Cur_InvoiceLineAcctDim.user1_id, Cur_InvoiceLineAcctDim.user2_id, 
            Cur_InvoiceLineAcctDim.c_costcenter_id, Cur_InvoiceLineAcctDim.c_activity_id, Cur_InvoiceLineAcctDim.c_bpartner_id, Cur_InvoiceLineAcctDim.m_product_id);

            END LOOP; -- Create Reversal Accounting Dimensions

					-- Add promotions
					FOR Cur_Offer IN 
						(SELECT *
						 FROM C_INVOICELINE_OFFER
						 WHERE c_InvoiceLine_ID = Cur_InvoiceLine.c_InvoiceLine_ID
						) LOOP
						INSERT INTO C_INVOICELINE_OFFER
						(c_invoiceline_offer_id, ad_client_id, ad_org_id,                         
						 isactive, createdby, updatedby,           
						 c_invoiceline_id, line, m_offer_id,          
						 priceoffer, priceoffergross, amtoffer, 
						 totalamt, displayedtotalamt)
						 values
						(get_uuid(), Cur_Offer.AD_Client_ID, Cur_Offer.AD_Org_ID,
						 'Y', v_UpdatedBy, v_UpdatedBy,
						 v_NextNo, Cur_Offer.line, Cur_Offer.m_offer_id,
						 Cur_Offer.priceoffer, Cur_Offer.priceoffergross, Cur_Offer.amtoffer,
						 Cur_Offer.totalamt, Cur_Offer.displayedtotalamt);
					END LOOP;
        END LOOP; -- Create Reversal Invoice Lines

        -- Check if there is any manually added tax
        FOR Cur_InvoiceTax IN
          (SELECT c_tax_id, ad_client_id, ad_org_id, isactive,
            taxbaseamt, taxamt, recalculate
          FROM c_invoicetax
          WHERE c_invoice_id = v_Record_ID
          EXCEPT
          SELECT c_tax_id, ad_client_id, ad_org_id, isactive,
            -taxbaseamt, -taxamt, recalculate
          FROM c_invoicetax
          WHERE c_invoice_id = v_RInvoice_ID)
        LOOP
          SELECT MAX(line) + 10 INTO v_LineMax FROM c_invoicetax WHERE c_invoice_id = v_RInvoice_ID;
          INSERT INTO c_invoicetax(c_tax_id, c_invoice_id, ad_client_id, ad_org_id, isactive, created, createdby, updated, updatedby,
            taxbaseamt, taxamt, line, c_invoicetax_id, recalculate)
          VALUES(Cur_InvoiceTax.c_tax_id, v_RInvoice_ID, Cur_InvoiceTax.ad_client_id, Cur_InvoiceTax.ad_org_id, Cur_InvoiceTax.isactive,
            TO_DATE(NOW()), v_UpdatedBy, TO_DATE(NOW()), v_UpdatedBy, -Cur_InvoiceTax.taxbaseamt, -Cur_InvoiceTax.taxamt, v_LineMax,
            get_uuid(), Cur_InvoiceTax.recalculate);
        END LOOP;
        
        -- Close Invoice
        UPDATE C_INVOICE
        SET DocStatus='VO', -- it IS reversed
            Description=COALESCE(TO_CHAR(Description), '') || ' (*R* -> ' || v_RDocumentNo || ')',
            DocAction='--',
            Processed='Y',
            Updated=TO_DATE(NOW())
        WHERE C_Invoice_ID=v_Record_ID;
        -- Update reversal invoice dates
        IF (v_voiddate_inv IS NOT NULL) THEN
          UPDATE C_INVOICE SET DateInvoiced = v_voiddate_inv WHERE C_Invoice_ID=v_RInvoice_ID;
        END IF;
        IF (v_voiddate_acct IS NOT NULL) THEN
          UPDATE C_INVOICE SET DateAcct = v_voiddate_acct WHERE C_Invoice_ID=v_RInvoice_ID;
        END IF;
        IF (v_prepaymentamt !=0) THEN
          UPDATE C_INVOICE SET prepaymentamt = v_prepaymentamt WHERE C_Invoice_ID=v_RInvoice_ID;
        END IF;
        -- Post Reversal
        PERFORM C_INVOICE_POST(NULL, v_RInvoice_ID) ;
        -- Reversal Transaction is closed
        UPDATE C_INVOICE
        SET DocStatus='VO', -- the reversal transaction (issue 18633) (rolledback in issue 19541)
            DocAction='--',
            Processed='Y'
        WHERE C_Invoice_ID=v_RInvoice_ID;
        -- If Payments from both invoices are pending, create a new settlement and cancel them
        SELECT COUNT(*) INTO v_count
        FROM C_DEBT_PAYMENT dp
        WHERE C_Debt_Payment_Status(dp.C_Settlement_Cancel_ID, dp.Cancel_Processed, dp.Generate_Processed, dp.IsPaid, dp.IsValid, dp.C_CashLine_ID, dp.C_BankStatementLine_ID)<>'P'
          AND(dp.C_Invoice_ID=v_Record_ID
          OR dp.C_Invoice_ID=v_RInvoice_ID) ;
        -- To cancel, the sum of amounts should be 0
        IF (v_count=0) THEN
          SELECT SUM(AMOUNT) INTO v_count
          FROM C_DEBT_PAYMENT dp
          WHERE dp.C_Invoice_ID=v_Record_ID
            OR dp.C_Invoice_ID=v_RInvoice_ID;
          IF (v_count=0) THEN
            v_SettlementDocType_ID:=Ad_Get_Doctype(v_Client_ID, v_Org_ID, TO_CHAR('STT')) ;
            v_settlementID := get_uuid();
            SELECT * INTO  v_SDocumentNo FROM Ad_Sequence_Doctype(v_SettlementDocType_ID, v_Record_ID, 'Y') ;
            IF (v_SDocumentNo IS NULL) THEN
              SELECT * INTO  v_SDocumentNo FROM Ad_Sequence_Doc('DocumentNo_C_Settlement', v_Client_ID, 'Y') ;
            END IF;
            INSERT
            INTO C_SETTLEMENT
              (
                C_SETTLEMENT_ID, AD_CLIENT_ID, AD_ORG_ID, ISACTIVE,
                CREATED, CREATEDBY, UPDATED, UPDATEDBY,
                DOCUMENTNO, DATETRX, DATEACCT, SETTLEMENTTYPE,
                C_DOCTYPE_ID, PROCESSING, PROCESSED, POSTED,
                C_CURRENCY_ID, C_PROJECT_ID, C_CAMPAIGN_ID, C_ACTIVITY_ID,
                USER1_ID, USER2_ID, CREATEFROM, ISGENERATED
              )
              SELECT v_settlementID, AD_Client_ID, AD_Org_ID, 'Y',
                TO_DATE(NOW()), v_UpdatedBy, TO_DATE(NOW()), v_UpdatedBy,
                '*RE*'||v_SDocumentNo, TRUNC(TO_DATE(NOW())), TRUNC(TO_DATE(NOW())), 'C',
                v_SettlementDocType_ID, 'N', 'N', 'N',
                C_Currency_ID, C_PROJECT_ID, C_CAMPAIGN_ID, C_ACTIVITY_ID,
                USER1_ID, USER2_ID, 'N', 'Y'
              FROM C_INVOICE
              WHERE C_Invoice_ID=v_Record_ID;
            UPDATE C_DEBT_PAYMENT
            SET C_Settlement_Cancel_id=v_settlementID,
                UPDATED=TO_DATE(NOW()),
                UPDATEDBY=v_UpdatedBy
            WHERE C_DEBT_PAYMENT.C_Invoice_ID=v_Record_ID
              OR C_DEBT_PAYMENT.C_Invoice_ID=v_RInvoice_ID;
            PERFORM C_SETTLEMENT_POST(NULL, v_settlementID) ;
          END IF;
        END IF;
        END_PROCESSING:=TRUE;
      END IF;
    END; -- FOR COMMIT
  END IF;--FINISH_PROCESS
  IF (NOT FINISH_PROCESS AND NOT END_PROCESSING) THEN
    /**************************************************************************
     * Credit Multiplier
     *************************************************************************/
    DECLARE
      v_DocBaseType C_DOCTYPE.DocBaseType%TYPE;
      v_DocTypeIsSOtrx C_DOCTYPE.IsSOtrx%TYPE;
    BEGIN
      -- Is it a Credit Memo?
      SELECT DocBaseType, IsReversal, issotrx INTO v_DocBaseType, v_isReversal, v_DocTypeIsSOtrx
      FROM C_DOCTYPE
      WHERE C_DocType_ID=v_DocType_ID;
      IF (v_DocBaseType IN('ARC', 'API') or (v_isReversal='Y' and v_DocTypeIsSOtrx='Y') or (v_isReversal='N' and v_DocTypeIsSOtrx='N')) THEN
        v_Multiplier:=-1;
      END IF;
    END;
  END IF;--FINISH_PROCESS
  IF (NOT FINISH_PROCESS AND NOT END_PROCESSING) THEN
    /************************************************************************
     * Actions allowed: Reactivate
     * Modified by Jon Alegria
     */
    IF (v_DocAction='RE') THEN
      IF (v_DocStatus<>'CO') THEN
        RAISE EXCEPTION '%', '@NotCompletedInvoice@'; --OBTG:-20000--
      END IF;
      IF (v_Posted='Y') THEN
        RAISE EXCEPTION '%', '@InvoiceDocumentPosted@'; --OBTG:-20000--
      END IF;
      SELECT COUNT(*), MAX(C_DEBT_PAYMENT_ID)
        INTO v_Count, v_Debtpayment_ID
      FROM C_DEBT_PAYMENT
      WHERE C_DEBT_PAYMENT.C_Invoice_ID=v_Record_ID
        AND C_Debt_Payment_Status(C_Settlement_Cancel_ID, Cancel_Processed, C_DEBT_PAYMENT.Generate_Processed, IsPaid, IsValid, C_Cashline_ID, C_BankstatementLine_ID)<>'P'
        AND C_ORDER_ID IS NULL;
      IF (v_Count<>0) THEN
        --Added by P.Sarobe. New messages
        SELECT c_Bankstatementline_Id, c_cashline_id, c_settlement_cancel_id, ispaid, cancel_processed
          INTO v_Bankstatementline_ID, v_CashLine_ID, v_Settlement_Cancel_ID, v_ispaid, v_Cancel_Processed
        FROM C_DEBT_PAYMENT
        WHERE C_Debt_Payment_ID = v_Debtpayment_ID;
        IF (v_Bankstatementline_ID IS NOT NULL) THEN
          SELECT C_BANKSTATEMENT.NAME, C_BANKSTATEMENT.STATEMENTDATE
            INTO v_nameBankstatement, v_dateBankstatement
          FROM C_BANKSTATEMENT, C_BANKSTATEMENTLINE
          WHERE C_BANKSTATEMENT.C_BANKSTATEMENT_ID = C_BANKSTATEMENTLINE.C_BANKSTATEMENT_ID
            AND C_BANKSTATEMENTLINE.C_BANKSTATEMENTLINE_ID = v_Bankstatementline_ID;
          RAISE EXCEPTION '%', '@ManagedDebtPaymentInvoiceBank@'||v_nameBankstatement||' '||'@Bydate@'||v_dateBankstatement ; --OBTG:-20000--
        END IF;
        IF (v_CashLine_ID IS NOT NULL) THEN
          SELECT C_CASH.NAME, C_CASH.STATEMENTDATE
            INTO v_nameCash, v_dateCash
          FROM C_CASH, C_CASHLINE
          WHERE C_CASH.C_CASH_ID = C_CASHLINE.C_CASH_ID
            AND C_CASHLINE.C_CASHLINE_ID = v_CashLine_ID;
          RAISE EXCEPTION '%', '@ManagedDebtPaymentInvoiceCash@'||v_nameCash||' '||'@Bydate@'||v_dateCash ; --OBTG:-20000--
        END IF;
        IF (v_Cancel_Processed='Y' AND v_ispaid='N') THEN
          SELECT documentno, datetrx
            INTO v_documentno_Settlement, v_dateSettlement
          FROM C_SETTLEMENT
          WHERE C_SETTLEMENT_ID = v_Settlement_Cancel_ID;
          RAISE EXCEPTION '%', '@ManagedDebtPaymentOrderCancel@'||v_documentno_Settlement||' '||'@Bydate@'||v_dateSettlement ; --OBTG:-20000--
        END IF;
      END IF;
      SELECT COUNT(*) INTO v_Count
      FROM C_DP_MANAGEMENTLINE ml,
           C_DP_MANAGEMENT m,
           C_DEBT_PAYMENT dp
      WHERE ml.C_DP_Management_ID=m.C_DP_Management_ID
        AND ml.C_Debt_Payment_ID=dp.C_Debt_Payment_ID
        AND dp.C_Invoice_ID=v_Record_ID
        AND m.processed='Y';
      IF (v_Count!=0) THEN
        RAISE EXCEPTION '%', '@DPInvoiceManaged@'; --OBTG:-20000--
      END IF;
      -- Pending undo not Stocked BOM's
      -- Undo BP Statictis
      --Undo first sale
      SELECT MIN(DateAcct) INTO v_FirstSales
      FROM C_INVOICE
      WHERE C_Invoice_ID<>v_Record_ID
        AND C_BPartner_ID=v_BPartner_ID;
      UPDATE C_BPARTNER  SET FirstSale=v_FirstSales  WHERE C_BPartner_ID=v_BPartner_ID;
      -- Undo Last contact
      FOR Cur_LastContact IN
        (SELECT Updated, DocumentNo, Ad_User_ID
         FROM C_INVOICE
         WHERE C_Invoice_ID<>v_Record_ID
           AND Ad_User_ID=v_BPartner_User_ID
         ORDER BY Updated DESC
        )
      LOOP
        UPDATE AD_USER
        SET LastContact=Cur_LastContact.Updated,
            LastResult=Cur_LastContact.DocumentNo
        WHERE AD_User_ID=Cur_LastContact.Ad_User_ID;
        EXIT;
      END LOOP;
      IF (v_IsSOTrx='Y') THEN
        -- Undo revenue and credit limit
        --The next lines (3) have been commented due to the issue 19198
        --UPDATE C_BPARTNER
        --SET ActualLifeTimeValue=ActualLifeTimeValue -(v_Multiplier *  C_Base_Convert(v_GrandTotal, v_Currency_ID, v_Client_ID, v_DateAcct, v_Org_ID))
        --WHERE C_BPartner_ID=v_BPartner_ID;
        FOR Cur_ReactivateInvoiceLine IN
          (SELECT C_InvoiceLine_ID, C_Orderline_ID, M_InoutLine_ID, QtyInvoiced
           FROM C_INVOICELINE
           WHERE C_Invoice_ID=v_Record_ID
          )
        LOOP
          IF (Cur_ReactivateInvoiceLine.C_OrderLine_ID IS NOT NULL) THEN
            SELECT MAX(C_INVOICE.DateInvoiced), COALESCE(sum(QtyInvoiced),0) 
	    INTO v_REDateInvoiced, v_invoiceline_qtysum
	    FROM C_INVOICE, C_INVOICELINE
	    WHERE C_INVOICE.C_Invoice_ID=C_INVOICELINE.C_INVOICE_ID
	    AND C_INVOICELINE.C_ORDERLINE_ID=Cur_ReactivateInvoiceLine.C_ORDERLINE_ID
	    and C_INVOICE.docstatus='CO'
	    AND C_INVOICE.C_INVOICE_ID <> v_Record_ID;
	    
	    UPDATE C_ORDERLINE
	    SET QtyInvoiced=v_invoiceline_qtysum, 
		DateInvoiced=v_REDateInvoiced,
		Updated=TO_DATE(NOW()),
		UpdatedBy=v_UpdatedBy
	    WHERE C_ORDERLINE.C_OrderLine_ID=Cur_ReactivateInvoiceLine.C_OrderLine_ID;
          END IF;
          IF (Cur_ReactivateInvoiceLine.M_InOutLine_ID IS NOT NULL) THEN
            SELECT m.DOCSTATUS INTO v_REInOutStatus
            FROM M_INOUT m, M_INOUTLINE ml
            WHERE M.M_InOut_ID=ml.M_InOut_ID
              AND ml.M_InOutLine_ID=Cur_ReactivateInvoiceLine.M_InOutLine_ID;
            IF (v_REInOutStatus<>'RE') THEN
              SELECT COALESCE(SUM(C_INVOICELINE.QTYINVOICED), 0) INTO v_REtotalQtyInvoiced
              FROM C_INVOICELINE, C_INVOICE
              WHERE C_INVOICE.C_Invoice_ID=C_INVOICELINE.C_Invoice_ID
                AND C_INVOICE.Processed='Y'
                AND C_INVOICELINE.M_InOutLine_ID=Cur_ReactivateInvoiceLine.M_InOutLine_ID;
              v_REtotalQtyInvoiced:=v_REtotalQtyInvoiced - Cur_ReactivateInvoiceLine.QtyInvoiced;
              SELECT MovementQty INTO v_REdeliveredQty
              FROM M_INOUTLINE
              WHERE M_InOutLine_ID=Cur_ReactivateInvoiceLine.M_InOutLine_ID;
              UPDATE M_INOUTLINE
              SET IsInvoiced=(
                     CASE v_REtotalQtyInvoiced
                        WHEN 0 THEN 'N'
                        ELSE 'Y'
                     END)
              WHERE M_InOutLine_ID=Cur_ReactivateInvoiceLine.M_InOutLine_ID;
            END IF;
          END IF;
        END LOOP;
      ELSE
        -- When re-activating an invoice, match invoice lines are removed (if not posted)
        SELECT COUNT(1) INTO v_count
        FROM FACT_ACCT
        WHERE AD_TABLE_ID = (SELECT AD_TABLE_ID 
                             FROM AD_TABLE
                             WHERE UPPER(TABLENAME) LIKE 'M_MATCHPO')
                                AND RECORD_ID IN (SELECT M_MATCHPO_ID
                                                  FROM M_MATCHPO MP, C_INVOICE I, C_INVOICELINE IL
                                                  WHERE I.C_INVOICE_ID=IL.C_INVOICE_ID
                                                    AND MP.C_INVOICELINE_ID=IL.C_INVOICELINE_ID
                                                    AND I.C_INVOICE_ID=v_Record_ID);
        IF (v_count>0) THEN
          RAISE EXCEPTION '%', '@PostedMatchPO@'; --OBTG:-20000--
        END IF;
        DELETE FROM M_MATCHPO
        WHERE C_InvoiceLine_ID IN (SELECT C_InvoiceLine_ID FROM C_INVOICELINE WHERE C_Invoice_ID=v_Record_ID);
      END IF;

	--ADDED by Ashutosh on 22 Aug for deleting transaction cost while reactivating
	PERFORM exfm_trxCost_insert(null,v_Record_ID);

	--Added by Asutosh on 26 Oct, for deleting inv line i.e. Round Off Account entry 
	---Get Purchase/Sales Rounding Off account from c_AcctSchema_default(General Ledger configuration)
	IF(v_IsSOTrx='Y')THEN
	 SELECT CGA.C_GLItem_id INTO v_Rounding_Account
		FROM C_Glitem_Acct CGA
		LEFT JOIN c_validCombination cvc ON cvc.c_validCombination_id=CGA.Glitem_Credit_Acct
		LEFT JOIN c_elementvalue ev ON ev.c_elementvalue_id=cvc.account_id
		WHERE CGA.Glitem_Credit_Acct=(select EM_Expur_S_Rounding_Acct  from C_AcctSchema_Default limit 1);
	 ELSE

	  SELECT  CGA.C_GLItem_id INTO v_Rounding_Account
		FROM C_Glitem_Acct CGA
		LEFT JOIN c_validCombination cvc ON cvc.c_validCombination_id=CGA.Glitem_Credit_Acct
		LEFT JOIN c_elementvalue ev ON ev.c_elementvalue_id=cvc.account_id
		WHERE CGA.Glitem_Credit_Acct=(select EM_Expur_P_Rounding_Acct  from C_AcctSchema_Default limit 1);
	
	END IF;--Ends IF(NEW.ISSoTrx='Y')THEN

      UPDATE C_INVOICE
      SET Processed='N',
          DocStatus='DR',
          DocAction='CO',Updated=TO_DATE(NOW()),
          UpdatedBy=v_UpdatedBy
      WHERE C_Invoice_Id=v_Record_ID;

	--Added by Asutosh on 26 Oct, for deleting inv line i.e. Round Off Account entry 
	delete from c_invoiceline where c_invoice_id=v_Record_ID and account_id=v_Rounding_Account;

	--Code Added On 31-July-2019 For Deleting TDS Entry From c_invoice_line

	For Cur_WithHoldingTax_Data IN
	(
	SELECT cwtx_tds_id, ad_org_id, c_invoice_id, c_glitem_id, tds_amount, cwtx_typeof_services_id, 
	       cwtx_tds_code_section_id, percentage, c_invoiceline_id, base_amount, 
	       invline_updated
	FROM   cwtx_tds WHERE c_invoice_id = v_Record_ID
	)
	LOOP
		DELETE FROM c_invoiceline WHERE account_id = Cur_WithHoldingTax_Data.c_glitem_id and c_invoice_id=v_Record_ID;
	END LOOP;	-- For Cur_WithHoldingTax_Data Ends



      --Delete automatically created records ...
      DELETE FROM C_CASHLINE
      WHERE ISGENERATED='Y'
        AND C_DEBT_PAYMENT_ID IN
          (SELECT C_DEBT_PAYMENT_ID
           FROM C_DEBT_PAYMENT
           WHERE C_INVOICE_ID=v_Record_ID)
             AND C_CASH_ID IN (SELECT C_CASH_ID FROM C_CASH WHERE PROCESSED='N');
      -- Updates the debt-payments of the cash, to make them not to point to the invoice
      UPDATE C_DEBT_PAYMENT
      SET C_INVOICE_ID=NULL
      WHERE C_Invoice_ID=v_Record_ID
        AND C_Order_ID IS NOT NULL;
      DELETE FROM C_DEBT_PAYMENT
      WHERE C_Invoice_ID=v_Record_ID
        AND COALESCE(IsAutomaticGenerated, 'Y')='Y'
        AND C_ORDER_ID IS NULL;
      UPDATE C_DEBT_PAYMENT
      SET IsValid='N',Updated=TO_DATE(NOW()),
          UpdatedBy=v_UpdatedBy
      WHERE C_Invoice_ID=v_Record_ID
        AND COALESCE(IsAutomaticGenerated, 'Y')='N'
        AND C_ORDER_ID IS NULL;
      IF (v_IsSOTrx='Y') THEN
        PERFORM C_BP_SOCREDITUSED_REFRESH(v_BPartner_ID) ;
      END IF;
      DELETE FROM C_INVOICELINE
      WHERE C_INVOICE_DISCOUNT_ID IS NOT NULL
        AND C_INVOICE_ID=v_Record_ID;
      END_PROCESSING:=TRUE;
    END IF;
  END IF;--END_PROCESSING
  -- Issue 20553. Problem with the order of the execution of the triggers.
  -- By updating the Invoice Line again, we can assure that the Invoice Line Tax
  -- Trigger had been executed before.
  UPDATE C_INVOICELINE
  SET UPDATED = TO_DATE(NOW())
  WHERE C_INVOICE_ID = v_Record_ID;
  IF (NOT FINISH_PROCESS AND NOT END_PROCESSING) THEN
    /**************************************************************************
     * Actions allowed: COmplete, APprove
     */
    IF (v_DocAction='AP' OR v_DocAction='CO') THEN
      -- Check the header belongs to a organization where transactions are posible and ready to use
      SELECT AD_Org.IsReady, Ad_OrgType.IsTransactionsAllowed
        INTO v_is_ready, v_is_tr_allow
      FROM C_INVOICE, AD_Org, AD_OrgType
      WHERE AD_Org.AD_Org_ID=C_INVOICE.AD_Org_ID
        AND AD_Org.AD_OrgType_ID=AD_OrgType.AD_OrgType_ID
        AND C_INVOICE.C_INVOICE_ID=v_Record_ID;
      IF (v_is_ready='N') THEN
        RAISE EXCEPTION '%', '@OrgHeaderNotReady@'; --OBTG:-20000--
      END IF;
      IF (v_is_tr_allow='N') THEN
        RAISE EXCEPTION '%', '@OrgHeaderNotTransAllowed@'; --OBTG:-20000--
      END IF;

      SELECT AD_ORG_CHK_DOCUMENTS('C_INVOICE', 'C_INVOICELINE', v_Record_ID, 'C_INVOICE_ID', 'C_INVOICE_ID') INTO v_is_included FROM dual;
      IF (v_is_included=-1) THEN
        RAISE EXCEPTION '%', '@LinesAndHeaderDifferentLEorBU@'; --OBTG:-20000--
      END IF;

      -- Check the period control is opened (only if it is legal entity with accounting)
      -- Gets the BU or LE of the document
      SELECT AD_GET_DOC_LE_BU('C_INVOICE', v_Record_ID, 'C_INVOICE_ID', 'LE') INTO v_org_bule_id FROM DUAL;
      SELECT AD_OrgType.IsAcctLegalEntity INTO v_isacctle
      FROM AD_OrgType, AD_Org
      WHERE AD_Org.AD_OrgType_ID = AD_OrgType.AD_OrgType_ID
        AND AD_Org.AD_Org_ID=v_org_bule_id;

      IF (v_isacctle='Y') THEN
        SELECT C_CHK_OPEN_PERIOD(v_Org_ID, v_DateAcct, NULL, v_DocTypeTarget_ID) INTO v_available_period FROM DUAL;
        IF (v_available_period<>1) THEN
          RAISE EXCEPTION '%', '@PeriodNotAvailable@'; --OBTG:-20000--
        END IF;
      END IF;

	--ADDED by Ashutosh on 11 Aug for inserting transaction cost 
	PERFORM exfm_trxCost_insert(null,v_Record_ID);
	
      SELECT COUNT(*) INTO v_count
      FROM C_INVOICE c, C_BPARTNER bp
      WHERE c.C_BPARTNER_ID=bp.C_BPARTNER_ID
        AND Ad_Isorgincluded(c.AD_ORG_ID, bp.AD_ORG_ID, bp.AD_CLIENT_ID)=-1
        AND c.C_Invoice_ID=v_Record_ID;
      IF (v_count>0) THEN
        RAISE EXCEPTION '%', '@NotCorrectOrgBpartnerInvoice@' ; --OBTG:-20000--
      END IF;
      WHILE(v_DocType_ID<>v_DocTypeTarget_ID)
      LOOP
        BEGIN
          v_ResultStr:='UpdateDocType';
          UPDATE C_INVOICE
          SET C_DocType_ID=C_DocTypeTarget_ID,
              Updated=TO_DATE(NOW()),
              UpdatedBy=v_UpdatedBy
          WHERE C_Invoice_ID=v_Record_ID;
          v_DocType_ID:=v_DocTypeTarget_ID;
        EXCEPTION
          WHEN OTHERS THEN
            v_ResultStr:='UpdateDocumentNo';
            UPDATE C_INVOICE
              SET DocumentNo=DocumentNo || '.'
            WHERE C_Invoice_ID=v_Record_ID;
        END;
      END LOOP;
    ELSE
      v_Message:='@ActionNotAllowedHere@ (I-' || v_DocAction || ')';
      RAISE EXCEPTION '%', v_Message ; --OBTG:-20000--
      END_PROCESSING:=TRUE;
    END IF;
  END IF;--FINISH_PROCESS
  IF (NOT FINISH_PROCESS AND NOT END_PROCESSING) THEN
    /**************************************************************************
     * Resolve not-stocked BOMs
     *************************************************************************/
   DECLARE
      -- Invoice Lines with non-stocked BOMs
      CUR_BOM_Line RECORD;
      --
    BEGIN
      v_ResultStr:='ResolveBOM';
      FOR CUR_BOM_Line IN
        (SELECT *
         FROM C_INVOICELINE l
         WHERE l.C_Invoice_ID=v_Record_ID
           AND l.IsActive='Y'
           AND l.explode='N'
           AND EXISTS
              (SELECT *
               FROM M_PRODUCT p
               WHERE l.M_Product_ID=p.M_Product_ID
                 AND p.IsBOM='Y'
                 AND p.IsStocked='N'
                 AND p.productType='I'
               )
         ORDER BY l.Line  FOR UPDATE
        )
      LOOP
        PERFORM M_INVEXPLODEBOMNOTSTOCK(null, CUR_BOM_Line.c_invoiceline_ID);
      END LOOP; -- BOM Loop
    END;
  END IF;--FINISH_PROCESS
  IF (NOT FINISH_PROCESS AND NOT END_PROCESSING) THEN
     /**************************************************************************
      * Calculate promotions                                                   
      *************************************************************************/
      IF (v_DocAction = 'CO') THEN
         PERFORM M_PROMOTION_CALCULATE('I', v_Record_ID, v_UpdatedBy);
      END IF;

    /**************************************************************************
     * Calculate Discounts
     *************************************************************************/
    v_CumDiscount:=0;
    v_OldCumDiscount:=0;
    v_Line:=10;
    SELECT MAX(LINE) INTO v_InvoiceLineSeqNo
    FROM C_INVOICELINE
    WHERE C_INVOICE_ID=v_Record_ID;
    SELECT PricePrecision INTO v_precision
    FROM C_INVOICE i, C_CURRENCY c
    WHERE i.C_INVOICE_ID = v_Record_ID AND i.C_CURRENCY_ID = c.C_CURRENCY_ID;
    FOR Cur_CInvoiceDiscount IN
      (SELECT C_INVOICE_DISCOUNT.C_INVOICE_DISCOUNT_ID, C_DISCOUNT.DISCOUNT, C_DISCOUNT.M_PRODUCT_ID, C_DISCOUNT.NAME,
           C_INVOICE_DISCOUNT.CASCADE, C_DISCOUNT.C_DISCOUNT_ID, M_PRODUCT.C_UOM_ID,
           REVPLANTYPE, ISDEFERREDREVENUE, PERIODNUMBER, DEFAULTPERIOD,
					EXPPLANTYPE, ISDEFERREDEXPENSE, PERIODNUMBER_EXP, DEFAULTPERIOD_EXP
       FROM C_INVOICE_DISCOUNT, C_DISCOUNT, M_PRODUCT
       WHERE C_INVOICE_DISCOUNT.C_DISCOUNT_ID=C_DISCOUNT.C_DISCOUNT_ID
         AND C_DISCOUNT.M_PRODUCT_ID=M_PRODUCT.M_PRODUCT_ID
         AND C_INVOICE_DISCOUNT.C_INVOICE_ID=v_Record_ID
         AND C_INVOICE_DISCOUNT.ISACTIVE='Y'
       ORDER BY C_INVOICE_DISCOUNT.LINE
      )
    LOOP
      v_CumDiscount:=(1-v_OldCumDiscount) * Cur_CInvoiceDiscount.Discount/100;
      v_OldCumDiscount:=v_OldCumDiscount + v_CumDiscount;
      FOR Cur_TaxDiscount IN
        (SELECT C_INVOICELINE.C_TAX_ID, SUM(C_INVOICELINE.LINENETAMT) AS LINENETAMT,
                SUM(C_INVOICELINE.LINE_GROSS_AMOUNT) AS LINEGROSSAMT
         FROM C_INVOICELINE
         WHERE C_INVOICE_ID=v_Record_ID
           AND C_INVOICELINE.LINENETAMT<>0
           AND C_INVOICE_DISCOUNT_ID IS NULL
         GROUP BY C_TAX_ID
        )
      LOOP
        IF (v_istaxincluded = 'Y') THEN
          IF (Cur_CInvoiceDiscount.CASCADE='Y') THEN
            v_line_gross_amount:=(-1) * Cur_TaxDiscount.LINEGROSSAMT * v_CumDiscount;
          ELSE
            v_line_gross_amount:=(-1) * Cur_TaxDiscount.LINEGROSSAMT * Cur_CInvoiceDiscount.Discount/100;
          END IF;
          v_Discount:= C_GET_NET_PRICE_FROM_GROSS(Cur_TaxDiscount.C_TAX_ID, v_line_gross_amount, 0, v_precision, 1);
          v_gross_unit_price:= v_line_gross_amount;
        ELSE
          IF (Cur_CInvoiceDiscount.CASCADE='Y') THEN
            v_Discount:=(-1) * Cur_TaxDiscount.LINENETAMT * v_CumDiscount;
          ELSE
            v_Discount:=(-1) * Cur_TaxDiscount.LINENETAMT * Cur_CInvoiceDiscount.Discount/100;
          END IF;
          v_gross_unit_price:= 0;
          v_line_gross_amount:= 0;
        END IF;
        IF(Cur_CInvoiceDiscount.M_PRODUCT_ID IS NOT NULL) THEN
					IF(v_IsSOTrx = 'Y') THEN
						v_period_inv:= c_get_default_period(v_Record_ID, Cur_CInvoiceDiscount.defaultperiod);
						IF(v_period_inv IS NOT NULL AND Cur_CInvoiceDiscount.isdeferredrevenue = 'Y') THEN
							v_isdeferred_inv := Cur_CInvoiceDiscount.isdeferredrevenue;
							v_defplantype_inv := Cur_CInvoiceDiscount.revplantype;
							v_periodnumber_inv := Cur_CInvoiceDiscount.periodnumber;
					  ELSE
					  	v_period_inv := NULL;
							v_isdeferred_inv := 'N';
							v_defplantype_inv := NULL;
							v_periodnumber_inv := NULL;
						END IF;
					ELSE
						v_period_inv:= c_get_default_period(v_Record_ID, Cur_CInvoiceDiscount.defaultperiod_exp);
						IF(v_period_inv IS NOT NULL AND Cur_CInvoiceDiscount.isdeferredexpense = 'Y') THEN
							v_isdeferred_inv := Cur_CInvoiceDiscount.isdeferredexpense;
							v_defplantype_inv := Cur_CInvoiceDiscount.expplantype;
							v_periodnumber_inv := Cur_CInvoiceDiscount.periodnumber_exp;
					  ELSE
					  	v_period_inv := NULL;
							v_isdeferred_inv := 'N';
							v_defplantype_inv := NULL;
							v_periodnumber_inv := NULL;
						END IF;
					END IF;
        END IF;        
        v_InvoiceLineSeqNo:=10 + v_InvoiceLineSeqNo;
        v_InvoiceLine:=get_uuid();
        INSERT INTO C_INVOICELINE
          (
           C_INVOICELINE_ID, AD_CLIENT_ID, AD_ORG_ID, ISACTIVE,
           CREATED, CREATEDBY, UPDATED, UPDATEDBY,
           C_INVOICE_ID, C_ORDERLINE_ID, M_INOUTLINE_ID, LINE,
           DESCRIPTION, M_PRODUCT_ID, QTYINVOICED, PRICELIST,
           PRICEACTUAL, PRICELIMIT, LINENETAMT, C_CHARGE_ID,
           CHARGEAMT, C_UOM_ID, C_TAX_ID, S_RESOURCEASSIGNMENT_ID,
           TAXAMT, M_ATTRIBUTESETINSTANCE_ID, ISDESCRIPTION,
           QUANTITYORDER, M_PRODUCT_UOM_ID, PRICESTD,
           GROSS_UNIT_PRICE, TAXBASEAMT, LINE_GROSS_AMOUNT,
           ISDEFERRED, DEFPLANTYPE, PERIODNUMBER, C_PERIOD_ID
          )
          VALUES
          (
           v_InvoiceLine, v_Client_ID, v_Org_ID, 'Y',
           TO_DATE(NOW()), v_UpdatedBy, TO_DATE(NOW()), v_UpdatedBy,
           v_Record_ID, NULL, NULL, v_InvoiceLineSeqNo,
           Cur_CInvoiceDiscount.NAME, Cur_CInvoiceDiscount.M_PRODUCT_ID, 1, v_Discount,
           v_Discount, v_Discount, v_Discount, NULL,
           0, Cur_CInvoiceDiscount.C_UOM_ID, Cur_TaxDiscount.C_TAX_ID, NULL,
           NULL, NULL, 'N' ,
           NULL, NULL, v_Discount,
           ROUND(v_gross_unit_price, v_precision), v_Discount  ,ROUND(v_line_gross_amount, v_precision),
           v_isdeferred_inv, v_defplantype_inv, v_periodnumber_inv, v_period_inv
          );
        --v_InvoiceDiscount:=Ad_Sequence_Nextno('C_InvoiceLine');
        UPDATE C_INVOICELINE
        SET C_INVOICE_DISCOUNT_ID=Cur_CInvoiceDiscount.C_INVOICE_DISCOUNT_ID
        WHERE C_INVOICELINE_ID=v_InvoiceLine;
      END LOOP;
      v_Line:=v_Line + 10;
    END LOOP;
  END IF;--FINISH_PROCESS
  IF (NOT FINISH_PROCESS AND NOT END_PROCESSING) THEN
    /**************************************************************************
     * Calculate Invoice Taxes and Totals
     *************************************************************************/
    DECLARE
      Cur_Tax RECORD;
      Cur_MultiTax RECORD;
      xTaxBaseAmt NUMERIC:=0;
      xTaxAmt NUMERIC:=0;
      v_taxnorecalculable NUMERIC:=0;
      v_PreviousTaxAmt NUMERIC:=0;
      HeaderNotAdded BOOLEAN:=TRUE;
      v_LineNo NUMERIC:=0;
      v_ActualBaseAmt NUMERIC;
      v_FirstLine BOOLEAN;
      v_C_InvoiceTax_ID VARCHAR(32); --OBTG:VARCHAR2--
      
    BEGIN
      v_ResultStr:='DeleteOldTaxes';
      DELETE FROM C_INVOICELINETAX
      WHERE C_InvoiceLine_ID IN (SELECT C_InvoiceLine_ID from C_InvoiceLine WHERE C_Invoice_ID = v_Record_ID);
      DELETE FROM C_INVOICETAX
      WHERE C_Invoice_ID=v_Record_ID
        AND Recalculate = 'Y';
      -- Update line if recalculate='N'
      FOR Cur_TaxMAct IN
        ( SELECT C_INVOICETAX_ID FROM C_INVOICETAX
          WHERE C_Invoice_ID=v_Record_ID
          AND Recalculate = 'N'
        )
      LOOP
        v_LineNo:=v_LineNo+10;
        UPDATE C_INVOICETAX SET line=v_LineNo WHERE C_INVOICETAX_ID=Cur_TaxMAct.C_INVOICETAX_ID;   
      END LOOP;
      -- For all Tax Rates
      v_ResultStr:='InsertNewTaxes';
      FOR Cur_Tax IN
        (SELECT l.C_InvoiceLine_ID, l.C_Tax_ID, i.IsTaxIncluded,
              COALESCE(SUM(l.LineNetAmt),0) + COALESCE(SUM(l.ChargeAmt), 0) AS LineNetAmt,
              COALESCE(SUM(l.TaxBaseAmt), 0) + COALESCE(SUM(l.ChargeAmt), 0) AS TaxBaseAmt,
              COALESCE(SUM(i.ChargeAmt), 0) AS HeaderNet,
              t.Rate, t.IsSummary, c.StdPrecision, t.Cascade, t.BaseAmount,
              l.line_gross_amount
         FROM C_INVOICE i, C_INVOICELINE l, C_TAX t, C_CURRENCY c
         WHERE i.C_Invoice_ID=l.C_Invoice_ID
           AND i.C_Invoice_ID=v_Record_ID -- Parameter
           AND l.C_Tax_ID=t.C_Tax_ID
           AND i.C_Currency_ID=c.C_Currency_ID
         GROUP BY l.C_InvoiceLine_ID, l.C_Tax_ID,i.IsTaxIncluded, t.Rate, t.IsSummary,
              c.StdPrecision, t.Cascade, t.BaseAmount, l.line_gross_amount
         ORDER BY 4 DESC
        )
      LOOP
        xTaxBaseAmt:=Cur_Tax.LineNetAmt;
        v_TotalLines:=v_TotalLines + xTaxBaseAmt; -- w/o Header Freight/Charge
        IF (HeaderNotAdded) THEN -- add header to first
          HeaderNotAdded:=FALSE;
          xTaxBaseAmt:=xTaxBaseAmt + Cur_Tax.HeaderNet;
        END IF;
        PERFORM C_INVOICELINETAX_INSERT(v_Org_ID, v_Record_ID, Cur_Tax.C_InvoiceLine_ID, v_UpdatedBy, Cur_Tax.C_Tax_ID, Cur_Tax.C_Tax_ID, Cur_Tax.LineNetAmt, Cur_Tax.TaxBaseAmt, Cur_Tax.StdPrecision);
        IF (v_istaxincluded = 'Y') THEN
          PERFORM C_INVOICELINETAX_ROUNDING(cur_tax.c_invoiceline_id, cur_tax.line_gross_amount, cur_tax.linenetamt);
        END IF;

      END LOOP; -- Insert New Taxes
      -- Update Header
      IF (v_IsSOTrx = 'N') THEN
        SELECT c_getwithholding(v_record_id) INTO withholdamount FROM dual;
      ELSE
        withholdamount:=0;
      END IF;

      IF (v_istaxincluded = 'Y') THEN
        SELECT COALESCE(SUM(TaxAmt),0) INTO v_TaxNoRecalculable
        FROM C_INVOICETAX
        WHERE C_Invoice_ID = v_Record_ID
          AND Recalculate = 'N';
        SELECT COALESCE(SUM(line_gross_amount), 0) INTO v_grandtotal
        FROM c_invoiceline
        WHERE c_invoice_id = v_record_id;
        v_grandtotal := v_grandtotal + v_taxnorecalculable;
      ELSE
        SELECT COALESCE(SUM(TAXAMT), 0) INTO v_GrandTotal
        FROM C_INVOICETAX
        WHERE C_INVOICE_ID = v_Record_ID;
        v_GrandTotal:=v_GrandTotal+ v_TotalLines;
      END IF;
      UPDATE C_INVOICE
      SET TotalLines=v_TotalLines,
          GrandTotal=v_GrandTotal,
          withholdingamount = withholdamount
      WHERE C_Invoice_ID=v_Record_ID;
      IF (v_istaxincluded = 'Y') THEN
        PERFORM C_INVOICETAX_ROUNDING(v_Record_ID, v_GrandTotal - v_taxnorecalculable, v_TotalLines);
      END IF;
      RAISE NOTICE '%','withholdingamount=' || withholdamount;
      RAISE NOTICE '%','GrandTotal=' || v_GrandTotal ;
    END; -- Calculate Tax and Totals
    -- Synchronize Client/Org Ownership
    v_ResultStr:='SyncOwnershipClient';
    UPDATE C_INVOICELINE
    SET AD_Client_ID=v_Client_ID
    WHERE C_Invoice_ID=v_Record_ID
      AND AD_Client_ID<>v_Client_ID;

  END IF;--FINISH_PROCESS
  IF (NOT FINISH_PROCESS AND NOT END_PROCESSING) THEN
    /**************************************************************************
     * Update BP Statistics
     *************************************************************************/
    v_ResultStr:='Updating BPartners';
    -- First Sale
    UPDATE C_BPARTNER
    SET FirstSale=v_DateAcct
    WHERE C_BPartner_ID=v_BPartner_ID
      AND FirstSale IS NULL;
    -- Last Contact, Result
    UPDATE AD_USER
    SET LastContact=TO_DATE(NOW()),
        LastResult=v_DocumentNo
    WHERE AD_User_ID=v_BPartner_User_ID;
    -- Update total revenue and credit limit
    -- It is reversed in C_Allocation_Trg
    --The next lines (5) have been commented due to the issue 19198
    --IF (v_IsSOTrx='Y') THEN
      --UPDATE C_BPARTNER
      --SET ActualLifeTimeValue=ActualLifeTimeValue +(v_Multiplier *  C_Base_Convert(v_GrandTotal, v_Currency_ID, v_Client_ID, v_DateAcct, v_Org_ID))
      --WHERE C_BPartner_ID=v_BPartner_ID;
    --END IF;
  END IF;--FINISH_PROCESS
  IF (NOT FINISH_PROCESS AND NOT END_PROCESSING) THEN
    /**************************************************************************
     * Matching
     *************************************************************************/
    v_ResultStr:='Matching';
    IF (v_IsSOTrx='N') THEN
      DECLARE
        -- Invoice-Receipt Match
        Cur_ILines_Receipt RECORD;
        -- Invoice-PO Match
        Cur_ILines_PO RECORD;
        v_Qty NUMERIC;
        v_MatchInv_ID VARCHAR(32) ; --OBTG:VARCHAR2--
        v_MatchPO_ID VARCHAR(32) ; --OBTG:VARCHAR2--
      BEGIN
        v_ResultStr:='MatchInv-Receipt';
        FOR Cur_ILines_Receipt IN
          (SELECT il.AD_Client_ID, il.AD_Org_ID, il.C_InvoiceLine_ID, ml.M_InOutLine_ID,
               ml.M_Product_ID, ml.MovementQty, il.QtyInvoiced, i.DateAcct
           FROM C_INVOICELINE il
                INNER JOIN M_INOUTLINE ml ON (il.M_InOutLine_ID=ml.M_InOutLine_ID)
                INNER JOIN M_INOUT m ON (ml.M_InOut_ID=m.M_InOut_ID)
                INNER JOIN C_INVOICE i ON(il.C_Invoice_ID=i.C_Invoice_ID)
           WHERE il.M_Product_ID=ml.M_Product_ID
             AND M.Processed = 'Y'
             AND il.C_Invoice_ID=v_Record_ID
           )
        LOOP
          IF (Cur_ILines_Receipt.M_INOUTLINE_ID IS NOT NULL) THEN
            SELECT COUNT(1) INTO v_Count
            FROM M_MATCHINV
            WHERE C_INVOICELINE_ID=Cur_ILines_Receipt.C_InvoiceLine_ID
              AND M_INOUTLINE_ID=Cur_ILines_Receipt.M_INOUTLINE_ID;
            IF (v_Count=0) THEN
              v_Qty:=Cur_ILines_Receipt.QtyInvoiced;
              v_MatchInv_ID := get_uuid();
              v_ResultStr:='InsertMatchInv ' || v_MatchInv_ID;
              RAISE NOTICE '%','  M_MatchInv_ID=' || v_MatchInv_ID || ' - ' || v_Qty ;
              INSERT INTO M_MATCHINV
                (
                 M_MatchInv_ID, AD_Client_ID, AD_Org_ID, IsActive,
                 Created, CreatedBy, Updated, UpdatedBy,
                 M_InOutLine_ID, C_InvoiceLine_ID, M_Product_ID, DateTrx,
                 Qty, Processing, Processed, Posted
                )
                VALUES
                (
                 v_MatchInv_ID, Cur_ILines_Receipt.AD_Client_ID, Cur_ILines_Receipt.AD_Org_ID, 'Y',
                 TO_DATE(NOW()), v_UpdatedBy, TO_DATE(NOW()), v_UpdatedBy,
                 Cur_ILines_Receipt.M_InOutLine_ID, Cur_ILines_Receipt.C_InvoiceLine_ID, Cur_ILines_Receipt.M_Product_ID, Cur_ILines_Receipt.DateAcct,
                 v_Qty, 'N', 'Y', 'N'
                );
            END IF;
          END IF;
        END LOOP;

        UPDATE m_transaction
        SET checkpricedifference = 'Y'
        WHERE m_transaction_id in (
        SELECT TRX.M_TRANSACTION_ID 
        FROM C_INVOICELINE IL 
          JOIN M_MATCHINV MI ON IL.C_INVOICELINE_ID = MI.C_INVOICELINE_ID
          JOIN M_TRANSACTION TRX ON MI.M_INOUTLINE_ID = TRX.M_INOUTLINE_ID
        WHERE IL.C_INVOICE_ID = v_record_id);

        v_ResultStr:='MatchInv-PO';
        FOR Cur_ILines_PO IN
          (SELECT il.AD_Client_ID, il.AD_Org_ID, il.C_InvoiceLine_ID, ol.C_OrderLine_ID,
               ol.M_Product_ID, ol.C_Charge_ID, ol.QtyOrdered, il.QtyInvoiced,
                i.DateAcct
           FROM C_INVOICELINE il
                INNER JOIN C_ORDERLINE ol ON (il.C_OrderLine_ID=ol.C_OrderLine_ID)
                INNER JOIN C_INVOICE i ON (il.C_Invoice_ID=i.C_Invoice_ID)
           WHERE (il.M_Product_ID=ol.M_Product_ID
                  OR il.C_Charge_ID=ol.C_Charge_ID)
             AND il.C_Invoice_ID=v_Record_ID
          )
        LOOP
          -- The min qty. Modified by Ismael Ciordia
          --v_Qty := Cur_ILines_PO.QtyOrdered;
          --IF (ABS(Cur_ILines_PO.QtyOrdered) > ABS(Cur_ILines_PO.QtyInvoiced)) THEN
          v_Qty:=Cur_ILines_PO.QtyInvoiced;
          --END IF;
          v_MatchPO_ID := get_uuid();
          v_ResultStr:='InsertMatchPO ' || v_MatchPO_ID;
          RAISE NOTICE '%','  M_MatchPO_ID=' || v_MatchPO_ID || ' - ' || v_Qty ;
          INSERT INTO M_MATCHPO
            (
             M_MatchPO_ID, AD_Client_ID, AD_Org_ID, IsActive,
             Created, CreatedBy, Updated, UpdatedBy,
             C_OrderLine_ID, M_InOutLine_ID, C_InvoiceLine_ID, M_Product_ID,
             DateTrx, Qty, Processing, Processed,
             Posted
            )
            VALUES
            (
             v_MatchPO_ID, Cur_ILines_PO.AD_Client_ID, Cur_ILines_PO.AD_Org_ID, 'Y',
             TO_DATE(NOW()), v_UpdatedBy, TO_DATE(NOW()), v_UpdatedBy,
             Cur_ILines_PO.C_OrderLine_ID, NULL, Cur_ILines_PO.C_InvoiceLine_ID, Cur_ILines_PO.M_Product_ID,
             Cur_ILines_PO.DateAcct, v_Qty, 'N', 'Y',
             'N'
            );
        END LOOP;
      END;
    ELSE -- Actualiza las cantidades facturadas de los pedidos de venta, y las lineas de albaryn facturadas
      DECLARE
        CurLines RECORD;
        p_DateInvoiced TIMESTAMP;
        v_totalQtyInvoiced NUMERIC;
        v_ODocumentNo C_ORDER.DocumentNo%TYPE;
        v_NewPendingToInvoice NUMERIC;
        v_deliveredQty NUMERIC;
        v_inOutStatus VARCHAR(60) ; --OBTG:varchar2--
      BEGIN
        SELECT DateInvoiced
        INTO p_DateInvoiced
        FROM C_INVOICE
        WHERE C_Invoice_ID=v_Record_ID;
        FOR CurLines IN
          (SELECT * FROM C_INVOICELINE  WHERE C_INVOICE_ID=v_Record_ID  ORDER BY line)
        LOOP
          IF (CurLines.C_OrderLine_ID IS NOT NULL) THEN
            --Check that qty pending to invoice is higher or equal to the qty being invoiced
            SELECT o.documentno, ABS(ol.qtyordered) - ABS(ol.qtyinvoiced + CurLines.QtyInvoiced), p.isquantityvariable
              INTO v_ODocumentNo, v_NewPendingToInvoice, v_Isquantityvariable
            FROM c_order o, c_orderline ol
            LEFT JOIN m_product p ON p.m_product_id = ol.m_product_id
            WHERE o.c_order_id = ol.c_order_id
              AND ol.c_orderline_id = CurLines.c_orderline_id
		and p.producttype = 'I';
            IF (v_Isquantityvariable <> 'Y' AND v_NewPendingToInvoice <0) THEN
              v_Message := '@NotPossibleCompleteInvoice@' || ' ' || v_DocumentNo;
              v_Message := v_Message || ' ' || '@line@' || ' ' || CurLines.line || '. ';
              v_Message := v_Message || '@OrderDocumentno@' || ' ' || v_ODocumentNo;
              v_Message := v_Message || ': ' || '@QtyInvoicedHigherOrdered@' || '.';
              RAISE EXCEPTION '%', v_Message; --OBTG:-20000--
            END IF;
            UPDATE C_ORDERLINE
            SET QtyInvoiced=QtyInvoiced + CurLines.QtyInvoiced,
                DateInvoiced=p_DateInvoiced,
                Updated=TO_DATE(NOW()),
                UpdatedBy=v_UpdatedBy
            WHERE C_OrderLine_ID=CurLines.C_OrderLine_ID and priceactual > 0;
          END IF;
          IF (CurLines.M_InOutLine_ID IS NOT NULL) THEN
            SELECT m.DOCSTATUS INTO v_inOutStatus
            FROM M_INOUT m, M_INOUTLINE ml
            WHERE M.M_InOut_ID=ml.M_InOut_ID
              AND ml.M_InOutLine_ID=CurLines.M_InOutLine_ID;
            IF (v_inOutStatus<>'RE') THEN
              SELECT COALESCE(SUM(C_INVOICELINE.QTYINVOICED), 0) INTO v_totalQtyInvoiced
              FROM C_INVOICELINE, C_INVOICE
              WHERE C_INVOICE.C_Invoice_ID=C_INVOICELINE.C_Invoice_ID
                AND C_INVOICE.Processed='Y'
                AND C_INVOICELINE.M_InOutLine_ID=CurLines.M_InOutLine_ID;
              v_totalQtyInvoiced:=v_totalQtyInvoiced + CurLines.QtyInvoiced;
              SELECT MovementQty INTO v_deliveredQty
              FROM M_INOUTLINE
              WHERE M_InOutLine_ID=CurLines.M_InOutLine_ID;
              UPDATE M_INOUTLINE
              SET IsInvoiced=(
                    CASE v_totalQtyInvoiced
                      WHEN 0 THEN 'N'
                      ELSE 'Y'
                    END)
              WHERE M_InOutLine_ID=CurLines.M_InOutLine_ID;
            END IF;
          END IF;
        END LOOP;
      END;
    END IF;
  END IF;--FINISH_PROCESS
  IF (NOT FINISH_PROCESS AND NOT END_PROCESSING) THEN
    -- Modified by Ismael Ciordia
    -- Generate C_Debt_Payment linked to this invoice
    DECLARE
      v_totalCash NUMERIC:=0;
      v_processed CHAR(1):='N';
      v_debtPaymentID VARCHAR(32) ; --OBTG:varchar2--
      v_amount NUMERIC;
      v_cashBook VARCHAR(32) ; --OBTG:VARCHAR2--
      v_bankAccount VARCHAR(32) ; --OBTG:VARCHAR2--
      v_cash VARCHAR(32) ; --OBTG:VARCHAR2--
      v_IsoCode C_CURRENCY.ISO_CODE%TYPE;
      v_CashLine VARCHAR(32) ; --OBTG:VARCHAR2--
      v_line NUMERIC ;
      v_BPartnerName C_BPARTNER.NAME%TYPE;
      v_GenDP_Org VARCHAR(32); --OBTG:VARCHAR2--
      v_dummy VARCHAR(2000); --OBTG:VARCHAR2--
    BEGIN
      SELECT COUNT(1) INTO v_count
      FROM ad_preference
      WHERE property = 'FinancialManagement'
        AND ad_module_id <> '0';
      IF (v_count > 1) THEN
        v_dummy := AD_GET_PREFERENCE_VALUE('FinancialManagement', 'Y', v_client_id, v_org_id, NULL, NULL, NULL);
      ELSIF (v_count = 0) THEN
        v_ResultStr:='Generating C_Debt_Payment';
        UPDATE C_DEBT_PAYMENT
          SET C_INVOICE_ID=v_Record_ID
        WHERE EXISTS
              (SELECT 1
               FROM C_ORDERLINE ol, C_INVOICELINE il
               WHERE ol.C_ORDERLINE_ID=il.C_ORDERLINE_ID
                 AND il.C_INVOICE_ID=v_Record_ID
                 AND ol.C_ORDER_ID=C_DEBT_PAYMENT.C_ORDER_ID
              )
          AND C_INVOICE_ID IS NULL;
        UPDATE C_DEBT_PAYMENT
          SET IsValid='Y'
        WHERE C_INVOICE_ID=v_Record_ID
          AND IsValid!='Y';

        -- Is it a Credit Memo:4
        SELECT DocBaseType, isreversal INTO v_TargetDocBaseType, v_isReversal
        FROM C_DOCTYPE
        WHERE C_DocType_ID=v_DocTypeTarget_ID;
        IF (v_TargetDocBaseType in ('ARC','APC') or v_isReversal='Y') THEN
          v_MultiplierARC:=-1;
        END IF;

        --Sums debt payments from the order and the ones that have been inserted manually, added by ALO
        SELECT COALESCE(SUM(C_Currency_Round(C_Currency_Convert((Amount + WriteOffAmt)*v_MultiplierARC, C_Currency_ID, v_Currency_ID, v_DateInvoiced, NULL, v_Client_ID, v_Org_ID), v_Currency_ID, NULL)), 0) INTO v_totalCash
        FROM C_DEBT_PAYMENT_V dp
        WHERE C_INVOICE_ID=v_Record_ID;
        --Insert C_Debt_Payment if GrandTotal - v_totalCash <> 0;
        IF (v_GrandTotal<>v_totalCash) THEN
          DECLARE
            CUR_PAYMENTS RECORD;
            v_plannedDate TIMESTAMP;
            v_pendingAmount NUMERIC;
            v_paymentAmount NUMERIC;
            v_GenDebt_PaymentID VARCHAR(32); --OBTG:varchar2--
            v_SettlementDocTypeID VARCHAR(32) ; --OBTG:varchar2--
            v_settlement_ID VARCHAR(32) ; --OBTG:VARCHAR2--
            v_CB_Curr VARCHAR(32) ; --OBTG:VARCHAR2--
            v_SDocument_No C_SETTLEMENT.DocumentNo%TYPE;
          BEGIN
            IF (v_IsSOTrx ='Y') THEN
              v_pendingAmount:=v_GrandTotal - v_totalCash;
            ELSE
              v_pendingAmount:=v_GrandTotal + v_totalCash;
            END IF;
            FOR CUR_PAYMENTS IN
              (SELECT LINE, PERCENTAGE, ONREMAINDER, EXCLUDETAX,
                   COALESCE(PAYMENTRULE, v_PaymentRule) AS PAYMENTRULE, FIXMONTHDAY, FIXMONTHDAY2, FIXMONTHDAY3,
                   NETDAYS, FIXMONTHOFFSET, NETDAY, ISNEXTBUSINESSDAY
               FROM C_PAYMENTTERMLINE
               WHERE C_PAYMENTTERM_ID=v_PaymentTerm
               UNION
               -- Header of paymentTerm is processed at last
               SELECT 9999 AS LINE, 100 AS PERCENTAGE, 'Y' AS ONREMAINDER, 'N' AS EXCLUDETAX,
                   v_PaymentRule AS PAYMENTRULE, FIXMONTHDAY, FIXMONTHDAY2, FIXMONTHDAY3,
                   NETDAYS, FIXMONTHOFFSET, NETDAY, ISNEXTBUSINESSDAY
               FROM C_PAYMENTTERM
               WHERE C_PAYMENTTERM_ID=v_PaymentTerm
               ORDER BY LINE
              )
            LOOP
              IF (CUR_PAYMENTS.PaymentRule IN('B', 'C')) THEN
                SELECT MAX(C_CashBook_ID) INTO v_cashBook
                FROM C_CASHBOOK
                WHERE AD_Client_ID=v_Client_ID
                  AND isActive='Y'
                  AND isDefault='Y'
                  AND AD_IsOrgIncluded(v_org_id,AD_ORG_ID, AD_Client_ID)<>-1;
                IF (v_cashBook IS NULL) THEN
                  RAISE EXCEPTION '%', '@NoDefaultCashBook@'; --OBTG:-20000--
                END IF;
                v_bankAccount:=NULL;
              ELSE
                SELECT COALESCE((
                         CASE v_IsSOTrx
                           WHEN 'Y' THEN SO_BankAccount_ID
                           ELSE PO_BankAccount_ID
                         END
                         ),
                         (SELECT MAX(C_BankAccount_ID)
                          FROM C_BANKACCOUNT
                          WHERE AD_Client_ID=v_Client_ID
                            AND isDefault='Y'
                         )
                       ) INTO v_bankAccount
                FROM C_BPARTNER
                WHERE c_BPartner_ID=v_BPartner_ID;
                v_cashBook:=NULL;
              END IF;
              v_plannedDate:=C_Paymentduedate(v_BPartner_ID, v_IsSOTrx, CUR_PAYMENTS.FixMonthDay, CUR_PAYMENTS.FixMonthDay2, CUR_PAYMENTS.FixMonthDay3, CUR_PAYMENTS.NetDays, CUR_PAYMENTS.FixMonthOffset, CUR_PAYMENTS.NetDay, CUR_PAYMENTS.IsNextbusinessday, v_DateInvoiced) ;
              SELECT COALESCE(SUM(C_DEBT_PAYMENT_V.AMOUNT),0) INTO v_partialAmount
              FROM C_DEBT_PAYMENT_V, C_DEBT_PAYMENT
              WHERE C_DEBT_PAYMENT_V.C_INVOICE_ID = V_RECORD_ID
                AND C_DEBT_PAYMENT_V.C_DEBT_PAYMENT_ID = C_DEBT_PAYMENT.C_DEBT_PAYMENT_ID
                AND ISAUTOMATICGENERATED='N';
              IF (CUR_PAYMENTS.EXCLUDETAX='Y') THEN
                -- if excludeTax = 'Y', percentage is aplied on the TotalLines
                v_paymentAmount:=C_Currency_Round((v_TotalLines-v_partialAmount) *CUR_PAYMENTS.PERCENTAGE/100, v_Currency_ID, NULL) ;
              ELSIF (CUR_PAYMENTS.ONREMAINDER='N') THEN
                -- if onRemainder = 'N', percentage is aplied on the GrandTotal
                v_paymentAmount:=C_Currency_Round((v_GrandTotal-v_partialAmount) *CUR_PAYMENTS.PERCENTAGE/100, v_Currency_ID, NULL) ;
              ELSE
                v_paymentAmount:=C_Currency_Round((v_pendingAmount) *CUR_PAYMENTS.PERCENTAGE/100, v_Currency_ID, NULL) ;
              END IF;
              v_pendingAmount:=v_pendingAmount - v_paymentAmount;
              v_debtPaymentID :=get_uuid() ;
              v_paymentcheck:=C_Currency_Round((v_paymentamount *v_multiplierarc) -withholdamount *(v_paymentamount *v_multiplierarc / v_grandtotal), v_Currency_ID, NULL);
              IF (v_paymentcheck <> 0) THEN
                INSERT INTO C_DEBT_PAYMENT
                  (
                   C_DEBT_PAYMENT_ID, AD_CLIENT_ID, AD_ORG_ID, ISACTIVE,
                   CREATED, CREATEDBY, UPDATED, UPDATEDBY,
                   ISRECEIPT, C_SETTLEMENT_CANCEL_ID, C_SETTLEMENT_GENERATE_ID, DESCRIPTION,
                   C_INVOICE_ID, C_BPARTNER_ID, C_CURRENCY_ID, C_CASHLINE_ID,
                   C_BANKACCOUNT_ID, C_CASHBOOK_ID, PAYMENTRULE, ISPAID,
                   AMOUNT, WRITEOFFAMT, DATEPLANNED, ISMANUAL,
                   ISVALID, C_BANKSTATEMENTLINE_ID, CHANGESETTLEMENTCANCEL, CANCEL_PROCESSED,
                   GENERATE_PROCESSED, c_project_id, status, status_initial,   withholdingamount,C_WITHHOLDING_ID
                  )
                  VALUES
                  (
                   v_debtPaymentID, v_Client_ID, v_Org_ID, 'Y',
                   TO_DATE(NOW()), v_UpdatedBy, TO_DATE(NOW()), v_UpdatedBy,
                   v_IsSOTrx, NULL, NULL, '* ' || v_DocumentNo || ' * (' || COALESCE(TO_CHAR(v_BPartnerName) ,'') ||( CASE WHEN v_POReference IS NULL THEN '' ELSE ' .Ref:'||TO_CHAR(v_POReference) END) || ' )',
                   v_Record_ID, v_BPartner_ID, v_Currency_ID, NULL,
                   v_bankAccount, v_cashBook, CUR_PAYMENTS.PaymentRule, 'N',
                   C_Currency_Round((v_paymentamount *v_multiplierarc) -withholdamount *(v_paymentamount *v_multiplierarc / v_grandtotal), v_Currency_ID, NULL), 0, v_plannedDate, 'N',
                   'Y', NULL, 'N', 'N',
                   'N', v_C_Project_Id, 'DE', 'DE', C_Currency_Round(withholdamount *(v_paymentamount *v_multiplierarc / v_grandtotal), v_Currency_ID, NULL),cWithHoldId
                  );
              END IF;
              --AL
              --Looking for autogenerated debt-payments
              SELECT MAX(c_Debt_Payment_Id), MAX(ad_Org_ID)
                INTO v_GenDebt_PaymentID, v_GenDP_Org
              FROM C_DEBT_PAYMENT DP
              WHERE C_BPartner_ID=v_BPartner_ID
                AND C_Debt_Payment_Status(C_Settlement_Cancel_ID, Cancel_Processed, Generate_Processed, IsPaid, IsValid, C_Cashline_ID, C_BankstatementLine_ID)='P'
                AND ISRECEIPT=v_IsSOTrx
                AND (-1) *Amount=v_paymentAmount
                AND c_currency_ID=v_Currency_ID
                AND C_SETTLEMENT_GENERATE_ID IS NOT NULL
                AND Ad_Isorgincluded(v_Org_id, dp.ad_org_id,v_Client_ID) != -1
                AND ad_client_id = v_Client_ID
                AND EXISTS (SELECT 1
                            FROM C_SETTLEMENT S
                            WHERE DP.C_SETTLEMENT_GENERATE_ID = S.C_Settlement_ID
                              AND IsGenerated = 'Y')
                AND NOT EXISTS (SELECT 1
                                FROM C_REMITTANCELINE rl
                                WHERE rl.C_DEBT_PAYMENT_CANCELLED = DP.C_DEBT_PAYMENT_ID);
  
              IF (v_GenDebt_PaymentID IS NOT NULL) THEN
                v_SettlementDocTypeID:=Ad_Get_Doctype(v_Client_ID, v_GenDP_Org, TO_CHAR('STT')) ;
                v_settlement_ID := get_uuid();
                SELECT * INTO  v_SDocument_No FROM Ad_Sequence_Doctype(v_SettlementDocTypeID, v_Record_ID, 'Y') ;
                IF (v_SDocument_No IS NULL) THEN
                  SELECT * INTO  v_SDocument_No FROM Ad_Sequence_Doc('DocumentNo_C_Settlement', v_Client_ID, 'Y') ;
                END IF;
                INSERT INTO C_SETTLEMENT
                  (
                   C_SETTLEMENT_ID, AD_CLIENT_ID, AD_ORG_ID, ISACTIVE,
                   CREATED, CREATEDBY, UPDATED, UPDATEDBY,
                   DOCUMENTNO, DATETRX, DATEACCT, SETTLEMENTTYPE,
                   C_DOCTYPE_ID, PROCESSING, PROCESSED, POSTED,
                   C_CURRENCY_ID, ISGENERATED
                  )
                   /*, C_PROJECT_ID, C_CAMPAIGN_ID,
                   C_ACTIVITY_ID, USER1_ID, USER2_ID, CREATEFROM)*/
                  VALUES
                  (
                   v_Settlement_ID, v_Client_ID, v_GenDP_Org, 'Y',
                   TO_DATE(NOW()), v_UpdatedBy, TO_DATE(NOW()), v_UpdatedBy,
                   '*C*'||v_SDocument_No, TRUNC(TO_DATE(NOW())), TRUNC(TO_DATE(NOW())), 'C',
                   v_SettlementDocTypeID, 'N', 'N', 'N',
                   v_Currency_ID, 'Y'
                  );
                UPDATE C_DEBT_PAYMENT
                SET C_Settlement_Cancel_Id=v_Settlement_ID,
                    Updated=TO_DATE(NOW()),
                    UpdatedBy=v_UpdatedBy
                WHERE c_Debt_Payment_ID IN(v_genDebt_PaymentID, v_debtPaymentID) ;
                PERFORM C_SETTLEMENT_POST(NULL, v_Settlement_ID) ;
              END IF;
              --If Invoice.paymentRule = 'B', insert de cashline de tipo efecto apuntando al efecto
              IF (v_cashBook IS NOT NULL AND CUR_PAYMENTS.PaymentRule='B') THEN
                SELECT MAX(C.C_CASH_ID) INTO v_Cash
                FROM C_CASH C
                WHERE C.C_CASHBOOK_ID=v_cashBook
                  AND TRUNC(C.DATEACCT)=TRUNC(v_DateAcct)
                  AND C.PROCESSED='N';
  
                SELECT C_CURRENCY_ID INTO v_CB_Curr
                FROM C_CASHBOOK
                WHERE C_CASHBOOK_ID = v_cashBook;
  
                IF (v_Cash IS NULL) THEN
                  v_ResultStr:='Creating C_Cash';
                  SELECT ISO_CODE INTO v_IsoCode
                  FROM C_CURRENCY
                  WHERE C_Currency_ID=v_CB_Curr;
                  v_Cash :=get_uuid();
                  INSERT INTO C_CASH (
                      C_Cash_ID, AD_Client_ID, AD_Org_ID, IsActive,
                      Created, CreatedBy, Updated, UpdatedBy,
                      C_CashBook_ID, NAME, StatementDate, DateAcct,
                      BeginningBalance, EndingBalance, StatementDifference, Processing,
                      Processed, Posted )
                    VALUES (
                      v_Cash, v_Client_ID, v_Org_ID, 'Y',
                      TO_DATE(NOW()), v_UpdatedBy, TO_DATE(NOW()), v_UpdatedBy,
                      v_cashBook, (TO_CHAR(v_DateAcct, 'YYYY-MM-DD') || ' ' || v_IsoCode), v_DateAcct, v_DateAcct,
                      0, 0, 0, 'N',
                      'N', 'N');
                END IF; -- v_Cash IS NULL
                v_ResultStr:='Creating C_CashLine';
                v_CashLine := get_uuid();
                SELECT COALESCE(MAX(LINE), 0) + 10 INTO v_line
                FROM C_CASHLINE
                WHERE C_CASH_ID=v_Cash;
  
                SELECT SUM(AMOUNT) INTO v_Amount
                FROM C_DEBT_PAYMENT_V
                WHERE C_INVOICE_ID = v_Record_ID;
  
                INSERT INTO C_CASHLINE
                  (
                    C_CashLine_ID, AD_Client_ID, AD_Org_ID, IsActive,
                    Created, CreatedBy, Updated, UpdatedBy,
                    C_Cash_ID, C_Debt_Payment_ID, Line, Description,
                    Amount, CashType, C_Currency_ID, DiscountAmt,
                    WriteOffAmt, IsGenerated
                  )
                  VALUES
                  (
                    v_CashLine, v_Client_ID, v_Org_ID, 'Y',
                    TO_DATE(TO_DATE(NOW())), v_UpdatedBy, TO_DATE(TO_DATE(NOW())), v_UpdatedBy,
                    v_Cash, v_debtPaymentID, v_line, v_BPartnerName,
                    v_Amount, 'P', v_Currency_ID, 0,
                    0, 'Y'
                  );
  
              END IF; -- v_cashBook IS NOT NULL
            END LOOP;
          END;
        END IF; -- v_GrandTotal <> v_totalCash
      END IF;
    END;
    IF (NOT FINISH_PROCESS AND v_IsSOTrx='Y') THEN
      PERFORM C_BP_SOCREDITUSED_REFRESH(v_BPartner_ID) ;
    END IF;
  END IF;--FINISH_PROCESS
  IF (NOT FINISH_PROCESS AND NOT END_PROCESSING) THEN
    -- Finish up -------------------------------------------------------------
    UPDATE C_INVOICE
    SET DocStatus='CO',
        Processed='Y',
        DocAction='RE',
        Updated=TO_DATE(NOW()),
        UpdatedBy=v_UpdatedBy
    WHERE C_Invoice_ID=v_Record_ID;
  END IF;--FINISH_PROCESS
  IF (NOT FINISH_PROCESS) THEN
    -- End Processing --------------------------------------------------------
    ---- <<END_PROCESSING>>
    v_ResultStr:='UnLockingInvoice';
    UPDATE C_INVOICE
    SET Processing='N',
        Updated=TO_DATE(NOW()),
        UpdatedBy=v_UpdatedBy
    WHERE C_Invoice_ID=v_Record_ID;
    -- Commented by cromero 19102006 IF (p_PInstance_ID IS NOT NULL) THEN
    -- Commented by cromero 19102006   -- COMMIT;
    -- Commented by cromero 19102006 END IF;
  END IF;--FINISH_PROCESS

  --C_Invoice_Post - Finish_Process Extension Point
  SELECT count(*) INTO v_count FROM DUAL
  WHERE EXISTS (SELECT 1 FROM ad_ep_procedures WHERE ad_extension_points_id = 'CBE7DD2E561E4D3D8257ECEA5F19687F');
  IF (v_count=1) THEN
    DECLARE
      v_ep_instance VARCHAR(32); --OBTG:VARCHAR2--
      v_extension_point_id VARCHAR(32) := 'CBE7DD2E561E4D3D8257ECEA5F19687F'; --OBTG:VARCHAR2--
    BEGIN
      v_ep_instance := get_uuid();
      PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'Record_ID', v_record_id, NULL, NULL, NULL, NULL, NULL, NULL);
      PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'DocAction', v_DocAction, NULL, NULL, NULL, NULL, NULL, NULL);
      PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'User', v_UpdatedBy, NULL, NULL, NULL, NULL, NULL, NULL);
      PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'Message', NULL, NULL, NULL, NULL, NULL, NULL, v_Message);
      PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'Result', NULL, NULL, v_result, NULL, NULL, NULL, NULL);
      PERFORM AD_EXTENSION_POINT_HANDLER(v_ep_instance, v_extension_point_id);
      SELECT p_number INTO v_Result
      FROM ad_ep_instance_para
      WHERE ad_ep_instance_id = v_ep_instance
        AND parametername LIKE 'Result';
      SELECT p_text INTO v_Message
      FROM ad_ep_instance_para
      WHERE ad_ep_instance_id = v_ep_instance
        AND parametername LIKE 'Message';

      DELETE FROM ad_ep_instance_para
      WHERE ad_ep_instance_id = v_ep_instance;
    END;
  END IF;

	FOR Cur_lineqty IN
      (SELECT C_INVOICELINE.qtyInvoiced
       FROM C_INVOICELINE
       WHERE C_Invoice_ID = v_Record_ID
      )
    LOOP
    IF(Cur_lineqty.qtyInvoiced <> 0) THEN
      v_totalqty := v_totalqty + 1;
     END IF;
    END LOOP;
  ---- <<FINISH_PROCESS>>
  IF (p_PInstance_ID IS NOT NULL) THEN
    --  Update AD_PInstance
    RAISE NOTICE '%','Updating PInstance - Finished - ' || v_Message ;
   
    IF(v_totalqty = 0 AND v_DocAction <> 'RE') THEN
      SELECT COUNT(1)
      INTO v_hasTaxes
      FROM DUAL
      WHERE EXISTS (SELECT 1
                    FROM C_INVOICETAX
                    WHERE C_Invoice_ID = v_Record_ID);
      IF(v_hasTaxes=0) THEN
	      v_Message := v_Message || '@NoAccountingEntryInvoice@';
	    END IF;
    END IF;
    PERFORM AD_UPDATE_PINSTANCE(p_PInstance_ID, v_UpdatedBy, 'N', v_Result, v_Message) ;
  ELSE
    RAISE NOTICE '%','--<<C_Invoive_Post finished>> ' || v_Message ;
  END IF;
  RETURN;
END; --BODY
EXCEPTION
WHEN OTHERS THEN
  RAISE NOTICE '%',v_ResultStr ;
     v_ResultStr:= '@ERROR=' || SQLERRM;
      RAISE NOTICE '%',v_ResultStr ;
      IF (p_PInstance_ID IS NOT NULL) THEN
        -- ROLLBACK;
        PERFORM AD_UPDATE_PINSTANCE(p_PInstance_ID, NULL, 'N', 0, v_ResultStr) ;
      ELSE
        RAISE EXCEPTION '%', SQLERRM;
      END IF;
  -- Commented by cromero 19102006 RETURN;
END ; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION c_invoice_post(character varying, character varying)
  OWNER TO tad;
/******* C_Invoice_Post Stored Procedure Changes Ends **************/


-- DROP FUNCTION c_invoicelinetax_trg();

CREATE OR REPLACE FUNCTION c_invoicelinetax_trg()
  RETURNS trigger AS
$BODY$ DECLARE 

/*************************************************************************
  * The contents of this file are subject to the Compiere Public
  * License 1.1 ("License"); You may not use this file except in
  * compliance with the License. You may obtain a copy of the License in
  * the legal folder of your Openbravo installation.
  * Software distributed under the License is distributed on an
  * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing rights
  * and limitations under the License.
  * The Original Code is  Compiere  ERP  Solution
  * The Initial Developer of the Original Code is Jorg Janke and ComPiere, Inc.
  * Portions created by Jorg Janke are Copyright (C) 1999-2001 Jorg Janke,
  * parts created by ComPiere are Copyright (C) ComPiere, Inc.;
  * All Rights Reserved.
  * Contributor(s): Openbravo SLU
  * Contributions are Copyright (C) 2010-2012 Openbravo, S.L.U.
  *
  * Specifically, this derivative work is based upon the following Compiere
  * file and version.
  *************************************************************************/

v_Count NUMERIC;
v_LineNo  NUMERIC;
v_C_Invoice_ID C_INVOICELINETAX.C_INVOICE_ID%TYPE;
v_C_Tax_ID C_INVOICELINETAX.C_TAX_ID%TYPE;
v_c_invoicetax_id C_INVOICETAX.C_INVOICETAX_ID%TYPE;
v_Prec C_CURRENCY.STDPRECISION%TYPE;
v_DocTaxAmount C_TAX.DOCTAXAMOUNT%TYPE;
v_Rate  C_TAX.RATE%TYPE;
v_Processed   VARCHAR(60);
v_Increment_Amount C_ORDERTAX.TAXAMT%TYPE ;
v_Increment_Base C_ORDERTAX.TAXBASEAMT%TYPE ;
v_totallines NUMERIC:=0;
v_grandtotal NUMERIC:=0;
v_istaxincluded CHAR(1);
    
BEGIN
    
    IF AD_isTriggerEnabled()='N' THEN IF TG_OP = 'DELETE' THEN RETURN OLD; ELSE RETURN NEW; END IF; 
    END IF;
    
    IF(TG_OP = 'INSERT' OR TG_OP = 'UPDATE') THEN
      v_C_Tax_ID:=NEW.C_Tax_ID;
      v_C_Invoice_ID:=NEW.C_INVOICE_ID;
    ELSE
      v_C_Tax_ID:=OLD.C_Tax_ID;
      v_C_Invoice_ID:=OLD.C_INVOICE_ID;
    END IF;

    SELECT C_CURRENCY.STDPRECISION, PROCESSED,  M_PRICELIST.istaxincluded
    INTO v_Prec, v_Processed, v_istaxincluded
    FROM C_INVOICE, C_CURRENCY, M_PRICELIST
    WHERE C_INVOICE.C_CURRENCY_ID = C_CURRENCY.C_CURRENCY_ID
    AND C_INVOICE.M_PRICELIST_ID = M_PRICELIST.M_PRICELIST_ID
    AND C_INVOICE_ID = v_C_Invoice_ID;
    --added logic by usha on july 18th for taxamount precision rounding off
    --v_Prec :=0.0;
    SELECT DOCTAXAMOUNT, RATE
    INTO v_DocTaxAmount, v_Rate
    FROM C_TAX
    WHERE C_TAX_ID = v_C_Tax_ID;
  IF ( TG_OP = 'INSERT' ) THEN
    v_Increment_Amount := NEW.TAXAMT ;
    v_Increment_Base := NEW.TAXBASEAMT ;
  ELSIF ( TG_OP = 'UPDATE' ) THEN
    v_Increment_Amount := NEW.TAXAMT - OLD.TAXAMT ;
    v_Increment_Base := NEW.TAXBASEAMT - OLD.TAXBASEAMT ;
  ELSE
    v_Increment_Amount := - OLD.TAXAMT ;
    v_Increment_Base := - OLD.TAXBASEAMT ;
  END IF;

  IF (TG_OP = 'INSERT' OR TG_OP = 'UPDATE') THEN
    SELECT COUNT(C_TAX_ID), MAX(c_invoicetax_id) INTO v_Count, v_c_invoicetax_id
    FROM C_INVOICETAX
    WHERE C_INVOICE_ID = NEW.C_Invoice_ID
    AND C_TAX_ID = NEW.C_TAX_ID
    AND Recalculate = 'Y';
    IF(v_Count>0) THEN
      UPDATE C_INVOICETAX SET TAXAMT = (CASE WHEN v_DocTaxAmount='D' THEN ROUND((TAXBASEAMT + v_Increment_Base) * v_Rate/100, v_Prec) ELSE (TAXAMT + v_Increment_Amount) END), 
      TAXBASEAMT=TAXBASEAMT + v_Increment_Base
      WHERE C_INVOICETAX_ID = v_c_invoicetax_id;
    ELSE
      SELECT COALESCE(MAX(LINE),0) + 10
      INTO v_LineNo
      FROM C_INVOICETAX
      WHERE C_INVOICE_ID = NEW.C_Invoice_ID;
      INSERT
      INTO C_INVOICETAX (
      C_InvoiceTax_ID, C_Invoice_ID, C_Tax_ID, AD_Client_ID, AD_Org_ID,
      IsActive, Created, CreatedBy, Updated,
      UpdatedBy, TaxBaseAmt, TaxAmt, Line, Recalculate)
      VALUES (
      GET_UUID(), NEW.C_Invoice_ID, NEW.C_TAX_ID, NEW.AD_CLIENT_ID, NEW.AD_ORG_ID,
      'Y', TO_DATE(NOW()), NEW.UPDATEDBY, TO_DATE(NOW()),
      NEW.UPDATEDBY, NEW.TAXBASEAMT, NEW.TAXAMT, v_LineNo, 'Y');
    END IF;
  ELSE
  IF (v_Processed='Y') THEN 
    RAISE EXCEPTION '%', '@20501@' ; --OBTG:-20000--
  ELSE
    UPDATE C_INVOICETAX SET TAXAMT = (CASE WHEN v_DocTaxAmount='D' THEN ROUND((TAXBASEAMT - OLD.TAXBASEAMT) * v_Rate/100, v_Prec) ELSE (TAXAMT - OLD.TAXAMT) END), TAXBASEAMT=TAXBASEAMT - OLD.TAXBASEAMT
    WHERE C_INVOICE_ID = OLD.C_Invoice_ID
    AND C_TAX_ID = OLD.C_TAX_ID
    AND Recalculate = 'Y';
    
    DELETE FROM C_INVOICETAX 
    WHERE C_INVOICE_ID = OLD.C_Invoice_ID
    AND C_TAX_ID = OLD.C_TAX_ID
    AND TAXAMT=0 AND TAXBASEAMT=0;
    
 		IF (v_istaxincluded = 'Y') THEN
      SELECT totallines, grandtotal INTO v_totallines, v_grandtotal
      FROM C_invoice
      WHERE c_invoice_id = v_C_Invoice_ID;
      PERFORM C_INVOICETAX_ROUNDING(v_C_Invoice_ID, v_grandtotal, v_totallines);
    END IF;
    
	END IF;
END IF;
IF TG_OP = 'DELETE' THEN RETURN OLD; ELSE RETURN NEW; END IF; 

END 

; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION c_invoicelinetax_trg()
  OWNER TO tad;



CREATE OR REPLACE FUNCTION aprm_gen_paymentschedule_inv(p_ep_instance character varying)
  RETURNS void AS
$BODY$ DECLARE 
/*************************************************************************
* The contents of this file are subject to the Openbravo  Public  License
* Version  1.0  (the  "License"),  being   the  Mozilla   Public  License
* Version 1.1  with a permitted attribution clause; you may not  use this
* file except in compliance with the License. You  may  obtain  a copy of
* the License at http://www.openbravo.com/legal/license.html
* Software distributed under the License  is  distributed  on  an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
* License for the specific  language  governing  rights  and  limitations
* under the License.
* The Original Code is Openbravo ERP.
* The Initial Developer of the Original Code is Openbravo SLU
* All portions are Copyright (C) 2010-2015 Openbravo SLU
* All Rights Reserved.
* Contributor(s):  ______________________________________.
************************************************************************/


p_message VARCHAR(2000);
p_record_id VARCHAR(60);
p_docAction VARCHAR(60);
p_user VARCHAR(60);
p_result NUMERIC;

v_PaidAmount NUMERIC;
V_OutstandingAmount NUMERIC;
V_DueAmount NUMERIC;
V_DayStillDue NUMERIC;
v_ConvertedAmount NUMERIC;

v_Client_ID VARCHAR(32); --OBTG:VARCHAR2--
v_Org_ID VARCHAR(32); --OBTG:VARCHAR2--
v_ResultStr VARCHAR(2000):=''; --OBTG:VARCHAR2--
v_Message VARCHAR(2000):=''; --OBTG:VARCHAR2--
v_DocTypeTarget_ID VARCHAR(32); --OBTG:VARCHAR2--
v_IsSOTrx C_INVOICE.IsSOTrx%TYPE;
v_GrandTotal NUMERIC:=0;
v_PaymentTerm C_INVOICE.C_PaymentTerm_ID%TYPE;
v_PaymentRule C_INVOICE.PaymentRule%TYPE;
v_Currency_ID VARCHAR(32); --OBTG:VARCHAR2--
v_bpCurrency_id VARCHAR(32); --OBTG:VARCHAR2--
v_BPartner_ID VARCHAR(32); --OBTG:VARCHAR2--
v_DateInvoiced TIMESTAMP;
v_TotalLines NUMERIC;
v_PaymentMethod C_INVOICE.FIN_PAYMENTMETHOD_ID%TYPE;
v_documentno C_INVOICE.DocumentNo%TYPE;
v_poreference C_INVOICE.POReference%TYPE;
v_project_id c_invoice.c_project_id%TYPE;
v_campaign_id c_invoice.c_campaign_id%TYPE;
v_activity_id c_invoice.c_activity_id%TYPE;
v_user1 c_invoice.user1_id%TYPE;
v_user2 c_invoice.user2_id%TYPE;
v_costcenter c_invoice.c_costcenter_id%TYPE;
v_reversalinvoice_id VARCHAR(32); --OBTG:VARCHAR2--
v_delete_paymentplan BOOLEAN := FALSE;
v_Financial_Account_ID FIN_FINANCIAL_ACCOUNT.FIN_FINANCIAL_ACCOUNT_ID%TYPE;
v_Financial_Account_Org VARCHAR(32); --OBTG:VARCHAR2--
v_CreatePayment CHAR(1):='N';
v_CreateFinTransaction CHAR(1):='N';
v_PaymentDocType_ID FIN_PAYMENT.C_DOCTYPE_ID%TYPE;
v_PaymentDocumentNo FIN_PAYMENT.DOCUMENTNO%TYPE;
v_FIN_PAYMENT_ID FIN_PAYMENT.FIN_PAYMENT_ID%TYPE;
v_FIN_PAYMENT_DETAIL_ID FIN_PAYMENT_DETAIL.FIN_PAYMENT_DETAIL_ID%TYPE;
v_FIN_FINACC_TRANSACTION_ID FIN_FINACC_TRANSACTION.FIN_FINACC_TRANSACTION_ID%TYPE;
v_Line FIN_FINACC_TRANSACTION.LINE%TYPE;
v_count NUMERIC;
v_PaymentPriority VARCHAR(32);
v_InvoicePaid CHAR(1);
v_creditmultiplier NUMERIC:= 1;
v_lang AD_User.Default_AD_Language%TYPE;
v_orderno C_Order.DocumentNo%TYPE:=null;
v_finpayment_desc VARCHAR(2000); --OBTG:VARCHAR2--
v_orderno_trl AD_Message.MsgText%TYPE;
v_invoiceno_trl AD_Message.MsgText%TYPE;
v_payment_desc AD_OrgInfo.em_aprm_payment_desc%TYPE;
v_description_first BOOLEAN := TRUE;
v_finacct_currency VARCHAR(32); --OBTG:VARCHAR2--
v_rate NUMERIC;
v_PricePr NUMERIC;
v_isinvoicepaid CHAR(1):= 'N';
v_IsCashVAT C_Invoice.IsCashVAT%TYPE;

--TYPE RECORD IS REFCURSOR;
Cur_Params RECORD;
cur_paymentschedule RECORD;
cur_finaccpaymentmethod RECORD;
cur_PaymentScheduleOrder RECORD;
cur_linktopayment_scheddetails RECORD;
cur_update_scheddetails RECORD;
cur_invoicepaid RECORD;

v_paymentamt NUMERIC:=0;
v_depositamt NUMERIC:=0;
v_transactiontype VARCHAR(32); --OBTG:VARCHAR2--
v_roundingValue NUMERIC:=0; --added by pranav for rounding off amount issue
v_flag CHAR(1):= 'N'; --added by pranav for rounding off amount issue

BEGIN

  FOR Cur_Params IN (
    SELECT *
    FROM ad_ep_instance_para
    WHERE ad_ep_instance_id = p_ep_instance
    ) LOOP
    IF (cur_params.parametername LIKE 'DocAction') THEN
      p_docaction := Cur_Params.p_string;
    ELSIF (cur_params.parametername LIKE 'Record_ID') THEN
      p_record_id := cur_params.p_string;
    ELSIF (cur_params.parametername LIKE 'User') THEN
      p_user := cur_params.p_string;
    ELSIF (cur_params.parametername LIKE 'Message') THEN
      p_message := cur_params.p_text;
    ELSIF (cur_params.parametername LIKE 'Result') THEN
      p_result := cur_params.p_number;
    END IF;
  END LOOP;
  -- Default user's language
  SELECT COALESCE(default_ad_language, 'en_US') INTO v_lang FROM ad_user where ad_user_id = p_user;

  -- Reading the invoice
  v_ResultStr:='ReadingInvoice';
  SELECT ad_client_id, ad_org_id, c_doctypetarget_id, IsSOTrx,
      grandtotal, C_PaymentTerm_ID, PaymentRule, C_Currency_ID,
      C_BPartner_ID, DateInvoiced, totallines, fin_paymentmethod_id,
      fin_payment_priority_id, documentNo, poreference,
      c_project_id, c_campaign_id, c_activity_id, user1_id, user2_id, c_costcenter_id,
      IsCashVAT
  INTO v_Client_ID, v_Org_ID, v_DocTypeTarget_ID, v_IsSOTrx,
      v_GrandTotal, v_PaymentTerm, v_PaymentRule, v_Currency_ID,
      v_BPartner_ID, v_DateInvoiced, v_totallines, v_PaymentMethod,
      v_PaymentPriority, v_documentno, v_poreference,
      v_project_id, v_campaign_id, v_activity_id, v_user1, v_user2, v_costcenter,
      v_IsCashVAT
  FROM c_invoice
  WHERE c_invoice_id=p_record_id;
  
  IF (v_IsSOTrx = 'N') THEN
    v_creditmultiplier := -1;
  END IF;

  --Gets the business partner's currency
  SELECT BP_Currency_ID
  INTO v_bpCurrency_id
  from C_BPartner
  WHERE C_BPartner_ID = v_BPartner_ID;
  
  IF (v_bpCurrency_id is null) THEN
    v_bpCurrency_id:= v_Currency_ID;

    update c_bpartner
    set BP_Currency_ID = v_bpCurrency_id
    where c_bpartner_id =v_BPartner_ID;
  END IF;

  -- complete invoice
  IF (p_docaction = 'CO') THEN
    -- Checking Payment Method ID is available
    IF(v_PaymentMethod IS NULL) THEN
      RAISE EXCEPTION '%', '@APRM_PAYMENTMETHOD_MISSING@'; --OBTG:-20000--
    END IF;
    
    -- BEGIN Extension Point
    SELECT count(*) INTO v_count FROM DUAL
    WHERE EXISTS (SELECT 1 FROM ad_ep_procedures WHERE ad_extension_points_id = 'F489FE52771F42E5B8CF228F26553726');
    IF (v_count=1) THEN
      DECLARE
        v_ep_instance VARCHAR(32); --OBTG:VARCHAR2--
        v_extension_point_id VARCHAR(32) := 'F489FE52771F42E5B8CF228F26553726'; --OBTG:VARCHAR2--
      BEGIN 
        v_ep_instance := get_uuid();
        PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'Record_ID', p_record_id, NULL, NULL, NULL, NULL, NULL, NULL);
        PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'DocAction', p_docaction, NULL, NULL, NULL, NULL, NULL, NULL);
        PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'User', p_user, NULL, NULL, NULL, NULL, NULL, NULL);
        PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'Message', NULL, NULL, NULL, NULL, NULL, NULL, p_message);
        PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'Result', NULL, NULL, p_result, NULL, NULL, NULL, NULL);
        
        PERFORM AD_EXTENSION_POINT_HANDLER(v_ep_instance, v_extension_point_id);
        SELECT p_number INTO p_result
        FROM ad_ep_instance_para
        WHERE ad_ep_instance_id = v_ep_instance
          AND parametername LIKE 'Result';
        SELECT p_text INTO p_message
        FROM ad_ep_instance_para
        WHERE ad_ep_instance_id = v_ep_instance
          AND parametername LIKE 'Message';

        DELETE FROM ad_ep_instance_para
        WHERE ad_ep_instance_id = v_ep_instance;
      END;
    END IF;
    -- END Extension Point
    
    
    DECLARE
      cur_payments RECORD;
      cur_order_schdet_ISOPEN BOOLEAN:=false;
      fetch_next_order_item BOOLEAN:=true;
      next_order BOOLEAN := FALSE;
      v_TargetDocBaseType C_DOCTYPE.DocBaseType%TYPE;
      v_isReversal C_DOCTYPE.IsReversal%TYPE;
      v_MultiplierARC NUMERIC:=1;
      v_pendingAmount NUMERIC;
      v_plannedDate TIMESTAMP;
      v_paymentAmount NUMERIC;
      v_scheduledamount NUMERIC;
      v_invoicedamount NUMERIC;
      v_notassignedamount NUMERIC;
      v_assignedamount NUMERIC;
      v_scheduledetailamount NUMERIC;
      v_oldorder VARCHAR(32) := '-1'; --OBTG:VARCHAR2--
      v_payment_schedule_invoice VARCHAR(32); --OBTG:VARCHAR2--
      v_differenceamount NUMERIC:= 0;
      v_scheduledetailid VARCHAR(32); --OBTG:VARCHAR2--
      v_new_scheduledetailid VARCHAR(32); --OBTG:VARCHAR2--
      v_ConsumedGranTotal NUMERIC:= 0;
      v_paymentCount NUMERIC:= 0;
      v_negativePS NUMERIC:= 1;
      v_psdbreakbypartialpayment BOOLEAN:=TRUE;
      cur_cinvoicetax RECORD;
      v_PercentageCashVAT NUMERIC;

      DECLARE cur_order_schdet CURSOR (invoice_id VARCHAR)  FOR
      SELECT DISTINCT c_orderline.c_order_id AS order_id, fin_payment_scheduledetail.amount + COALESCE(fin_payment_scheduledetail.writeoffamt,0) AS amount,
             fin_payment_scheduledetail_id,
             fin_payment_scheduledetail.fin_payment_schedule_order,
             fin_payment_scheduledetail.fin_payment_detail_id,
             fin_payment_scheduledetail.isinvoicepaid AS paid,
             CASE WHEN fin_payment_scheduledetail.fin_payment_detail_id is not null THEN 0 ELSE 1 END AS priority
      FROM c_invoiceline, c_orderline, fin_payment_schedule,
        fin_payment_scheduledetail LEFT JOIN fin_payment_detail ON fin_payment_scheduledetail.fin_payment_detail_id = fin_payment_detail.fin_payment_detail_id
                                   LEFT JOIN fin_payment ON fin_payment_detail.fin_payment_id = fin_payment.fin_payment_id
      WHERE c_invoiceline.c_orderline_id = c_orderline.c_orderline_id
        AND c_orderline.c_order_id = fin_payment_schedule.c_order_id
        AND fin_payment_schedule.fin_payment_schedule_id = fin_payment_scheduledetail.fin_payment_schedule_order
        AND fin_payment_scheduledetail.fin_payment_schedule_invoice is null
        AND fin_payment_scheduledetail.ISCANCELED <> 'Y'
        AND c_invoiceline.c_invoice_id = invoice_id
      ORDER BY CASE WHEN fin_payment_scheduledetail.fin_payment_detail_id is not null THEN 0 ELSE 1 END, c_orderline.c_order_id;
      order_schdet RECORD; --OBTG:cur_order_schdet--

    BEGIN
      v_ResultStr:='Generating FIN_PAYMENT_SCHEDULE';

      SELECT count(1) INTO v_count
      FROM c_debt_payment
      WHERE c_invoice_id = p_record_id;
      IF (v_count > 0) THEN
        RAISE EXCEPTION '%', '@APRM_INVOICE_MAN_PAYMENTS@'; --OBTG:-20000--
      END IF;
      -- Is it a Credit Memo
      SELECT docbasetype, isreversal
        INTO v_TargetDocBaseType, v_isReversal
      FROM c_doctype
      WHERE c_doctype_id=v_DocTypeTarget_ID;
      IF (v_TargetDocBaseType in ('ARC','APC') or v_isReversal='Y') THEN
        v_MultiplierARC:=-1;
      END IF;

      SELECT COALESCE(sum(ps.paidamt),0)
      INTO v_ConsumedGranTotal
      FROM fin_payment_schedule ps
      WHERE ps.c_invoice_id = p_record_id;
            
      --Insert Payment Schedules for Invoices
      v_pendingAmount := v_GrandTotal - coalesce(v_ConsumedGranTotal, 0);

      IF (v_pendingAmount <> 0) THEN

        --get number of payment schedules expected for the invoice
        SELECT count(*) INTO v_paymentcount
        FROM (
            SELECT line, percentage, onremainder, excludetax,
                   COALESCE(paymentrule, v_paymentrule) AS paymentrule,
                   (CASE isduefixed WHEN 'N' THEN  null ELSE fixmonthday END) AS fixmonthday,
                   (CASE isduefixed WHEN 'N' THEN  null ELSE fixmonthday2 END) AS Fixmonthday2,
                   (CASE isduefixed WHEN 'N' THEN  null ELSE fixmonthday3 END) AS fixmonthday3,
                   netdays, fixmonthoffset, netday, isnextbusinessday
            FROM c_paymenttermline
            WHERE c_paymentterm_id=v_paymentterm
              AND isactive = 'Y'
            UNION
            -- Header of paymentTerm is processed at last
            SELECT 9999 AS line, 100 AS percentage, 'Y' AS onremainder, 'N' AS excludetax,
                   v_paymentRule AS paymentrule,
                   (CASE isduefixed WHEN 'N' THEN  null ELSE fixmonthday END) AS fixmonthday,
                   (CASE isduefixed WHEN 'N' THEN  null ELSE fixmonthday2 END) AS Fixmonthday2,
                   (CASE isduefixed WHEN 'N' THEN  null ELSE fixmonthday3 END) AS fixmonthday3,
                   netdays, fixmonthoffset, netday, isnextbusinessday
            FROM c_paymentterm
            WHERE c_paymentterm_id=v_paymentterm) a;

        FOR cur_payments IN (
            SELECT line, percentage, onremainder, excludetax,
                   COALESCE(cptl.paymentrule, v_paymentrule) AS paymentrule,
                   (CASE isduefixed WHEN 'N' THEN  null ELSE fixmonthday END) AS fixmonthday,
                   (CASE isduefixed WHEN 'N' THEN  null ELSE fixmonthday2 END) AS Fixmonthday2,
                   (CASE isduefixed WHEN 'N' THEN  null ELSE fixmonthday3 END) AS fixmonthday3,
                   netdays, fixmonthoffset, netday, isnextbusinessday,
                   COALESCE(cptl.fin_paymentmethod_id,c.fin_paymentmethod_id) as fin_paymentmethod_id
            FROM c_paymenttermline cptl,c_invoice c
            WHERE cptl.c_paymentterm_id=v_paymentterm
              AND cptl.isactive = 'Y'
              AND c_invoice_id = p_record_id
            UNION
            -- Header of paymentTerm is processed at last
            SELECT 9999 AS line, 100 AS percentage, 'Y' AS onremainder, 'N' AS excludetax,
                   v_paymentRule AS paymentrule,
                   (CASE isduefixed WHEN 'N' THEN  null ELSE fixmonthday END) AS fixmonthday,
                   (CASE isduefixed WHEN 'N' THEN  null ELSE fixmonthday2 END) AS Fixmonthday2,
                   (CASE isduefixed WHEN 'N' THEN  null ELSE fixmonthday3 END) AS fixmonthday3,
                   netdays, fixmonthoffset, netday, isnextbusinessday,
                   c.fin_paymentmethod_id
            FROM c_paymentterm cpt ,c_invoice c
            WHERE cpt.c_paymentterm_id=v_paymentterm
              AND c_invoice_id = p_record_id
            ORDER BY line
          )
        LOOP
          -- Decrease v_paymentcount, when its value is 0 it's the last payment.
          v_paymentcount := v_paymentcount - 1;
          v_plannedDate:=C_Paymentduedate(v_bpartner_id, v_issotrx, cur_payments.fixmonthday, cur_payments.fixmonthday2, cur_payments.fixmonthday3, cur_payments.netdays, cur_payments.fixmonthoffset, cur_payments.netday, cur_payments.isnextbusinessday, v_dateinvoiced);

          IF(cur_payments.excludetax='Y') THEN 
            -- if excludeTax = 'Y', percentage is aplied on the TotalLines
            v_paymentAmount:=C_Currency_Round(v_totallines * cur_payments.percentage/100, v_currency_id, NULL);
          ELSIF(cur_payments.onremainder='N') THEN 
            -- if onRemainder = 'N', percentage is aplied on the GrandTotal
            v_paymentAmount:=C_Currency_Round(v_grandtotal * cur_payments.percentage/100, v_currency_id, NULL);
          ELSE 
            v_paymentAmount:=C_Currency_Round(v_pendingamount * cur_payments.percentage/100, v_currency_id, NULL);
          END IF;
          v_pendingamount := v_pendingamount - v_paymentamount;
          v_scheduledamount := C_Currency_Round((v_paymentamount * v_multiplierarc), v_currency_id, NULL);
          IF (v_scheduledamount < 0) THEN
            v_negativeps := -1;
          ELSE
            v_negativeps := 1;
          END IF;

          v_ResultStr:='Inserting in FIN_PAYMENT_SCHEDULE table';
          v_payment_schedule_invoice := get_uuid();
          INSERT INTO fin_payment_schedule
          (
            fin_payment_schedule_id, ad_client_id, ad_org_id, isactive,
            created, createdby, updated, updatedby,
            c_invoice_id, c_currency_id, c_order_id,
            fin_paymentmethod_id, amount, duedate, expecteddate,
            outstandingamt, fin_payment_priority_id
           ) VALUES (
            v_payment_schedule_invoice, v_client_id, v_org_id, 'Y',
            TO_DATE(NOW()), p_user, TO_DATE(NOW()), p_user,
            p_record_id, v_currency_id, null,
            cur_payments.fin_paymentmethod_id,
            v_scheduledamount, v_planneddate, v_planneddate,
            v_scheduledamount, v_PaymentPriority
          );

          -- loop for payment schedule details of related orders
          LOOP
            -- open cursor once
            IF (NOT cur_order_schdet_ISOPEN) THEN
              OPEN cur_order_schdet(p_record_id);
              cur_order_schdet_ISOPEN := true;
            END IF;

            -- fetch if we have finished with the current one
            IF (fetch_next_order_item OR next_order) THEN
              FETCH cur_order_schdet INTO order_schdet;
              EXIT WHEN  NOT FOUND ; --OBTG:cur_order_schdet--
              v_scheduledetailid := order_schdet.fin_payment_scheduledetail_id;
              v_scheduledetailamount := order_schdet.amount;
              next_order := FALSE;
            ELSE
              v_scheduledetailamount := v_differenceamount;
              v_scheduledetailid := v_new_scheduledetailid;
            END IF;
            
            IF (order_schdet.order_id <> v_oldorder) THEN
              -- get invoiced amount for the order
              SELECT COALESCE(SUM(c_invoiceline.linenetamt+c_getinvoiceline_taxamount(c_invoiceline.c_invoiceline_id)),0) INTO v_invoicedamount
              FROM c_invoiceline, c_orderline
              WHERE c_invoiceline.c_orderline_id = c_orderline.c_orderline_id
                AND c_invoiceline.c_invoice_id = p_record_id
                AND c_orderline.c_order_id = order_schdet.order_id;

              --if v_count = 0 the order is completely invoiced on this invoice.
              IF (v_IsSOTrx = 'Y') THEN
                SELECT COALESCE(COUNT(*),0) INTO v_Count
                FROM c_orderline
                WHERE qtyinvoiced<>qtyordered
                  AND c_order_id = order_schdet.order_id;
              ELSE
                SELECT count(*) INTO v_count
                FROM (
                  SELECT coalesce(SUM(mpo.qty),0) as matchedqty, ol.qtyordered
                  FROM c_orderline ol
                       LEFT JOIN m_matchpo mpo ON ol.c_orderline_id = mpo.c_orderline_id
                                                  AND mpo.c_invoiceline_id IS NOT NULL
                  WHERE ol.c_order_id = order_schdet.order_id
                  GROUP BY ol.c_orderline_id, ol.qtyordered) a
                WHERE a.matchedqty != a.qtyordered;
              END IF;
            END IF;

            --If the order is completely invoiced the whole amount of the psd has to be included on the invoice.
            IF (v_count = 0) THEN
              v_notassignedamount := v_scheduledetailamount;
            ELSE 
              SELECT COALESCE(SUM(psd.amount),0) INTO v_assignedamount
              FROM fin_payment_schedule ps_inv, fin_payment_scheduledetail psd,
                 fin_payment_schedule ps_ord
              WHERE ps_inv.fin_payment_schedule_id = psd.fin_payment_schedule_invoice
                AND psd.fin_payment_schedule_order = ps_ord.fin_payment_schedule_id
                AND ps_inv.c_invoice_id = p_record_id
                AND psd.ISCANCELED <> 'Y'
                AND ps_ord.c_order_id = order_schdet.order_id;

              -- substract previously assigned amount
              v_notassignedamount := (COALESCE(v_invoicedamount,0) - COALESCE(v_assignedamount,0));
            END IF;

            -- If there is no amount left to assign from the order to the invoice and the order is not completely
            -- invoiced move to next order payment schedule detail.
            -- Example 1: an order with a partial prepayment and is partially invoiced with the prepayment amount, the
            -- psd that remains unpaid shall not be included in the invoice.
            -- Example 2: an order with a partial prepayment and is invoiced completely changing the price so the grand
            -- total is exactly the amount of the prepayment, the psd that remaing unpaid shall be included in the invoice.
            IF (v_notassignedamount = 0 AND v_count <> 0) THEN
              next_order := TRUE;
            END IF;
            IF (NOT next_order) THEN
              v_differenceamount := 0;

              --1st condition: The order is completely invoiced and it is the last payment schedule. All the pending amount of the
              --               order has to be assigned to this invoice, a regulation psd only related to this invoice will be 
              --               generated later to match the difference.
              --2st condition: invoiced amount is higher than the scheduled amount, calculate the difference and split
              --               the payment schedule detail of the order.
              --3rd condition: split order's payment schedule detail in case that not all the amount has been invoiced.
              --               In this case difference amount would not be zero.
              IF(v_Count = 0 AND v_paymentcount = 0) THEN
                v_differenceamount:= 0;
              ELSIF (v_notassignedamount * v_negativePS > v_scheduledamount * v_negativeps ) THEN
                v_differenceamount := COALESCE(v_scheduledetailamount,0) - COALESCE(v_scheduledamount,0);
                IF (v_paymentcount > 0) THEN
                  v_psdbreakbypartialpayment := true;
                ELSE
                  v_psdbreakbypartialpayment := false;
                END IF;
              ELSE
                v_differenceamount := COALESCE(v_scheduledetailamount,0) - COALESCE(v_notassignedamount,0);
                v_psdbreakbypartialpayment := false;
              END IF;

              --When difference amount is not 0 the payment schedule detail of the order has to be split. The difference
              --amount is the amount of the new psd that is not related to any invoice.	      

              IF (v_differenceamount * v_negativePS > 0) THEN
                 v_new_scheduledetailid := get_uuid(); 
                 INSERT INTO fin_payment_scheduledetail
                 (
                  fin_payment_scheduledetail_id, ad_client_id, ad_org_id, isactive,
                  created, createdby, updated, updatedby,
                  fin_payment_schedule_order,
                  fin_payment_schedule_invoice,
                  fin_payment_detail_id,
                  amount,
                  c_bpartner_id
                 )
                 VALUES
                 (
                  v_new_scheduledetailid, v_Client_ID, v_Org_ID, 'Y',
                  TO_DATE(NOW()), p_user, TO_DATE(NOW()), p_user,
                  order_schdet.fin_payment_schedule_order,
                  null,
                  order_schdet.fin_payment_detail_id,
                  v_differenceamount, 
                  v_BPartner_ID
                 );

                 -- update amount of the current payment schedule detail
                 UPDATE fin_payment_scheduledetail
                 SET amount = amount - v_differenceamount,
                   updated = TO_DATE(NOW()),
                   updatedby = p_user
                 WHERE fin_payment_scheduledetail_id = v_scheduledetailid;

                 v_scheduledetailamount := v_scheduledetailamount - v_differenceamount;
              END IF;

              IF (v_differenceamount = 0 OR (v_count <> 0 AND NOT v_psdbreakbypartialpayment)) THEN
                fetch_next_order_item := true;
              ELSE
                fetch_next_order_item := false;
              END IF;

              -- link current current payment schedule detail to the invoice
              UPDATE fin_payment_scheduledetail
              SET fin_payment_schedule_invoice = v_payment_schedule_invoice,
                  updated = TO_DATE(NOW()),
                  updatedby = p_user
              WHERE fin_payment_scheduledetail_id = v_scheduledetailid;

               UPDATE FIN_PAYMENT_SCHEDULEDETAIL
              SET isinvoicepaid=(select CASE WHEN fpsd.fin_payment_detail_id is null then 'N'
                  WHEN ((aprm_seqnumberpaymentstatus(fp.status))>= (aprm_seqnumberpaymentstatus((CASE WHEN fp.isreceipt='Y' 
                  THEN Payin_Invoicepaidstatus ELSE Payout_Invoicepaidstatus END)))) THEN 'Y' ELSE 'N' END
                  from fin_payment_scheduledetail fpsd
                  left join fin_payment_detail fpd on fpsd.fin_payment_detail_id=fpd.fin_payment_detail_id
                  left join fin_payment fp on fpd.fin_payment_id=fp.fin_payment_id
                  left join fin_financial_account fa on fa.fin_financial_account_id=fp.fin_financial_account_id 
                  left join FIN_FinAcc_PaymentMethod fpm on fpm.fin_financial_account_id=fp.fin_financial_account_id 
                 and fpm.fin_paymentmethod_id=fp.fin_paymentmethod_id WHERE fin_payment_scheduledetail_id = v_scheduledetailid) 
                 WHERE FIN_PAYMENT_SCHEDULEDETAIL_ID = v_scheduledetailid;
              
              -- if paid, update paid and outstanding amount
              select isinvoicepaid 
              into v_isinvoicepaid 
              from fin_payment_scheduledetail
              where fin_payment_scheduledetail_id = v_scheduledetailid;
              
              IF (v_isinvoicepaid = 'Y') THEN
                UPDATE fin_payment_schedule
                SET outstandingamt = outstandingamt - COALESCE(v_scheduledetailamount,0),
                    paidamt = paidamt + COALESCE(v_scheduledetailamount, 0)
                WHERE fin_payment_schedule_id = v_payment_schedule_invoice;
              END IF;

              v_scheduledamount := v_scheduledamount - v_scheduledetailamount;

	      -- Create C_InvoiceTax_CashVAT records
	      IF (v_IsCashVAT = 'Y' AND order_schdet.fin_payment_detail_id IS NOT NULL) THEN
                v_PercentageCashVAT := c_currency_round(v_scheduledetailamount * 100 / v_GrandTotal, v_Currency_ID, null);
		FOR cur_cinvoicetax IN (
		  SELECT it.C_InvoiceTax_ID, it.taxamt, it.taxbaseamt
                  FROM C_InvoiceTax it INNER JOIN C_Tax t on (it.c_tax_id = t.c_tax_id)
		  WHERE it.c_invoice_id = p_record_id
                  AND t.isCashVAT = 'Y'
                )
                LOOP
	          INSERT INTO c_invoicetax_cashvat(
                  c_invoicetax_cashvat_id, ad_client_id, ad_org_id, isactive, created,
                  createdby, updated, updatedby, c_invoicetax_id, percentage, taxamt,
                  taxbaseamt, fin_payment_detail_id)
                  VALUES (get_uuid(), v_Client_ID, v_Org_ID, 'Y', TO_DATE(NOW()),
                  p_user, TO_DATE(NOW()), p_user, cur_cinvoicetax.C_InvoiceTax_ID, v_PercentageCashVAT, c_currency_round(v_PercentageCashVAT * cur_cinvoicetax.taxamt / 100, v_Currency_ID, null),
                  c_currency_round(v_PercentageCashVAT * cur_cinvoicetax.taxbaseamt / 100, v_Currency_ID, null), order_schdet.fin_payment_detail_id);
                END LOOP;
	      END IF;

              IF (v_scheduledamount * v_negativeps <= 0 AND v_paymentcount > 0) THEN
                -- actual invoice's payment schedule processed.
                v_oldorder := order_schdet.order_id;
                EXIT;
              END IF;
            END IF;

            v_oldorder := order_schdet.order_id;
          END LOOP;

	  -- Code Added by Pranav for Rounding OF Amount Issue
	  Select Coalesce(SUM(LineNetAmt), 0) 
	  Into v_roundingValue
	  From C_Invoiceline 
	  Where C_Invoice_ID = p_record_id
	  And Account_ID In (Select C_GLItem_ID From C_GLItem Where Name Like '%Rounding off  Differences');

          IF (v_scheduledamount <> 0 ) And (v_roundingValue <> v_scheduledamount) THEN -- (v_scheduledamount <> 0 )
            -- no more orders, insert payment schedule detail with remaining amount
            INSERT INTO fin_payment_scheduledetail
            (
              fin_payment_scheduledetail_id, ad_client_id, ad_org_id, isactive,
              created, createdby, updated, updatedby,
              fin_payment_schedule_order,
              fin_payment_schedule_invoice,
              fin_payment_detail_id,
              amount,
              c_bpartner_id
            )
            VALUES
            (
              get_uuid(), v_Client_ID, v_Org_ID, 'Y',
              TO_DATE(NOW()), p_user, TO_DATE(NOW()), p_user,
              null,
              v_payment_schedule_invoice,
              null,
              v_scheduledamount,
              v_BPartner_ID
            );
          Else -- Code Added by Pranav for Rounding OF Amount Issue
             IF v_flag = 'N' THEN
                Update fin_payment_scheduledetail
                Set amount = amount + v_roundingValue
                Where fin_payment_schedule_invoice in 
		(select fin_payment_schedule_id 
		 from fin_payment_schedule 
		 where c_invoice_id = p_record_id 
		 and amount > 0 
		 And round(amount) <> (amount+v_roundingValue));

		v_flag := 'Y';
             END IF;
          END IF;
        END LOOP;

        CLOSE cur_order_schdet;
      
      END IF;

      -- Reading Data from FIN_PAYMENT_SCHEDULE
      SELECT COALESCE(sum(PAIDAMT),0) as PaidAmount, COALESCE(SUM(OUTSTANDINGAMT),0) as OutstandingAmount
        INTO v_PaidAmount,V_OutstandingAmount
      FROM FIN_PAYMENT_SCHEDULE
      WHERE C_INVOICE_ID=P_RECORD_ID;
      -- Getting DueAmount from FIN_PAYMENT_SCHEDULE for the Invoice
      SELECT coalesce(sum(OUTSTANDINGAMT),0) as DueAmount
        INTO V_DueAmount
      FROM FIN_PAYMENT_SCHEDULE
      WHERE C_INVOICE_ID=P_RECORD_ID
        AND duedate<=TO_DATE(NOW());
      V_DueAmount :=COALESCE(V_DueAmount,0);
      --Getting Day Still Due
      SELECT COALESCE(TO_NUMBER(MIN(DUEDATE)-TRUNC(TO_DATE(NOW()))),0) as DAYSTILLDUE
      INTO V_DayStillDue
      FROM FIN_PAYMENT_SCHEDULE
      WHERE C_INVOICE_ID=P_RECORD_ID
        AND OUTSTANDINGAMT != 0;

      --Updating Payment Monitor values into C_INVOICE
      UPDATE C_INVOICE
      SET TOTALPAID = v_PaidAmount,
          OUTSTANDINGAMT = COALESCE(v_OutstandingAmount,0),
          DUEAMT =  V_DueAmount,
          DAYSTILLDUE = V_DayStillDue,
          LASTCALCULATEDONDATE = TO_DATE(NOW()),
          ISPAID = CASE v_OutstandingAmount WHEN 0 THEN 'Y' ELSE 'N' END,
          FINALSETTLEMENT = CASE v_OutstandingAmount WHEN 0 THEN TO_DATE(NOW()) ELSE NULL END
      WHERE C_INVOICE_ID = P_RECORD_ID;

      -- Updating SO_CREDITUSED when Invoices are being processed
      if(v_bpCurrency_id <> v_Currency_id) THEN
        SELECT COUNT(*)
        INTO v_Count
        FROM C_Conversion_Rate_Document
        WHERE C_Invoice_ID = P_RECORD_ID
        AND C_Currency_ID = v_Currency_id
        AND C_Currency_Id_To = v_bpCurrency_id;

        IF v_Count >0 THEN
          SELECT RATE*COALESCE(V_OutstandingAmount, 0) * v_creditmultiplier
          INTO v_ConvertedAmount
          FROM C_Conversion_Rate_Document
          WHERE C_Invoice_ID = P_RECORD_ID
          AND C_Currency_ID = v_Currency_id
          AND C_Currency_Id_To = v_bpCurrency_id;        
        ELSE
          v_ConvertedAmount := C_Currency_Convert((COALESCE(V_OutstandingAmount, 0) * v_creditmultiplier), v_Currency_id, v_bpCurrency_id, v_DateInvoiced,'S', v_Client_ID, v_Org_ID);
        END IF;
      else
        v_ConvertedAmount := COALESCE(V_OutstandingAmount, 0) * v_creditmultiplier;
      end if;
      UPDATE C_BPARTNER
      SET SO_CREDITUSED = COALESCE(SO_CREDITUSED,0) + v_ConvertedAmount
      WHERE C_BPARTNER_ID = v_BPartner_ID;

      -- Automatic creation of payment and financial transaction
      SELECT CASE WHEN v_IsSOTrx='Y' THEN c_bpartner.FIN_FINANCIAL_ACCOUNT_ID ELSE C_BPARTNER.PO_FINANCIAL_ACCOUNT_ID END,
             CASE WHEN v_IsSOTrx='Y' THEN facustomer.ad_org_id ELSE favendor.ad_org_id END
        INTO v_Financial_Account_ID, v_Financial_Account_Org
      FROM c_bpartner LEFT JOIN FIN_FINANCIAL_ACCOUNT facustomer ON (c_bpartner.fin_financial_account_id = facustomer.fin_financial_account_id)
                      LEFT JOIN FIN_FINANCIAL_ACCOUNT favendor ON (c_bpartner.po_financial_account_id = favendor.fin_financial_account_id)
      WHERE c_bpartner.c_bpartner_id = v_BPartner_ID;
      
      -- Organization of the financial account must be in the natural organization tree of the invoice org.
      IF (v_Financial_Account_ID IS NOT NULL AND
          (AD_ISORGINCLUDED(v_Financial_Account_Org, v_Org_ID, v_Client_ID) <> -1 OR AD_ISORGINCLUDED(v_Org_ID, v_Financial_Account_Org, v_Client_ID) <> -1)) THEN
        SELECT MIN(em_aprm_payment_desc) INTO v_payment_desc
        FROM ad_orginfo
        WHERE ad_org_id = v_Org_ID
        AND isactive = 'Y';
        
        IF (v_payment_desc IS NOT NULL AND v_payment_desc='Supplier Reference' 
            AND v_IsSOTrx ='N' AND coalesce(length(v_poreference), 0)>0) THEN
          v_documentno := v_poreference;
        END IF;
        
        FOR cur_paymentschedule IN (
            SELECT ps.fin_paymentmethod_id, ps.duedate, ps.c_currency_id, ps.ad_org_id, ps.fin_payment_schedule_id,
              coalesce(sum(psd.amount),0) as outstandingamt
            FROM fin_payment_schedule ps
              INNER JOIN fin_payment_scheduledetail psd ON ps.fin_payment_schedule_id = psd.fin_payment_schedule_invoice
                                                           AND psd.fin_payment_detail_id is null
            WHERE ps.c_invoice_id = p_record_id
              AND ps.isactive = 'Y'
            GROUP BY ps.fin_paymentmethod_id, ps.duedate, ps.c_currency_id, ps.ad_org_id, ps.fin_payment_schedule_id
            ORDER BY ps.duedate, ps.fin_payment_schedule_id
          )
        LOOP
          -- Create FIN_Payment description
          SELECT ad_message_get2('InvoiceDocumentno', v_lang) INTO v_invoiceno_trl FROM DUAL;
          v_finpayment_desc:=v_invoiceno_trl || ': ' || v_documentno;          
          
          FOR cur_finaccpaymentmethod IN (
              SELECT CASE WHEN v_IsSOTrx='Y' THEN AUTOMATIC_RECEIPT ELSE AUTOMATIC_PAYMENT END AS CreatePayment,
                CASE WHEN v_IsSOTrx='Y' THEN AUTOMATIC_DEPOSIT ELSE AUTOMATIC_WITHDRAWN END AS CreateFinTransaction,
                CASE WHEN v_IsSOTrx='Y' THEN payin_execution_type ELSE payout_execution_type END AS ExecutionType,
                CASE WHEN v_IsSOTrx='Y' THEN payin_deferred ELSE payout_deferred END AS deferred,
                CASE WHEN v_IsSOTrx='Y' THEN payin_execution_process_id ELSE payout_execution_process_id END AS execution_process_id,
                CASE WHEN v_IsSoTrx='Y' THEN Payin_IsMulticurrency ELSE Payout_IsMulticurrency END AS multicurrency
              FROM FIN_FINACC_PAYMENTMETHOD
              WHERE FIN_FINACC_PAYMENTMETHOD.FIN_PAYMENTMETHOD_ID = cur_paymentschedule.FIN_PAYMENTMETHOD_ID
                AND FIN_FINACC_PAYMENTMETHOD.FIN_FINANCIAL_ACCOUNT_ID = v_Financial_Account_ID
                AND FIN_FINACC_PAYMENTMETHOD.ISACTIVE='Y'
            )
          LOOP
            -- Automatic creation of payment
            IF(cur_finaccpaymentmethod.CreatePayment = 'Y') THEN

              -- Do not add payment for the reversal invoice if the actual invoice is not paid
	      SELECT COUNT(*)
	      INTO v_Count
	      FROM C_Invoice_Reverse
	      WHERE C_Invoice_ID = p_record_id;

	      IF(v_Count <> 0) THEN
		SELECT COALESCE(ispaid, 'Y')
		INTO v_InvoicePaid
		FROM C_Invoice
		WHERE C_Invoice_ID IN (
			SELECT Reversed_C_Invoice_ID
			FROM C_Invoice_Reverse
			WHERE C_Invoice_Id = p_record_id
		);
		IF (v_InvoicePaid = 'N') THEN
		  RETURN;
		END IF;
	      END IF;

              v_ResultStr:='Generating FIN_PAYMENT';
              v_FIN_PAYMENT_ID := GET_UUID();
              v_PaymentDocType_ID := AD_GET_DOCTYPE(v_client_id, cur_paymentschedule.AD_ORG_ID, CASE WHEN v_IsSOTrx='Y' THEN 'ARR' ELSE 'APP' END);
              SELECT * INTO  v_PaymentDocumentNo FROM AD_Sequence_Doctype(v_PaymentDocType_ID, v_client_id, 'Y') ;
              IF (v_PaymentDocumentNo IS NULL) THEN
                SELECT * INTO  v_PaymentDocumentNo FROM AD_Sequence_Doc('DocumentNo_FIN_Payment', v_client_id, 'Y') ;
              END IF;

              --Gets the financial account currency
              SELECT C_Currency_ID 
              INTO v_finacct_currency 
              FROM FIN_Financial_Account 
              WHERE FIN_Financial_Account_id = v_Financial_Account_ID;

              --Gets the Price precision
              SELECT priceprecision 
              INTO v_PricePr 
              FROM C_CURRENCY 
              WHERE c_currency_id = v_finacct_currency;

              --Check for the exchange rate at document level and get the rate
              SELECT COUNT(rate)
              INTO v_count
              FROM C_Conversion_Rate_Document
              WHERE C_Invoice_ID = p_record_id
	      AND C_Currency_ID = cur_paymentschedule.C_CURRENCY_ID
	      AND C_Currency_ID_To = v_finacct_currency;
	      
              IF(v_count > 0) THEN
	        SELECT rate
	        INTO v_rate
	        FROM C_Conversion_Rate_Document
	        WHERE C_Invoice_ID = p_record_id
	        AND C_Currency_ID = cur_paymentschedule.C_CURRENCY_ID
	        AND C_Currency_ID_To = v_finacct_currency; 
	      ELSE
	        v_rate := 0;
	      END IF;
	      --The financial account currency and payment currency are different and the financial account is not configured to accept payment from different currency
	      IF (v_finacct_currency<>cur_paymentschedule.C_CURRENCY_ID AND cur_finaccpaymentmethod.multicurrency='N') THEN
	        RAISE EXCEPTION '%','@APRM_NoFinancialAccountDefined@'; --OBTG:-20000--
	      --The financial account currency and payment currency are different and the financial account is not configured to accept payment from different currency
	      --and there is no exchange rate defined at document level
              ELSIF (v_finacct_currency<>cur_paymentschedule.C_CURRENCY_ID AND cur_finaccpaymentmethod.multicurrency='Y' AND v_rate = 0) THEN
                v_rate := C_CURRENCY_RATE(cur_paymentschedule.C_CURRENCY_ID, v_finacct_currency, cur_paymentschedule.DUEDATE, NULL, v_client_id, cur_paymentschedule.AD_ORG_ID );
              --default exchange rate to 1
              ELSIF (v_rate = 0) THEN
                v_rate := 1;
              END IF;

              INSERT INTO fin_payment(
                fin_payment_id, ad_client_id, ad_org_id, created, createdby,
                updated, updatedby, isactive, isreceipt, c_bpartner_id, paymentdate,
                c_currency_id, amount, writeoffamt,
                finacc_txn_amount, finacc_txn_convert_rate, fin_paymentmethod_id, documentno,
                referenceno,
                status,
                processed, processing, posted, description,
                fin_financial_account_id, c_doctype_id, c_project_id, c_campaign_id, c_costcenter_id,
                c_activity_id, user1_id, user2_id, em_aprm_process_payment, em_aprm_reconcile_payment,
                em_aprm_add_scheduledpayments)
              VALUES (v_FIN_PAYMENT_ID, v_client_id, cur_paymentschedule.AD_ORG_ID, TO_DATE(NOW()), p_user,
                TO_DATE(NOW()), p_user, 'Y', v_IsSOTrx, v_bpartner_id, cur_paymentschedule.DUEDATE,
                cur_paymentschedule.C_CURRENCY_ID, COALESCE(cur_paymentschedule.OUTSTANDINGAMT,0), 0,
                ROUND(COALESCE(cur_paymentschedule.OUTSTANDINGAMT,0)*v_rate, v_PricePr), v_rate, cur_paymentschedule.FIN_PAYMENTMETHOD_ID, v_PaymentDocumentNo,
                '',
                CASE
                  WHEN cur_finaccpaymentmethod.ExecutionType = 'A' THEN 'RPAE'
                  WHEN v_IsSOTrx = 'Y' THEN 'RPR'
                  ELSE 'PPM'
                END,
                'N', 'N', 'N', v_finpayment_desc,
                v_Financial_Account_ID, v_PaymentDocType_ID, v_project_id, v_campaign_id, v_costcenter,
                v_activity_id, v_user1, v_user2, 'N', 'N', 'N');

              v_description_first := TRUE;
              
              -- link to the new payment all the pending payment schedule details
              FOR cur_linktopayment_scheddetails IN (
                   SELECT FIN_PAYMENT_SCHEDULEDETAIL_ID, AMOUNT
                   FROM FIN_PAYMENT_SCHEDULEDETAIL
                   WHERE FIN_PAYMENT_SCHEDULE_INVOICE = cur_paymentschedule.FIN_PAYMENT_SCHEDULE_ID
                   AND FIN_PAYMENT_DETAIL_ID IS NULL
                   )
              LOOP
                v_FIN_PAYMENT_DETAIL_ID := GET_UUID();
                INSERT INTO fin_payment_detail(
                  fin_payment_detail_id, ad_client_id, ad_org_id, created, createdby,
                  updated, updatedby, fin_payment_id, amount, refund, isactive,
                  writeoffamt, c_glitem_id, isprepayment)
                VALUES (v_FIN_PAYMENT_DETAIL_ID, v_client_id, cur_paymentschedule.AD_ORG_ID, TO_DATE(NOW()), p_user,
                  TO_DATE(NOW()), p_user, v_FIN_PAYMENT_ID, cur_linktopayment_scheddetails.AMOUNT, 'N', 'Y',
                  0, NULL, 'N');

                UPDATE FIN_PAYMENT_SCHEDULEDETAIL
                SET FIN_PAYMENT_DETAIL_ID = v_FIN_PAYMENT_DETAIL_ID
                WHERE FIN_PAYMENT_SCHEDULEDETAIL_ID = cur_linktopayment_scheddetails.FIN_PAYMENT_SCHEDULEDETAIL_ID
                  AND FIN_PAYMENT_DETAIL_ID IS NULL;
                  
                -- Create C_InvoiceTax_CashVAT records
	      IF (v_IsCashVAT = 'Y') THEN
                v_PercentageCashVAT := c_currency_round(cur_linktopayment_scheddetails.AMOUNT * 100 / v_GrandTotal, v_Currency_ID, null);
                FOR cur_cinvoicetax IN (
                  SELECT it.C_InvoiceTax_ID, it.taxamt, it.taxbaseamt
                  FROM C_InvoiceTax it INNER JOIN C_Tax t on (it.c_tax_id = t.c_tax_id)
                  WHERE it.c_invoice_id = p_record_id
                  AND t.isCashVAT='Y'
                )
                LOOP
                  INSERT INTO c_invoicetax_cashvat(
                        c_invoicetax_cashvat_id, ad_client_id, ad_org_id, isactive, created,
                        createdby, updated, updatedby, c_invoicetax_id, percentage, taxamt,
                        taxbaseamt, fin_payment_detail_id)
                        VALUES (get_uuid(), v_Client_ID, v_Org_ID, 'Y', TO_DATE(NOW()),
                        p_user, TO_DATE(NOW()), p_user, cur_cinvoicetax.C_InvoiceTax_ID, v_PercentageCashVAT, c_currency_round(v_PercentageCashVAT * cur_cinvoicetax.taxamt / 100, v_Currency_ID, null),
                        c_currency_round(v_PercentageCashVAT * cur_cinvoicetax.taxbaseamt / 100, v_Currency_ID, null), v_FIN_PAYMENT_DETAIL_ID);
                END LOOP;
	      END IF;
        
              END LOOP;

              --Fixes 14403 defect 
              -- Payment document id is added in success message when invoice is completed with auto receipt is checked
              v_Message:='@APRM_PaymentDocumentno@ ' || v_PaymentDocumentNo || ' @beenCreated@';
              UPDATE ad_ep_instance_para SET p_text= v_Message WHERE ad_ep_instance_id= p_ep_instance AND parametername LIKE 'Message';
              IF (cur_finaccpaymentmethod.deferred = 'N'
                  AND cur_finaccpaymentmethod.ExecutionType='A') THEN
                INSERT INTO aprm_pending_paymentinvoice (
                  aprm_pending_paymentinvoice_id, ad_client_id, ad_org_id, isactive,
                  created, createdby, updated, updatedby,
                  processing, fin_payment_id, c_invoice_id, fin_pay_exec_process_id
                ) VALUES (
                  get_uuid(), v_client_id, v_org_id, 'Y',
                  TO_DATE(NOW()), p_user, TO_DATE(NOW()), p_user,
                  'N', v_fin_payment_id, p_record_id, cur_finaccpaymentmethod.execution_process_id);
              END IF;
              
              UPDATE FIN_PAYMENT
              SET PROCESSED = 'Y',
                  EM_APRM_PROCESS_PAYMENT = 'R'
              WHERE FIN_PAYMENT_ID = v_FIN_PAYMENT_ID;

                           FOR cur_update_scheddetails IN (
                SELECT fin_payment_scheduledetail_id
                FROM fin_payment_schedule ps
                INNER JOIN fin_payment_scheduledetail psd 
                ON ps.fin_payment_schedule_id = psd.fin_payment_schedule_invoice                                                    
                WHERE ps.c_invoice_id =p_record_id
              )
              LOOP
              UPDATE FIN_PAYMENT_SCHEDULEDETAIL
              SET isinvoicepaid=(select CASE WHEN fpsd.fin_payment_detail_id is null then 'N'
                  WHEN ((aprm_seqnumberpaymentstatus(fp.status))>= (aprm_seqnumberpaymentstatus((CASE WHEN fp.isreceipt='Y' 
                  THEN Payin_Invoicepaidstatus ELSE Payout_Invoicepaidstatus END)))) THEN 'Y' ELSE 'N' END
                  from fin_payment_scheduledetail fpsd
                  left join fin_payment_detail fpd on fpsd.fin_payment_detail_id=fpd.fin_payment_detail_id
                  left join fin_payment fp on fpd.fin_payment_id=fp.fin_payment_id
                  left join fin_financial_account fa on fa.fin_financial_account_id=fp.fin_financial_account_id 
                  left join FIN_FinAcc_PaymentMethod fpm on fpm.fin_financial_account_id=fp.fin_financial_account_id 
                 and fpm.fin_paymentmethod_id=fp.fin_paymentmethod_id WHERE fin_payment_scheduledetail_id = cur_update_scheddetails.fin_payment_scheduledetail_id) 
                 WHERE FIN_PAYMENT_SCHEDULEDETAIL_ID = cur_update_scheddetails.fin_payment_scheduledetail_id;
              END LOOP;

              -- Update payment schedule amounts and payment monitor in case that the payment is not left in awaiting
              -- execution status.
              FOR cur_PaymentScheduleOrder IN (
                SELECT FIN_PAYMENT_SCHEDULE_ORDER
                FROM FIN_PAYMENT_SCHEDULEDETAIL
                WHERE FIN_PAYMENT_SCHEDULE_INVOICE = cur_paymentschedule.FIN_PAYMENT_SCHEDULE_ID
                  AND FIN_PAYMENT_SCHEDULE_ORDER IS NOT NULL
                GROUP BY FIN_PAYMENT_SCHEDULE_ORDER
                ) LOOP
                SELECT MIN(o.DocumentNo) INTO v_orderno
                FROM fin_payment_schedule ps INNER JOIN c_order o ON (o.C_Order_ID = ps.C_Order_ID)
                WHERE fin_payment_schedule_id=cur_PaymentScheduleOrder.FIN_PAYMENT_SCHEDULE_ORDER;
                IF (v_orderno IS NOT NULL) THEN
                  IF (v_description_first) THEN
                    v_finpayment_desc:=v_finpayment_desc || chr(13);
                    SELECT ad_message_get2('OrderDocumentno', v_lang) INTO v_orderno_trl FROM DUAL;
                    v_finpayment_desc:=v_finpayment_desc || v_orderno_trl || ': ' || v_orderno;
                    v_description_first := FALSE;
                  ELSE
                    v_finpayment_desc:=v_finpayment_desc || ', ' || v_orderno;
                  END IF;
                END IF;
                
                IF (cur_finaccpaymentmethod.ExecutionType<>'A') THEN
                  UPDATE FIN_PAYMENT_SCHEDULE
                  SET PAIDAMT = (SELECT COALESCE(sum(amount + COALESCE(writeoffamt, 0)), 0)
                                 FROM fin_payment_scheduledetail
                                 WHERE fin_payment_schedule_order=cur_PaymentScheduleOrder.FIN_PAYMENT_SCHEDULE_ORDER AND
                                       fin_payment_detail_id is not null AND
                                       exists (SELECT 1
                                               FROM fin_payment, fin_payment_detail
                                               WHERE fin_payment.fin_payment_id = fin_payment_detail.fin_payment_id
                                                      and fin_payment.processed='Y' 
                                                      and fin_payment_scheduledetail.isinvoicepaid='Y'
                                                      and fin_payment_detail.fin_payment_detail_id = fin_payment_scheduledetail.fin_payment_detail_id)),
                      OUTSTANDINGAMT = (SELECT COALESCE(sum(amount), 0)
                                        FROM fin_payment_scheduledetail
                                        WHERE fin_payment_schedule_order=cur_PaymentScheduleOrder.FIN_PAYMENT_SCHEDULE_ORDER AND
                                        (fin_payment_detail_id is null OR isinvoicepaid='N'))

                  WHERE FIN_PAYMENT_SCHEDULE_ID = cur_PaymentScheduleOrder.FIN_PAYMENT_SCHEDULE_ORDER;
                END IF;
              END LOOP;
              IF (length(v_finpayment_desc) > 255) THEN
                SELECT SUBSTR(v_finpayment_desc, 1, 252) || '...' INTO v_finpayment_desc FROM DUAL;
              END IF;
              UPDATE FIN_PAYMENT SET DESCRIPTION = v_finpayment_desc
                WHERE FIN_PAYMENT_ID = v_FIN_PAYMENT_ID;

	      SELECT count(*) INTO v_count
	      FROM fin_payment_schedule fps
	      WHERE exists(select 1
			   from fin_payment_scheduledetail fpsd
		           where fps.fin_payment_schedule_id = fpsd.fin_payment_schedule_invoice
		           and fpsd.isinvoicepaid='N')
              AND FIN_PAYMENT_SCHEDULE_ID = cur_paymentschedule.FIN_PAYMENT_SCHEDULE_ID;

              IF (cur_finaccpaymentmethod.ExecutionType<>'A' AND v_count = 0) THEN
                UPDATE FIN_PAYMENT_SCHEDULE
                SET PAIDAMT = PAIDAMT + COALESCE(cur_paymentschedule.OUTSTANDINGAMT,0),
                    OUTSTANDINGAMT = OUTSTANDINGAMT - COALESCE(cur_paymentschedule.OUTSTANDINGAMT, 0)
                WHERE FIN_PAYMENT_SCHEDULE_ID = cur_paymentschedule.FIN_PAYMENT_SCHEDULE_ID;
                -- Getting DueAmount from FIN_PAYMENT_SCHEDULE for the Invoice
                SELECT coalesce(sum(OUTSTANDINGAMT),0) as DueAmount
                INTO V_DueAmount
                FROM FIN_PAYMENT_SCHEDULE
                WHERE C_INVOICE_ID=P_RECORD_ID
                AND duedate<=TO_DATE(NOW());
                UPDATE C_INVOICE
                SET TOTALPAID = TOTALPAID + COALESCE(cur_paymentschedule.OUTSTANDINGAMT, 0),
                    OUTSTANDINGAMT = OUTSTANDINGAMT - COALESCE(cur_paymentschedule.OUTSTANDINGAMT, 0),
                    DUEAMT = V_DueAmount, 
                    FINALSETTLEMENT = cur_paymentschedule.duedate,
                    DAYSOUTSTANDING = 0,
                    PERCENTAGEOVERDUE = 0
                WHERE C_INVOICE_ID = P_RECORD_ID;
                UPDATE C_INVOICE
                SET ISPAID = 'Y'
                WHERE C_INVOICE_ID = P_RECORD_ID
                  AND TOTALPAID = GRANDTOTAL;
                -- Updating SO_CREDITUSED when PAYMENT OCCUR and is not set in RPAE status
                if (v_bpCurrency_id <> v_Currency_id) then
                  SELECT COUNT(*)
                  INTO v_Count
                  FROM C_Conversion_Rate_Document
                  WHERE C_Invoice_ID = P_RECORD_ID
                  AND C_Currency_ID = v_Currency_id
                  AND C_Currency_Id_To = v_bpCurrency_id;

                  IF v_Count >0 THEN
                    SELECT RATE*(COALESCE(cur_paymentschedule.OUTSTANDINGAMT, 0) * v_creditmultiplier)
                    INTO v_ConvertedAmount
                    FROM C_Conversion_Rate_Document
                    WHERE C_Invoice_ID = P_RECORD_ID
                    AND C_Currency_ID = v_Currency_id
                    AND C_Currency_Id_To = v_bpCurrency_id;
                  ELSE
                    v_ConvertedAmount := C_Currency_Convert((COALESCE(cur_paymentschedule.OUTSTANDINGAMT, 0) * v_creditmultiplier), v_Currency_id, v_bpCurrency_id, v_DateInvoiced,'S', v_Client_ID, v_Org_ID);
                  END IF;  
                else
                  v_ConvertedAmount := (COALESCE(cur_paymentschedule.OUTSTANDINGAMT, 0) * v_creditmultiplier);
                end if;
                UPDATE C_BPARTNER
                SET SO_CREDITUSED = COALESCE(SO_CREDITUSED,0) - v_ConvertedAmount
                WHERE C_BPARTNER_ID = v_BPartner_ID;
              END IF;
              -- Automatic creation of financial transaction
              IF(cur_finaccpaymentmethod.CreateFinTransaction = 'Y' AND cur_finaccpaymentmethod.ExecutionType = 'M') THEN
                v_ResultStr:='Generating FIN_FINACC_TRANSACTION';
                v_FIN_FINACC_TRANSACTION_ID := GET_UUID();
                SELECT COALESCE(MAX(LINE),0) INTO v_Line FROM FIN_FINACC_TRANSACTION WHERE FIN_FINANCIAL_ACCOUNT_ID = v_Financial_Account_ID;
		IF (v_IsSOTrx='Y') THEN
		 IF (cur_paymentschedule.OUTSTANDINGAMT>0) THEN v_depositamt:=cur_paymentschedule.OUTSTANDINGAMT; 
		 ELSE v_paymentamt:=abs(cur_paymentschedule.OUTSTANDINGAMT); 
		 END IF;				
		ELSE
		 IF (cur_paymentschedule.OUTSTANDINGAMT<0) THEN v_depositamt:=abs(cur_paymentschedule.OUTSTANDINGAMT); 
		 ELSE  v_paymentamt:=cur_paymentschedule.OUTSTANDINGAMT; END IF;			
		END IF;

		IF (v_paymentamt> 0) THEN
		 v_transactiontype:='BPW';
		ELSE
		 v_transactiontype:='BPD';
		END IF;                 
               --check the currency of the invoice and the currency of the financial account
                select c_currency_id into v_finacct_currency from FIN_Financial_Account where FIN_Financial_Account_id =v_Financial_Account_ID;
                IF (v_finacct_currency<>cur_paymentschedule.C_CURRENCY_ID AND cur_finaccpaymentmethod.multicurrency='Y') THEN
                  v_rate := C_CURRENCY_RATE(cur_paymentschedule.C_CURRENCY_ID, v_finacct_currency, cur_paymentschedule.DUEDATE, NULL, v_client_id, cur_paymentschedule.AD_ORG_ID );
                  SELECT priceprecision into v_PricePr from C_CURRENCY where c_currency_id = v_finacct_currency;
                  INSERT INTO fin_finacc_transaction(
                    fin_finacc_transaction_id, ad_client_id, ad_org_id, created,
                    createdby, updated, updatedby, isactive, c_currency_id, fin_financial_account_id,
                    line, fin_payment_id, dateacct, c_glitem_id, status, paymentamt,
                    depositamt, processed, processing, posted, c_project_id, c_campaign_id, c_costcenter_id,
                    c_activity_id, user1_id, user2_id, trxtype, statementdate, description,
                    fin_reconciliation_id, foreign_currency_id, foreign_convert_rate, foreign_amount, c_bpartner_id)
                  VALUES (v_FIN_FINACC_TRANSACTION_ID, v_client_id, cur_paymentschedule.AD_ORG_ID, TO_DATE(NOW()), p_user,
                    TO_DATE(NOW()), p_user, 'Y', v_finacct_currency, v_Financial_Account_ID,
                    v_Line, v_FIN_PAYMENT_ID, cur_paymentschedule.DUEDATE, NULL, CASE WHEN v_IsSOTrx='Y' THEN 'RDNC' ELSE 'PWNC' END, ROUND(v_paymentamt*v_rate, v_PricePr) , ROUND(v_depositamt*v_rate, v_PricePr) ,
                   'Y', 'N', 'N', v_project_id, v_campaign_id, v_costcenter,
                    v_activity_id, v_user1, v_user2, v_transactiontype , cur_paymentschedule.DUEDATE, 'Invoice No.: ' || v_documentno,
                    NULL, cur_paymentschedule.C_CURRENCY_ID, v_rate , CASE WHEN v_IsSOTrx='N' THEN cur_paymentschedule.OUTSTANDINGAMT ELSE cur_paymentschedule.OUTSTANDINGAMT END, v_BPartner_ID);
                ELSE
                  INSERT INTO fin_finacc_transaction(
                    fin_finacc_transaction_id, ad_client_id, ad_org_id, created,
                    createdby, updated, updatedby, isactive, c_currency_id, fin_financial_account_id,
                    line, fin_payment_id, dateacct, c_glitem_id, status, paymentamt,
                    depositamt, processed, processing, posted, c_project_id, c_campaign_id, c_costcenter_id,
                    c_activity_id, user1_id, user2_id, trxtype, statementdate, description,
                    fin_reconciliation_id, c_bpartner_id)
                  VALUES (v_FIN_FINACC_TRANSACTION_ID, v_client_id, cur_paymentschedule.AD_ORG_ID, TO_DATE(NOW()), p_user,
                    TO_DATE(NOW()), p_user, 'Y', cur_paymentschedule.C_CURRENCY_ID, v_Financial_Account_ID,
                    v_Line, v_FIN_PAYMENT_ID, cur_paymentschedule.DUEDATE, NULL, CASE WHEN v_IsSOTrx='Y' THEN 'RDNC' ELSE 'PWNC' END,v_paymentamt, v_depositamt,
                    'Y', 'N', 'N', v_project_id, v_campaign_id, v_costcenter,
                    v_activity_id, v_user1, v_user2, v_transactiontype , cur_paymentschedule.DUEDATE, 'Invoice No.: ' || v_documentno,
                    NULL, v_BPartner_ID);
                END IF;
                
                
                UPDATE FIN_PAYMENT SET STATUS = CASE WHEN v_IsSOTrx='Y' THEN 'RDNC' ELSE 'PWNC' END
                  WHERE FIN_PAYMENT_ID = v_FIN_PAYMENT_ID;
                  --UPDATE FINANCIAL ACCOUNT CURRENT BALANCE
                  UPDATE FIN_FINANCIAL_ACCOUNT SET CURRENTBALANCE=CURRENTBALANCE + (CASE WHEN v_IsSOTrx='Y' THEN cur_paymentschedule.OUTSTANDINGAMT ELSE (cur_paymentschedule.OUTSTANDINGAMT*-1) END)
                  WHERE FIN_FINANCIAL_ACCOUNT_ID = v_Financial_Account_ID;
              END IF;
            END IF;
          END LOOP;
        END LOOP;
      END IF;
    END;

  ELSIF (p_docaction = 'RE') THEN
    DECLARE
      v_count NUMERIC;
      v_documentno VARCHAR(40); --OBTG:VARCHAR2--
      v_PaymentPlanExpectedTotal NUMERIC:= 0;
    BEGIN 
      SELECT count(*), max(p.documentno)
        INTO v_count, v_documentno
      FROM fin_payment_schedule ps, fin_payment_scheduledetail psd, fin_payment_detail pd, fin_payment p
      WHERE ps.fin_payment_schedule_id = psd.fin_payment_schedule_invoice
        AND ps.c_invoice_id = p_record_id
        AND psd.fin_payment_detail_id = pd.fin_payment_detail_id
        AND pd.fin_payment_id = p.fin_payment_id
        AND pd.isprepayment = 'N';
      IF (v_count <> 0) THEN
        RAISE EXCEPTION '%', '@APRM_InvoiceWithPayments@' || ' ' || v_documentno; --OBTG:-20000--
      END IF;
      SELECT count(*), max(p.documentno)
        INTO v_count, v_documentno
      FROM fin_payment_schedule ps, fin_payment_scheduledetail psd, fin_payment_prop_detail pd, fin_payment_proposal p
      WHERE ps.fin_payment_schedule_id = psd.fin_payment_schedule_invoice
        AND ps.c_invoice_id = p_record_id
        AND psd.fin_payment_scheduledetail_id = pd.fin_payment_scheduledetail_id
        AND pd.fin_payment_proposal_id = p.fin_payment_proposal_id
        AND psd.fin_payment_detail_id is null;
      IF (v_count <> 0) THEN
        RAISE EXCEPTION '%', '@APRM_InvoiceWithUnprocessedProposal@' || ' ' || v_documentno; --OBTG:-20000--
      END IF;
      -- Doubtful Debt Validation
      SELECT COUNT(*), max(dd.documentno) INTO v_count, v_documentno
      FROM fin_payment_schedule ps join fin_doubtful_debt dd on (dd.fin_payment_schedule_id = ps.fin_payment_schedule_id)
            AND ps.c_invoice_id = p_record_id;
      IF (v_count <> 0) THEN
        RAISE EXCEPTION '%', '@APRM_InvoiceWithDoubtfulDebt@' || ' ' || v_documentno; --OBTG:-20000--
      END IF;
      
      v_delete_paymentplan := TRUE;

      -- Revert the bp used credit amount
      SELECT COALESCE(SUM(fin_payment_schedule.paidamt), 0), COALESCE(SUM(fin_payment_schedule.amount), 0)
      INTO v_PaidAmount, v_PaymentPlanExpectedTotal
      FROM FIN_PAYMENT_SCHEDULE
      WHERE FIN_PAYMENT_SCHEDULE.C_INVOICE_ID = p_record_id ;

      if v_bpCurrency_id <> v_Currency_id then
        SELECT COUNT(*)
        INTO v_Count
        FROM C_Conversion_Rate_Document
        WHERE C_Invoice_ID = P_RECORD_ID
        AND C_Currency_ID = v_Currency_id
        AND C_Currency_Id_To = v_bpCurrency_id;

        IF v_Count >0 THEN
          SELECT RATE*((v_PaymentPlanExpectedTotal - v_PaidAmount) * v_creditmultiplier)
          INTO v_ConvertedAmount
          FROM C_Conversion_Rate_Document
          WHERE C_Invoice_ID = P_RECORD_ID
          AND C_Currency_ID = v_Currency_id
          AND C_Currency_Id_To = v_bpCurrency_id;
        ELSE
          v_ConvertedAmount := C_Currency_Convert(((v_PaymentPlanExpectedTotal - v_PaidAmount) * v_creditmultiplier), v_Currency_id, v_bpCurrency_id, v_DateInvoiced,'S', v_Client_ID, v_Org_ID);
        END IF;  
      else
        v_ConvertedAmount := ((v_PaymentPlanExpectedTotal - v_PaidAmount) * v_creditmultiplier);
      END IF;
      UPDATE C_BPARTNER
         SET SO_CREDITUSED = COALESCE(SO_CREDITUSED,0) - v_convertedAmount
      WHERE C_BPARTNER_ID = v_BPartner_ID;
    END;

  ELSIF (p_docaction = 'RC') THEN 
    DECLARE
      v_count NUMERIC;
    BEGIN
      v_delete_paymentplan := TRUE;
      SELECT c_invoice_id INTO v_reversalinvoice_id
      FROM c_invoice_reverse
      WHERE reversed_c_invoice_id = p_record_id;
      SELECT count(*) INTO v_count
      FROM fin_payment_schedule ps, fin_payment_scheduledetail psd, fin_payment_detail pd, fin_payment p
      WHERE ps.fin_payment_schedule_id = psd.fin_payment_schedule_invoice
        AND ps.c_invoice_id = p_record_id
        AND psd.fin_payment_detail_id = pd.fin_payment_detail_id
        AND pd.fin_payment_id = p.fin_payment_id
        AND pd.isprepayment = 'N';
      IF (v_count <> 0) THEN
        v_delete_paymentplan := FALSE;
      END IF;
      SELECT count(*) INTO v_count
      FROM fin_payment_schedule ps, fin_payment_scheduledetail psd, fin_payment_prop_detail pd, fin_payment_proposal p
      WHERE ps.fin_payment_schedule_id = psd.fin_payment_schedule_invoice
        AND ps.c_invoice_id = p_record_id
        AND psd.fin_payment_scheduledetail_id = pd.fin_payment_scheduledetail_id
        AND pd.fin_payment_proposal_id = p.fin_payment_proposal_id
        AND psd.fin_payment_detail_id is null;
      IF (v_count <> 0) THEN
        v_delete_paymentplan := FALSE;
      END IF;
    END;
  END IF;

  IF (v_delete_paymentplan) THEN
    DECLARE
      v_payment_detail_old VARCHAR(32); --OBTG:VARCHAR2--
      v_payment_scheduledetail_old VARCHAR(32); --OBTG:VARCHAR2--
      cur_ps RECORD;
      cur_psd RECORD;
    BEGIN
      -- Delete schedule detail records that not belong to orders
      DELETE FROM fin_payment_scheduledetail
      WHERE fin_payment_schedule_invoice IN
          (SELECT fin_payment_schedule_id
           FROM fin_payment_schedule
           WHERE (c_invoice_id = p_record_id
                  OR
                  (v_reversalinvoice_id IS NOT NULL AND c_invoice_id = v_reversalinvoice_id)))
        AND fin_payment_schedule_order is null;

      FOR cur_ps IN (
        SELECT DISTINCT fin_payment_schedule_order
        FROM fin_payment_scheduledetail
        WHERE fin_payment_schedule_invoice IN
          (SELECT fin_payment_schedule_id
           FROM fin_payment_schedule
           WHERE (c_invoice_id = p_record_id
                  OR
                  (v_reversalinvoice_id IS NOT NULL AND c_invoice_id = v_reversalinvoice_id))))
        LOOP

        UPDATE fin_payment_scheduledetail
        SET fin_payment_schedule_invoice = null
        WHERE fin_payment_schedule_invoice IN
          (SELECT fin_payment_schedule_id
           FROM fin_payment_schedule
           WHERE (c_invoice_id = p_record_id
                  OR
                  (v_reversalinvoice_id IS NOT NULL AND c_invoice_id = v_reversalinvoice_id)))
          AND fin_payment_schedule_order = cur_ps.fin_payment_schedule_order;
        v_payment_detail_old := '-2';
        v_payment_scheduledetail_old := '-1';

        FOR cur_psd IN (SELECT fin_payment_scheduledetail_id, COALESCE(fin_payment_detail_id,'-1') as fin_payment_detail_id,
                               amount, writeoffamt
                        FROM fin_payment_scheduledetail
                        WHERE fin_payment_schedule_order = cur_ps.fin_payment_schedule_order
                        AND fin_payment_schedule_invoice IS NULL
                        ORDER BY fin_payment_detail_id, created)
          LOOP
          -- if there are more than one psd with same payment detail merge them.
          IF (cur_psd.fin_payment_detail_id = v_payment_detail_old) THEN
          
            UPDATE fin_payment_scheduledetail
            SET amount = amount + cur_psd.amount,
                writeoffamt = COALESCE(writeoffamt,0) + COALESCE(cur_psd.writeoffamt,0),
                updated = TO_DATE(NOW()),
                updatedby = p_user
            WHERE fin_payment_scheduledetail_id = v_payment_scheduledetail_old;
            DELETE FROM fin_payment_scheduledetail
            WHERE fin_payment_scheduledetail_id = cur_psd.fin_payment_scheduledetail_id;
          ELSE
            v_payment_detail_old := COALESCE(cur_psd.fin_payment_detail_id,'-1');
            v_payment_scheduledetail_old := cur_psd.fin_payment_scheduledetail_id;
          END IF;
        END LOOP;
      END LOOP;

      DELETE FROM fin_payment_schedule WHERE (c_invoice_id = p_record_id
                  OR
                  (v_reversalinvoice_id IS NOT NULL AND c_invoice_id = v_reversalinvoice_id));

    END;
  END IF;
          
  --update em_aprm_processinvoice column with docaction value
  UPDATE c_invoice
  SET em_aprm_processinvoice = docaction
  WHERE c_invoice_id = p_record_id;

EXCEPTION
WHEN OTHERS THEN
  RAISE NOTICE '%','APRM_GENERATE_PAYMENT_SCHEDULE exception: '|| v_ResultStr;
  RAISE EXCEPTION '%', SQLERRM;
END ; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION aprm_gen_paymentschedule_inv(character varying)
  OWNER TO tad;








--Trigger changes added on 25-Jun-2018 - For Schedule Delivery Date Changes

-- Function: c_order_chk_restrinctions_trg()

-- DROP FUNCTION c_order_chk_restrinctions_trg();

CREATE OR REPLACE FUNCTION c_order_chk_restrinctions_trg()
  RETURNS trigger AS
$BODY$ DECLARE 

v_n NUMERIC;
v_OrderLine_Offer_ID VARCHAR(32); --OBTG:VARCHAR2--
v_Price NUMERIC;
v_lineNo NUMERIC;
v_PriceNew NUMERIC;
v_amt NUMERIC;
v_DateNull TIMESTAMP := TO_DATE('01-01-1900','DD-MM-YYYY');

BEGIN
  IF AD_isTriggerEnabled()='N' THEN IF TG_OP = 'DELETE' THEN RETURN OLD; ELSE RETURN NEW; END IF; 
  END IF;

  IF TG_OP = 'UPDATE' THEN
    IF(OLD.Processed='Y' AND OLD.Docaction <> 'CL'
          AND(
               (COALESCE(OLD.C_BPartner_ID, '0') <> COALESCE(NEW.C_BPartner_ID, '0'))
               OR(COALESCE(OLD.DOCUMENTNO, '.') <> COALESCE(NEW.DOCUMENTNO, '.'))
               OR(COALESCE(OLD.C_DOCTYPE_ID, '0') <> COALESCE(NEW.C_DOCTYPE_ID, '0'))
               OR(COALESCE(OLD.C_DOCTYPETARGET_ID, '0') <> COALESCE(NEW.C_DOCTYPETARGET_ID, '0'))
               OR(COALESCE(OLD.DATEORDERED, v_DateNull) <> COALESCE(NEW.DATEORDERED, v_DateNull))
               OR(COALESCE(OLD.C_BPARTNER_LOCATION_ID, '0') <> COALESCE(NEW.C_BPARTNER_LOCATION_ID, '0'))
               OR(COALESCE(OLD.PAYMENTRULE, '.') <> COALESCE(NEW.PAYMENTRULE, '.'))
               OR(COALESCE(OLD.C_PAYMENTTERM_ID, '0') <> COALESCE(NEW.C_PAYMENTTERM_ID, '0'))
               OR(COALESCE(OLD.C_CHARGE_ID, '0') <> COALESCE(NEW.C_CHARGE_ID, '0'))
               OR(COALESCE(OLD.CHARGEAMT, 0) <> COALESCE(NEW.CHARGEAMT, 0))
               OR(COALESCE(OLD.TOTALLINES, 0) <> COALESCE(NEW.TOTALLINES, 0))
               OR(COALESCE(OLD.GRANDTOTAL, 0) <> COALESCE(NEW.GRANDTOTAL, 0))
	       -- CODE COMMENTED ON JUNE-25-2018 FOR MAKING SCHEDULE DELIVERY DATE EDITABLE
               -- OR(COALESCE(OLD.DATEPROMISED, v_DateNull) <> COALESCE(NEW.DATEPROMISED, v_DateNull))
               OR(COALESCE(OLD.BILLTO_ID, '0') <> COALESCE(NEW.BILLTO_ID, '0'))
               OR(COALESCE(OLD.DELIVERYRULE, '.') <> COALESCE(NEW.DELIVERYRULE, '.'))
               OR(COALESCE(OLD.M_PRICELIST_ID, '0') <> COALESCE(NEW.M_PRICELIST_ID, '0'))
               OR(COALESCE(OLD.AD_USER_ID, '0') <> COALESCE(NEW.AD_USER_ID, '0'))
               OR(COALESCE(OLD.AD_ORGTRX_ID, '0') <> COALESCE(NEW.AD_ORGTRX_ID, '0'))
               OR(COALESCE(OLD.M_WAREHOUSE_ID, '0') <> COALESCE(NEW.M_WAREHOUSE_ID, '0'))
               OR(COALESCE(OLD.DROPSHIP_USER_ID, '0') <> COALESCE(NEW.DROPSHIP_USER_ID, '0'))
               OR(COALESCE(OLD.DROPSHIP_BPARTNER_ID, '0') <> COALESCE(NEW.DROPSHIP_BPARTNER_ID, '0'))
               OR(COALESCE(OLD.DROPSHIP_LOCATION_ID, '0') <> COALESCE(NEW.DROPSHIP_LOCATION_ID, '0'))
               OR(COALESCE(OLD.DELIVERYVIARULE, '.') <> COALESCE(NEW.DELIVERYVIARULE, '.'))
               OR(COALESCE(OLD.PRIORITYRULE,'.') <> COALESCE(NEW.PRIORITYRULE, '.'))
               OR(COALESCE(old.AD_ORG_ID, '0') <> COALESCE(new.AD_ORG_ID, '0'))
               OR(COALESCE(old.AD_CLIENT_ID, '0') <> COALESCE(new.AD_CLIENT_ID, '0'))
          )
    )THEN
      RAISE EXCEPTION '%', '@20501@' ; --OBTG:-20000--
    END IF;
    IF(OLD.Posted='Y' AND
      ((COALESCE(OLD.DATEACCT, v_DateNull) <> COALESCE(NEW.DATEACCT, v_DateNull))
      OR(COALESCE(OLD.C_CAMPAIGN_ID, '0') <> COALESCE(NEW.C_CAMPAIGN_ID, '0'))
      OR(COALESCE(OLD.C_PROJECT_ID, '0') <> COALESCE(NEW.C_PROJECT_ID, '0'))
      OR(COALESCE(OLD.C_ACTIVITY_ID, '0') <> COALESCE(NEW.C_ACTIVITY_ID, '0'))
      OR(COALESCE(OLD.USER1_ID, '0') <> COALESCE(NEW.USER1_ID, '0'))
      OR(COALESCE(OLD.USER2_ID, '0') <> COALESCE(NEW.USER2_ID, '0'))
      OR(COALESCE(OLD.A_ASSET_ID, '0') <> COALESCE(NEW.A_ASSET_ID, '0')))) THEN
      RAISE EXCEPTION '%', '@20501@' ; --OBTG:-20000--
    END IF;
    IF (COALESCE(OLD.C_BPartner_ID, '0')!=COALESCE(NEW.C_BPartner_ID, '0')) OR (COALESCE(OLD.M_PriceList_ID,'0') != COALESCE(NEW.M_PriceList_ID,'0')) OR (COALESCE(old.C_Currency_ID, '0') != COALESCE(NEW.C_Currency_ID, '0')) THEN
      SELECT COUNT(*)
        INTO v_n
        FROM C_ORDERLINE
       WHERE C_Order_ID = NEW.C_Order_ID;

       IF v_n>0 THEN
         RAISE EXCEPTION '%', '@20502@' ; --OBTG:-20000--
       END IF;
     END IF;
  END IF;

  IF(TG_OP = 'DELETE') THEN
    IF OLD.Processed='Y' THEN
      RAISE EXCEPTION '%', '@20501@' ; --OBTG:-20000--
    END IF;
  END IF;
  IF(TG_OP = 'INSERT') THEN
    IF NEW.Processed='Y' THEN
      RAISE EXCEPTION '%', '@20501@' ; --OBTG:-20000--
    END IF;
  END IF;
IF TG_OP = 'DELETE' THEN RETURN OLD; ELSE RETURN NEW; END IF; 

END 

; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION c_order_chk_restrinctions_trg()
  OWNER TO tad;
--> Trigger c_order_chk_restrinctions_trg() Ends

/***********************************************************************************************
* Code Added/Modified On 17-July-2018
* Modified View Name : m_rm_receipt_pick_edit
* Modifications      : Made em_exs_user_qty Negative and View Should Show Only Item Products Types
*************************************************************************************************/
-- View: m_rm_receipt_pick_edit

-- DROP VIEW m_rm_receipt_pick_edit;

CREATE OR REPLACE VIEW m_rm_receipt_pick_edit AS 
 SELECT ol.c_orderline_id AS m_rm_receipt_pick_edit_id,
    ol.ad_client_id,
    COALESCE(iol.ad_org_id, ol.ad_org_id) AS ad_org_id,
    ol.isactive,
    ol.created,
    ol.createdby,
    COALESCE(iol.updated, ol.updated) AS updated,
    ol.updatedby,
    iol.m_inout_id,
        CASE
            WHEN iol.m_inoutline_id IS NOT NULL THEN 'Y'::text
            ELSE 'N'::text
        END AS ob_selected,
    ol.c_orderline_id,
    ol.m_product_id,
    ol.c_uom_id,
    ol.m_attributesetinstance_id,
    ol.qtyordered AS returned,
    (-1)::numeric * ol.qtyordered - ol.qtydelivered AS pendingqty,
    (-1)::numeric * iol.movementqty AS receivingqty,
    iol.m_condition_goods_id,
    iol.m_locator_id,
    o.documentno AS returnorderno,
    o.issotrx,
    ol.line,
    iol.m_inoutline_id,
    ol.em_exs_user_uom_id,
    ol.em_exs_user_qty * (-1)::numeric AS em_exs_user_qty
   FROM c_orderline ol
     JOIN c_order o ON o.c_order_id::text = ol.c_order_id::text
     JOIN m_product p ON ol.m_product_id::text = p.m_product_id::text
     JOIN c_doctype dt ON dt.c_doctype_id::text = o.c_doctypetarget_id::text AND dt.isreturn = 'Y'::bpchar
     LEFT JOIN ( SELECT il2.m_inoutline_id,
            il2.ad_client_id,
            il2.ad_org_id,
            il2.isactive,
            il2.created,
            il2.createdby,
            il2.updated,
            il2.updatedby,
            il2.line,
            il2.description,
            il2.m_inout_id,
            il2.c_orderline_id,
            il2.m_locator_id,
            il2.m_product_id,
            il2.c_uom_id,
            il2.movementqty,
            il2.isinvoiced,
            il2.m_attributesetinstance_id,
            il2.isdescription,
            il2.quantityorder,
            il2.m_product_uom_id,
            il2.m_condition_goods_id
           FROM m_inoutline il2
             JOIN m_inout i2 ON il2.m_inout_id::text = i2.m_inout_id::text AND i2.processed = 'N'::bpchar) iol ON iol.c_orderline_id::text = ol.c_orderline_id::text
  WHERE (ol.qtyordered - ol.qtydelivered) <> 0::numeric AND o.docstatus::text = 'CO'::text 
  AND p.ProductType IN('I');

ALTER TABLE m_rm_receipt_pick_edit
  OWNER TO tad;

/***********************************************************************************************
* Code Added/Modified On 10-Aug-2018
* Modified View Name : m_rm_shipment_pick_edit
* Modifications      : Chnages For Return To Vendor Shipment Pop up
*************************************************************************************************/

CREATE OR REPLACE VIEW m_rm_shipment_pick_edit AS 
 SELECT COALESCE(sd.m_storage_detail_id, ''::character varying)::text || ol.c_orderline_id::text AS m_rm_shipment_pick_edit_id, ol.ad_client_id, COALESCE(iol.ad_org_id, ol.ad_org_id) AS ad_org_id, ol.isactive, ol.createdby, ol.created, ol.updatedby, ol.updated, o.documentno AS returnorderno, ol.m_product_id, ol.m_attributesetinstance_id, ol.c_uom_id, (-1)::numeric * ol.qtyordered AS returned, (-1)::numeric * iol.movementqty AS movementqty, sd.m_locator_id, 
        CASE
            WHEN sd.m_locator_id IS NULL THEN (-1)::numeric * ol.qtyordered
            ELSE COALESCE(sd.qtyonhand, 0::numeric)
        END AS availableqty, (-1)::numeric * (ol.qtyordered - to_number(COALESCE(( SELECT to_char(sum(COALESCE(iol3.movementqty, 0::numeric))) AS sum
           FROM m_inoutline iol3
      JOIN m_inout io3 ON iol3.m_inout_id::text = io3.m_inout_id::text AND io3.processed = 'Y'::bpchar
     WHERE iol3.c_orderline_id::text = ol.c_orderline_id::text), '0'::character varying)::text)) AS pendingqty, iol.m_inout_id, 
        CASE
            WHEN iol.m_inout_id IS NOT NULL THEN 'Y'::text
            ELSE 'N'::text
        END AS ob_selected, ol.c_orderline_id, ol.line, iol.m_inoutline_id, p.isstocked, ol.em_exs_user_uom_id, ol.em_exs_user_qty, (-1)::numeric * (ol.em_exs_user_qty - to_number(COALESCE(( SELECT to_char(sum(COALESCE(iol3.em_exs_recvdqty, 0::numeric))) AS sum
           FROM m_inoutline iol3
      JOIN m_inout io3 ON iol3.m_inout_id::text = io3.m_inout_id::text AND io3.processed = 'Y'::bpchar
     WHERE iol3.c_orderline_id::text = ol.c_orderline_id::text), '0'::character varying)::text)) AS em_exs_pending
   FROM c_orderline ol
   JOIN c_order o ON o.c_order_id::text = ol.c_order_id::text AND o.processed = 'Y'::bpchar AND o.issotrx = 'N'::bpchar
   LEFT JOIN m_storage_detail sd ON sd.m_product_id::text = ol.m_product_id::text AND COALESCE(sd.m_attributesetinstance_id, '0'::character varying)::text = COALESCE(ol.m_attributesetinstance_id, '0'::character varying)::text AND sd.qtyonhand > 0::numeric
   LEFT JOIN m_locator l ON sd.m_locator_id::text = l.m_locator_id::text
   JOIN m_product p ON p.m_product_id::text = ol.m_product_id::text
   JOIN c_doctype dt ON o.c_doctypetarget_id::text = dt.c_doctype_id::text AND dt.isreturn = 'Y'::bpchar
   LEFT JOIN ( SELECT iol2.m_inoutline_id, iol2.em_exs_receiveduom_id, iol2.m_inout_id, iol2.movementqty, iol2.c_orderline_id, iol2.ad_org_id, iol2.m_locator_id
   FROM m_inoutline iol2
   JOIN m_inout io2 ON iol2.m_inout_id::text = io2.m_inout_id::text AND io2.processed = 'N'::bpchar) iol ON iol.c_orderline_id::text = ol.c_orderline_id::text AND iol.m_locator_id::text = sd.m_locator_id::text
  WHERE o.docstatus::text = 'CO'::text;

ALTER TABLE m_rm_shipment_pick_edit
  OWNER TO tad;



/***********************************************************************************************
* Code Added/Modified On 13-Feb-2019 by jhansi
* Modified Trigger Name : m_transaction_trg()
* Modifications      : Changes For Picking the Attribute set based on movement date
*************************************************************************************************/
-- Function: m_transaction_trg()

-- DROP FUNCTION m_transaction_trg();

CREATE OR REPLACE FUNCTION m_transaction_trg()
  RETURNS trigger AS
$BODY$ DECLARE 





/*************************************************************************
* The contents of this file are subject to the Openbravo  Public  License
* Version  1.1  (the  "License"),  being   the  Mozilla   Public  License
* Version 1.1  with a permitted attribution clause; you may not  use this
* file except in compliance with the License. You  may  obtain  a copy of
* the License at http://www.openbravo.com/legal/license.html
* Software distributed under the License  is  distributed  on  an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
* License for the specific  language  governing  rights  and  limitations
* under the License.
* The Original Code is Openbravo ERP.
* The Initial Developer of the Original Code is Openbravo SLU
* All portions are Copyright (C) 2001-2012 Openbravo SLU
* All Rights Reserved.
* Contributor(s):  ______________________________________.
************************************************************************/
  v_DATEINVENTORY TIMESTAMP;
  v_UOM_ID VARCHAR(32) ; --OBTG:VARCHAR2--
  v_ATTRIBUTESET_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_AttrSetValueType M_Product.AttrSetValueType%TYPE;
  v_Name M_Product.Name%TYPE;
  v_IsOneAtSetValReq M_Attributeset.Isoneattrsetvalrequired%TYPE;
  v_PRODUCTION_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_LINE NUMERIC;
  v_DateNull TIMESTAMP := TO_DATE('01-01-1900', 'DD-MM-YYYY');
  v_DocumentLineNo M_InventoryLine.line%TYPE;
  v_sv_count NUMERIC;
  v_warehouse VARCHAR(32);
  v_count NUMERIC;
  v_doIncrease BOOLEAN:= FALSE;
  v_doDecrease BOOLEAN:= FALSE;
  v_stockdiff NUMERIC:= 0;
BEGIN
    
    IF AD_isTriggerEnabled()='N' THEN IF TG_OP = 'DELETE' THEN RETURN OLD; ELSE RETURN NEW; END IF; 
    END IF;


  IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
    SELECT P.NAME, P.C_UOM_ID, P.M_ATTRIBUTESET_ID, A.ISONEATTRSETVALREQUIRED, P.ATTRSETVALUETYPE
    INTO v_name, v_UOM_ID, v_attributeset_id, v_IsOneAtSetValReq, v_AttrSetValueType 
    FROM M_PRODUCT P LEFT JOIN M_ATTRIBUTESET A
    ON A.M_ATTRIBUTESET_ID = P.M_ATTRIBUTESET_ID
    WHERE P.M_PRODUCT_ID=NEW.M_PRODUCT_ID;
    
		IF TG_OP = 'UPDATE' THEN
		  IF (COALESCE(old.m_transaction_id, '0') <> COALESCE(new.m_transaction_id, '0'))
    	OR(COALESCE(old.movementtype, '.') <> COALESCE(new.movementtype, '.'))
    	OR(COALESCE(old.m_locator_id, '0') <> COALESCE(new.m_locator_id, '0'))
    	OR(COALESCE(old.m_product_id, '0') <> COALESCE(new.m_product_id, '0'))
    	OR(COALESCE(old.movementdate, v_DateNull) <> COALESCE(new.movementdate, v_DateNull))
	    OR(COALESCE(old.movementqty, '0') <> COALESCE(new.movementqty, '0'))
	    OR(COALESCE(old.m_inventoryline_id, '0') <> COALESCE(new.m_inventoryline_id, '0'))
    	OR(COALESCE(old.m_movementline_id, '0') <> COALESCE(new.m_movementline_id, '0'))
    	OR(COALESCE(old.m_inoutline_id, '0') <> COALESCE(new.m_inoutline_id, '0'))
    	OR(COALESCE(old.m_productionline_id, '0') <> COALESCE(new.m_productionline_id, '0'))
    	OR(COALESCE(old.c_projectissue_id, '0') <> COALESCE(new.c_projectissue_id, '0'))
    	OR(COALESCE(old.m_attributesetinstance_id, '0') <> COALESCE(new.m_attributesetinstance_id, '0'))
    	OR(COALESCE(old.m_product_uom_id, '0') <> COALESCE(new.m_product_uom_id, '0'))
    	OR(COALESCE(old.quantityorder, '0') <> COALESCE(new.quantityorder, '0'))
    	OR(COALESCE(old.c_uom_id, '0') <> COALESCE(new.c_uom_id, '0'))
    	OR(COALESCE(old.m_internal_consumptionline_id ,'0') <> COALESCE(new.m_internal_consumptionline_id ,'0')) THEN

      	IF(COALESCE(v_UOM_ID, '0') <> COALESCE(NEW.C_UOM_ID, '0')) THEN
        	RAISE EXCEPTION '%', '@20111@' ; --OBTG:-20000--
      	END IF;
      	IF(v_attributeset_id IS NOT NULL AND (v_AttrSetValueType IS NULL OR v_AttrSetValueType <> 'F') AND v_IsOneAtSetValReq = 'Y' AND COALESCE(NEW.M_ATTRIBUTESETINSTANCE_ID, '0') = '0') THEN
        	RAISE EXCEPTION '%', '@20112@' || ' - ' || v_Name ; --OBTG:-20000--
      	END IF;
      	--Does not allow to change the attribute set value
      	-- for products which attribute set value type is Fixed
      	IF (NEW.M_PRODUCT_ID IS NOT NULL AND COALESCE(new.M_AttributeSetInstance_ID,'0')!='0') THEN
        	SELECT ATTRSETVALUETYPE 
          	INTO v_AttrSetValueType
        	FROM M_PRODUCT 
        	WHERE M_PRODUCT_ID=NEW.M_PRODUCT_ID;
        	IF (v_AttrSetValueType='F') THEN
          	RAISE EXCEPTION '%', '@AttrSetValueFixed@'; --OBTG:-20000--
        	END IF;
      	END IF;
      END IF;
    END IF;
    
		IF TG_OP = 'INSERT' THEN
			IF(COALESCE(v_UOM_ID, '0') <> COALESCE(NEW.C_UOM_ID, '0')) THEN
        IF (new.M_InventoryLine_ID IS NOT NULL) THEN
	  SELECT line INTO v_DocumentLineNo FROM M_InventoryLine WHERE M_InventoryLine_ID = new.M_InventoryLine_ID;
	END IF;
	IF (new.M_MovementLine_ID IS NOT NULL) THEN
	  SELECT line INTO v_DocumentLineNo FROM M_MovementLine WHERE M_MovementLine_ID = new.M_MovementLine_ID;
	END IF;
	IF (new.M_InOutLine_ID IS NOT NULL) THEN
	  SELECT line INTO v_DocumentLineNo FROM M_InOutLine WHERE M_InOutLine_ID = new.M_InOutLine_ID;
	END IF;
	IF (new.M_ProductionLine_ID IS NOT NULL) THEN
	  SELECT line INTO v_DocumentLineNo FROM M_ProductionLine WHERE M_ProductionLine_ID = new.M_ProductionLine_ID;
	END IF;
	IF (new.M_Internal_ConsumptionLine_ID IS NOT NULL) THEN
	  SELECT line INTO v_DocumentLineNo FROM M_Internal_ConsumptionLine WHERE M_Internal_ConsumptionLine_ID = new.M_Internal_ConsumptionLine_ID;
	END IF;
	  
	RAISE EXCEPTION '%', '@DocUOMMismatch@' || ' ' || COALESCE(v_DocumentLineNo, 0); --OBTG:-20000--
     	END IF;
      IF(v_attributeset_id IS NOT NULL AND (v_AttrSetValueType IS NULL OR v_AttrSetValueType <> 'F') AND v_IsOneAtSetValReq = 'Y' AND COALESCE(NEW.M_ATTRIBUTESETINSTANCE_ID, '0') = '0') THEN
       	RAISE EXCEPTION '%', '@20112@' || ' - ' || v_Name ; --OBTG:-20000--
     	END IF;
      --Does not allow to change the attribute set value
      -- for products which attribute set value type is Fixed
      IF (NEW.M_PRODUCT_ID IS NOT NULL AND COALESCE(new.M_AttributeSetInstance_ID,'0')!='0') THEN
       	SELECT ATTRSETVALUETYPE 
         	INTO v_AttrSetValueType
       	FROM M_PRODUCT 
        WHERE M_PRODUCT_ID=NEW.M_PRODUCT_ID;
       	IF (v_AttrSetValueType='F') THEN
         	RAISE EXCEPTION '%', '@AttrSetValueFixed@'; --OBTG:-20000--
       	END IF;
     	END IF;
		END IF;
  END IF;
  
  -- Updating inventory
  IF TG_OP = 'UPDATE' OR TG_OP = 'DELETE' THEN
    PERFORM M_UPDATE_INVENTORY(OLD.AD_CLIENT_ID, OLD.AD_ORG_ID, OLD.UPDATEDBY, OLD.M_PRODUCT_ID, OLD.M_LOCATOR_ID, OLD.M_ATTRIBUTESETINSTANCE_ID, 
    OLD.C_UOM_ID, OLD.M_PRODUCT_UOM_ID, -OLD.MOVEMENTQTY, -OLD.QUANTITYORDER, NULL, OLD.MOVEMENTQTY, OLD.QUANTITYORDER, OLD.movementdate, OLD.MovementType) ;
    -- FIXME: this shall be removed/reviewed when new warehouse management is implemented
    IF (OLD.M_PRODUCTIONLINE_ID IS NOT NULL) THEN     
	    SELECT M_PRODUCTIONPLAN.M_PRODUCTION_ID , M_PRODUCTIONPLAN.LINE
	    INTO v_PRODUCTION_ID, v_LINE
	    FROM M_PRODUCTIONPLAN, M_PRODUCTIONLINE
	    WHERE M_PRODUCTIONPLAN.M_PRODUCTIONPLAN_ID = M_PRODUCTIONLINE.M_PRODUCTIONPLAN_ID
	    AND M_PRODUCTIONLINE_ID = OLD.M_PRODUCTIONLINE_ID;
	    PERFORM M_UPDATE_STOCKAUX(OLD.AD_CLIENT_ID, OLD.AD_ORG_ID, OLD.UPDATEDBY, OLD.M_PRODUCT_ID, OLD.M_LOCATOR_ID, OLD.M_ATTRIBUTESETINSTANCE_ID, OLD.C_UOM_ID, OLD.M_PRODUCT_UOM_ID, OLD.MOVEMENTQTY, OLD.QUANTITYORDER, v_PRODUCTION_ID,'325', v_LINE) ;
    END IF;
    -- END FIXME
  END IF;
  IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
    SELECT MAX(MOVEMENTDATE)
      INTO v_DATEINVENTORY
    FROM M_INVENTORY I,
      M_INVENTORYLINE IL
    WHERE I.M_INVENTORY_ID=IL.M_INVENTORY_ID
      AND IL.M_INVENTORYLINE_ID=NEW.M_INVENTORYLINE_ID;
        
    PERFORM M_UPDATE_INVENTORY(NEW.AD_CLIENT_ID, NEW.AD_ORG_ID, NEW.UPDATEDBY, NEW.M_PRODUCT_ID, NEW.M_LOCATOR_ID, NEW.M_ATTRIBUTESETINSTANCE_ID, 
    NEW.C_UOM_ID, NEW.M_PRODUCT_UOM_ID, NEW.MOVEMENTQTY, NEW.QUANTITYORDER, v_DATEINVENTORY, -NEW.MOVEMENTQTY, -NEW.QUANTITYORDER, NEW.movementdate, NEW.MovementType) ;
    -- FIXME: this shall be removed/reviewed when new warehouse management is implemented
    IF (NEW.M_PRODUCTIONLINE_ID IS NOT NULL) THEN    
	SELECT M_PRODUCTIONPLAN.M_PRODUCTION_ID , M_PRODUCTIONPLAN.LINE
	INTO v_PRODUCTION_ID, v_LINE
	FROM M_PRODUCTIONPLAN, M_PRODUCTIONLINE
	WHERE M_PRODUCTIONPLAN.M_PRODUCTIONPLAN_ID = M_PRODUCTIONLINE.M_PRODUCTIONPLAN_ID
	AND M_PRODUCTIONLINE_ID = NEW.M_PRODUCTIONLINE_ID;
 PERFORM M_UPDATE_STOCKAUX(NEW.AD_CLIENT_ID, NEW.AD_ORG_ID, NEW.UPDATEDBY, NEW.M_PRODUCT_ID, NEW.M_LOCATOR_ID, NEW.M_ATTRIBUTESETINSTANCE_ID, NEW.C_UOM_ID, NEW.M_PRODUCT_UOM_ID,-NEW.MOVEMENTQTY, -NEW.QUANTITYORDER, v_PRODUCTION_ID,'325', v_LINE) ;
    END IF;
    -- END FIXME
  END IF;

  --Update m_stock_valuation
  SELECT COUNT(*) INTO v_count
  FROM DUAL
  WHERE EXISTS (SELECT 1 FROM ad_preference
                WHERE property = 'UnitaryCost'
                  AND ad_client_id IN (NEW.ad_client_id, '0')
                  AND TO_CHAR(value) = 'Y');

  IF (v_count > 0) THEN
    IF (TG_OP = 'INSERT') THEN
      IF (NEW.iscostcalculated = 'Y') THEN
        v_doIncrease := TRUE;
      END IF;
    ELSIF (TG_OP = 'DELETE') THEN
      IF (OLD.iscostcalculated = 'Y') THEN
        v_doDecrease := TRUE;
      END IF;
    ELSIF (TG_OP = 'UPDATE') THEN
      IF (NEW.iscostcalculated = 'Y' AND OLD.iscostcalculated = 'N') THEN
        v_doIncrease := TRUE;
      END IF;
      IF (NEW.iscostcalculated = 'N' AND OLD.iscostcalculated = 'Y') THEN
        v_doDecrease := TRUE;
      END IF;
    END IF;
    IF (v_doIncrease) THEN
      v_stockdiff := NEW.movementqty;
      IF (v_stockdiff <> 0) THEN
        SELECT m_warehouse_id
          INTO v_warehouse
        FROM m_locator
        WHERE m_locator_id = NEW.m_locator_id;
  
        PERFORM M_UPDATE_STOCK_VALUATION(NEW.ad_client_id, ad_get_org_le_bu(NEW.ad_org_id,'LE'), NEW.createdby, v_warehouse, NEW.m_product_id, v_stockdiff, 0);
      END IF;
    END IF;
    IF (v_doDecrease) THEN
      v_stockdiff := - OLD.movementqty;
      IF (v_stockdiff <> 0) THEN
        SELECT m_warehouse_id
          INTO v_warehouse
        FROM m_locator
        WHERE m_locator_id = OLD.m_locator_id;
  
        PERFORM M_UPDATE_STOCK_VALUATION(OLD.ad_client_id, ad_get_org_le_bu(OLD.ad_org_id,'LE'), OLD.createdby, v_warehouse, OLD.m_product_id, v_stockdiff, 0);
      END IF;
    END IF;
  END IF;

IF TG_OP = 'DELETE' THEN RETURN OLD; ELSE RETURN NEW; END IF; 

END 

; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION m_transaction_trg()
  OWNER TO tad;




/***********************************************************************************************
* Code Added/Modified On 13-Feb-2019 by jhansi
* Modified Procedure Name : m_update_inventory
* Modifications      : Changes For Picking the Attribute set based on movement date
*************************************************************************************************/

-- Function: m_update_inventory(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, numeric, numeric, timestamp without time zone, numeric, numeric, timestamp without time zone)

-- DROP FUNCTION m_update_inventory(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, numeric, numeric, timestamp without time zone, numeric, numeric, timestamp without time zone);

CREATE OR REPLACE FUNCTION m_update_inventory(p_client character varying, p_org character varying, p_user character varying, p_product character varying, 
p_locator character varying, p_attributesetinstance character varying, p_uom character varying, p_product_uom character varying, p_qty numeric,
 p_qtyorder numeric, p_datelastinventory timestamp without time zone, p_preqty numeric, p_preqtyorder numeric, p_movementdate timestamp without time zone,
 p_movementtype character varying)
  RETURNS void AS
$BODY$ DECLARE 
/*************************************************************************
* The contents of this file are subject to the Openbravo  Public  License
* Version  1.1  (the  "License"),  being   the  Mozilla   Public  License
* Version 1.1  with a permitted attribution clause; you may not  use this
* file except in compliance with the License. You  may  obtain  a copy of
* the License at http://www.openbravo.com/legal/license.html
* Software distributed under the License  is  distributed  on  an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
* License for the specific  language  governing  rights  and  limitations
* under the License.
* The Original Code is Openbravo ERP.
* The Initial Developer of the Original Code is Openbravo SLU
* All portions are Copyright (C) 2001-2014 Openbravo SLU
* All Rights Reserved.
* Contributor(s):  ______________________________________.
************************************************************************/
  v_count NUMERIC;
  v_qtyorder NUMERIC;
  v_preqtyorder NUMERIC;
  v_Storage_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_attributesetinstance VARCHAR(32); --OBTG:VARCHAR2--
  v_movementdate timestamp;
  v_QTYONHAND NUMERIC;
  v_movementtype VARCHAR(60);
BEGIN
  v_qtyorder:=p_qtyorder;
  v_preqtyorder:=p_preqtyorder;
  v_attributesetinstance :=COALESCE(p_attributesetinstance,'0');
  v_movementdate:=p_movementdate;
  v_movementtype:=p_movementtype;
  SELECT count(1)
  INTO v_count
  FROM DUAL WHERE EXISTS(
  SELECT 1
  FROM M_STORAGE_DETAIL
  WHERE M_PRODUCT_ID=p_product
    AND M_LOCATOR_ID=p_locator
    AND M_ATTRIBUTESETINSTANCE_ID=v_attributesetinstance
    AND C_UOM_ID=p_uom
    AND COALESCE(M_PRODUCT_UOM_ID, '-1')=COALESCE(p_product_uom, '-1'));
  IF(p_product_uom IS NOT NULL) THEN
    IF(v_qtyorder IS NULL) THEN
      v_qtyorder:=0;
    END IF;
    IF(v_preqtyorder IS NULL) THEN
      v_preqtyorder:=0;
    END IF;
  END IF;
  IF(v_count = 0) THEN
    INSERT
    INTO M_STORAGE_DETAIL
      (
        M_Storage_Detail_ID, AD_CLIENT_ID, AD_ORG_ID, ISACTIVE,
        CREATED, CREATEDBY, UPDATED, UPDATEDBY,
        M_PRODUCT_ID, M_LOCATOR_ID, M_ATTRIBUTESETINSTANCE_ID, C_UOM_ID,
        M_PRODUCT_UOM_ID, QTYONHAND, QTYORDERONHAND, DATELASTINVENTORY,
        PREQTYONHAND, PREQTYORDERONHAND, em_exma_systemcreated
      )
      VALUES
      (
        get_uuid(), p_client, p_org, 'Y',
        --TO_DATE(NOW()), p_user, TO_DATE(NOW()), p_user,
        v_movementdate, p_user, TO_DATE(NOW()), p_user,
        p_product, p_locator, v_attributesetinstance, p_uom,
        p_product_uom, COALESCE(p_qty, 0), v_qtyorder, p_datelastinventory,
        COALESCE(p_preqty, 0), v_preqtyorder,TO_DATE(NOW())
      )
      ;
  ELSE
  --Added by jhansi for updating creation date
  select QTYONHAND into v_QTYONHAND from M_STORAGE_DETAIL where  M_PRODUCT_ID=p_product and M_LOCATOR_ID=p_locator and M_ATTRIBUTESETINSTANCE_ID=v_attributesetinstance and AD_ORG_ID = p_org;
IF (v_QTYONHAND = 0 AND v_movementtype = 'P+' ) THEN

UPDATE M_STORAGE_DETAIL
      SET QTYONHAND=QTYONHAND + COALESCE(p_qty, 0),
      QTYORDERONHAND=QTYORDERONHAND + v_qtyorder,
      DATELASTINVENTORY=COALESCE(p_datelastinventory, DATELASTINVENTORY),
      PREQTYONHAND=PREQTYONHAND + COALESCE(p_preqty, 0),
      PREQTYORDERONHAND=PREQTYORDERONHAND + v_preqtyorder,
      AD_CLIENT_ID=p_client,
      AD_ORG_ID=p_org,
      UPDATED=TO_DATE(NOW()),
      UPDATEDBY=p_user,
      CREATED = v_movementdate,
      em_exma_systemcreated = TO_DATE(NOW())
    WHERE M_PRODUCT_ID=p_product
      AND M_LOCATOR_ID=p_locator
      AND M_ATTRIBUTESETINSTANCE_ID=v_attributesetinstance
      AND C_UOM_ID=p_uom
      AND COALESCE(M_PRODUCT_UOM_ID, '-1')=COALESCE(p_product_uom, '-1') ;
ELSE
  --ended by jhansi
    UPDATE M_STORAGE_DETAIL
      SET QTYONHAND=QTYONHAND + COALESCE(p_qty, 0),
      QTYORDERONHAND=QTYORDERONHAND + v_qtyorder,
      DATELASTINVENTORY=COALESCE(p_datelastinventory, DATELASTINVENTORY),
      PREQTYONHAND=PREQTYONHAND + COALESCE(p_preqty, 0),
      PREQTYORDERONHAND=PREQTYORDERONHAND + v_preqtyorder,
      AD_CLIENT_ID=p_client,
      AD_ORG_ID=p_org,
      UPDATED=TO_DATE(NOW()),
      UPDATEDBY=p_user
    WHERE M_PRODUCT_ID=p_product
      AND M_LOCATOR_ID=p_locator
      AND M_ATTRIBUTESETINSTANCE_ID=v_attributesetinstance
      AND C_UOM_ID=p_uom
      AND COALESCE(M_PRODUCT_UOM_ID, '-1')=COALESCE(p_product_uom, '-1') ;

   END IF;--Closed by jhansi
   
    SELECT MAX(SD.M_STORAGE_DETAIL_ID) 
    INTO v_Storage_ID
    FROM m_product p join m_attributeset aset ON p.m_attributeset_id = aset.m_attributeset_id 
                     JOIN M_STORAGE_DETAIL SD ON SD.M_PRODUCT_ID=p.m_product_id
            AND SD.M_LOCATOR_ID=p_locator
            AND SD.M_ATTRIBUTESETINSTANCE_ID=v_attributesetinstance
            AND SD.C_UOM_ID=p_uom
            AND COALESCE(SD.M_PRODUCT_UOM_ID, '-1')=COALESCE(p_product_uom, '-1')
    WHERE COALESCE(p.attrsetvaluetype, '-') <> 'F'
    AND aset.isoneattrsetvalrequired = 'Y'
    AND QTYONHAND = 0
    AND (QTYORDERONHAND=0 OR QTYORDERONHAND IS NULL)
    AND PREQTYONHAND=0
    AND (PREQTYORDERONHAND=0 OR PREQTYORDERONHAND IS NULL)
    AND P.M_PRODUCT_ID=p_product
    AND NOT EXISTS (SELECT 1 FROM m_stock_aux WHERE M_STORAGE_DETAIL_ID = SD.M_STORAGE_DETAIL_ID)
    AND NOT EXISTS (SELECT 1 FROM m_stock_proposed WHERE M_STORAGE_DETAIL_ID = SD.M_STORAGE_DETAIL_ID);

    IF (v_Storage_ID IS NOT NULL) THEN    
      DELETE FROM M_STORAGE_DETAIL WHERE M_STORAGE_DETAIL_ID =v_Storage_ID;
    END IF;

  END IF;
END ; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION m_update_inventory(character varying, character varying, character varying, character varying, character varying, character varying, 
character varying, character varying, numeric, numeric, timestamp without time zone, numeric, numeric, timestamp without time zone, character varying)
  OWNER TO tad;

/***********************************************************************************************
* Code Added/Modified On 13-Feb-2019 by jhansi
* Modified Trigger Name : m_inoutline_trg()
* Modifications      : Changes For Picking the Attribute set based on movement date
*************************************************************************************************/
-- Function: m_inoutline_trg()

-- DROP FUNCTION m_inoutline_trg();

CREATE OR REPLACE FUNCTION m_inoutline_trg()
  RETURNS trigger AS
$BODY$ DECLARE 





  v_ID          VARCHAR(32); --OBTG:varchar2--
  v_RO    NUMERIC;
  v_movementtype  VARCHAR(2); --OBTG:VARCHAR2--
  v_qty    NUMERIC;
  v_qtyorder   NUMERIC;
  v_qtyold   NUMERIC;
  v_qtyorderold  NUMERIC;
  v_MatchInvCount  NUMERIC;
  v_STOCKED   NUMERIC;
  v_UOM_ID    VARCHAR(32); --OBTG:varchar2--
  v_AttrSetValueType M_Product.AttrSetValueType%TYPE;
  V_COUNT  NUMERIC;
  v_ISSOTRX CHAR(1);
  v_QTYVARIABLE CHAR(1);
  v_OrderProduct VARCHAR(32); --OBTG:VARCHAR2--
  v_IsUpdateDifferentProduct BOOLEAN;
  v_movementdate timestamp;
/******************************************************************************
 * The contents of this file are subject to the   Compiere License  Version 1.1
 * ("License"); You may not use this file except in compliance with the License
 * You may obtain a copy of the License at http://www.compiere.org/license.html
 * Software distributed under the License is distributed on an  "AS IS"  basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for
 * the specific language governing rights and limitations under the License.
 * The Original Code is                  Compiere  ERP &  Business Solution
 * The Initial Developer of the Original Code is Jorg Janke  and ComPiere, Inc.
 * Portions created by Jorg Janke are Copyright (C) 1999-2001 Jorg Janke, parts
 * created by ComPiere are Copyright (C) ComPiere, Inc.;   All Rights Reserved.
 * Contributor(s): Openbravo SLU
 * Contributions are Copyright (C) 2001-2013 Openbravo S.L.U.
 ******************************************************************************/
     
BEGIN
    
    IF AD_isTriggerEnabled()='N' THEN IF TG_OP = 'DELETE' THEN RETURN OLD; ELSE RETURN NEW; END IF; 
    END IF;
 IF (TG_OP = 'INSERT') THEN
  IF (NEW.M_PRODUCT_ID IS NOT NULL) THEN
     SELECT C_UOM_ID INTO v_UOM_ID FROM M_PRODUCT WHERE M_PRODUCT_ID=NEW.M_PRODUCT_ID;
     IF (COALESCE(v_UOM_ID,'0') <> COALESCE(NEW.C_UOM_ID,'0')) THEN
       IF (NEW.C_ORDERLINE_ID IS NOT NULL) THEN
         SELECT C_UOM_ID INTO v_UOM_ID FROM C_ORDERLINE WHERE C_ORDERLINE_ID = NEW.C_ORDERLINE_ID;
           IF (COALESCE(v_UOM_ID,'0') <> COALESCE(NEW.C_UOM_ID,'0')) THEN
             RAISE EXCEPTION '%', '@20111@'; --OBTG:-20000--
           END IF;
       ELSE
         RAISE EXCEPTION '%', '@20111@'; --OBTG:-20000--
       END IF;
     END IF;
  END IF;
 END IF;

 IF (TG_OP = 'UPDATE' OR TG_OP = 'INSERT') THEN
  v_ID := new.M_InOut_ID;

  SELECT MOVEMENTTYPE,MovementDate INTO v_movementtype,v_movementdate
     FROM M_INOUT
     WHERE M_INOUT_ID = NEW.M_INOUT_ID;
     IF v_movementtype = 'C-' THEN
        v_qty := -NEW.MOVEMENTQTY;
        v_qtyorder := -NEW.QUANTITYORDER;
     ELSE
         v_qty := NEW.MOVEMENTQTY;
         v_qtyorder := NEW.QUANTITYORDER;

     END IF;

   SELECT ISSOTRX INTO v_ISSOTRX
   FROM M_INOUT
   WHERE M_INOUT_ID = NEW.M_INOUT_ID;

   IF (NEW.M_PRODUCT_ID IS NOT NULL) THEN
     SELECT ISQUANTITYVARIABLE INTO v_QTYVARIABLE
     FROM M_PRODUCT
     WHERE M_PRODUCT_ID = NEW.M_PRODUCT_ID;
   END IF;

   IF (v_QTYVARIABLE <> 'Y' AND v_ISSOTRX = 'Y' AND NEW.C_ORDERLINE_ID IS NOT NULL) THEN
       IF (TG_OP = 'UPDATE') THEN
          IF(old.MOVEMENTQTY <> NEW.MOVEMENTQTY) THEN
             SELECT COUNT(*) INTO V_COUNT 
             FROM C_ORDERLINE ol 
             WHERE ol.C_ORDERLINE_ID = NEW.C_ORDERLINE_ID
             AND ABS(NEW.MOVEMENTQTY + coalesce(ol.QTYDELIVERED,0)) > ABS(ol.QTYORDERED);
          END IF;
       ELSE
          SELECT COUNT(*) INTO V_COUNT 
          FROM C_ORDERLINE ol 
          WHERE ol.C_ORDERLINE_ID = NEW.C_ORDERLINE_ID
          AND ABS(NEW.MOVEMENTQTY + coalesce(ol.QTYDELIVERED,0)) > ABS(ol.QTYORDERED);
       END IF;

       IF(V_COUNT <> 0) THEN
	 RAISE EXCEPTION '%', '@MovementQtyCheck@'; --OBTG:-20000--
       END IF;
   END IF;
 END IF;  

 IF (TG_OP = 'UPDATE') THEN
  IF (COALESCE(OLD.C_UOM_ID, '0') <> COALESCE(NEW.C_UOM_ID, '0')) THEN
    IF (NEW.M_PRODUCT_ID IS NOT NULL) THEN
      SELECT C_UOM_ID INTO v_UOM_ID FROM M_PRODUCT WHERE M_PRODUCT_ID=NEW.M_PRODUCT_ID;
      IF (COALESCE(v_UOM_ID,'0') <> COALESCE(NEW.C_UOM_ID,'0')) THEN
        IF (NEW.C_ORDERLINE_ID IS NOT NULL) THEN
          SELECT C_UOM_ID INTO v_UOM_ID FROM C_ORDERLINE WHERE C_ORDERLINE_ID = NEW.C_ORDERLINE_ID;
            IF (COALESCE(v_UOM_ID,'0') <> COALESCE(NEW.C_UOM_ID,'0')) THEN
              RAISE EXCEPTION '%', '@20111@'; --OBTG:-20000--
            END IF;
        ELSE
          RAISE EXCEPTION '%', '@20111@'; --OBTG:-20000--
        END IF;
      END IF;
  END IF;
 END IF;
   v_ID := new.M_InOut_ID;

   SELECT MOVEMENTTYPE,MovementDate INTO v_movementtype,v_movementdate
     FROM M_INOUT
     WHERE M_INOUT_ID = NEW.M_INOUT_ID;
     IF v_movementtype = 'C-' THEN
           v_qty := -NEW.MOVEMENTQTY;
           v_qtyorder := -NEW.QUANTITYORDER;

        ELSE
           v_qty := NEW.MOVEMENTQTY;
           v_qtyorder := NEW.QUANTITYORDER;

     END IF;

     SELECT COUNT(*) INTO v_MatchInvCount
     FROM M_MATCHINV MI
     WHERE MI.QTY = OLD.MOVEMENTQTY
       AND MI.M_INOUTLINE_ID = NEW.M_INOUTLINE_ID;
     IF (OLD.MOVEMENTQTY <> NEW.MOVEMENTQTY AND v_MatchInvCount=1) THEN
       UPDATE M_MATCHINV SET QTY=NEW.MOVEMENTQTY
       WHERE QTY = OLD.MOVEMENTQTY
         AND M_INOUTLINE_ID = NEW.M_INOUTLINE_ID;
     END IF;

 END IF;


 IF TG_OP = 'UPDATE' OR TG_OP = 'DELETE' THEN
     v_ID := old.M_InOut_ID;
  SELECT MOVEMENTTYPE,movementdate INTO v_movementtype,v_movementdate
  FROM M_INOUT
  WHERE M_INOUT_ID = OLD.M_INOUT_ID;
  IF v_movementtype = 'C-' THEN
       v_qtyold := OLD.MOVEMENTQTY;
       v_qtyorderold := OLD.QUANTITYORDER;

    ELSE
       v_qtyold := -OLD.MOVEMENTQTY;
       v_qtyorderold := -OLD.QUANTITYORDER;

    END IF;
 END IF;

 -- ReadOnly Check
 SELECT  COUNT(*)
   INTO v_RO
 FROM M_InOut
 WHERE M_InOut_ID=v_ID
   AND (Processed='Y' OR Posted='Y');
 IF (v_RO > 0) THEN
  IF (TG_OP = 'INSERT' OR TG_OP = 'DELETE') THEN
   RAISE EXCEPTION '%', '@20501@'; --OBTG:-20000--
  ELSIF (new.M_Product_ID<>old.M_Product_ID OR new.MovementQty<>old.MovementQty
  OR COALESCE(new.M_AttributeSetInstance_ID, '0') <> COALESCE(old.M_AttributeSetInstance_ID, '0')
  OR COALESCE(new.M_Locator_ID,'-1') <> COALESCE(old.M_Locator_ID,'-1'))
 THEN
  RAISE EXCEPTION '%', '@20501@'; --OBTG:-20000--
   END IF;
 END IF;

 IF (TG_OP = 'UPDATE') THEN
   v_IsUpdateDifferentProduct := COALESCE(OLD.m_product_id, '0') <> COALESCE(NEW.m_product_id, '0');
 END IF;

 -- Do not allow different product than the one in the related orderline.
 IF (TG_OP = 'INSERT' OR v_IsUpdateDifferentProduct) THEN
   IF (new.C_OrderLine_ID is not null) THEN
     SELECT m_product_id INTO v_OrderProduct FROM C_OrderLine WHERE C_OrderLine_ID = new.C_OrderLine_ID;
     IF (v_OrderProduct <> new.M_Product_ID) THEN
       RAISE EXCEPTION '%', '@ProductDefinedByOrder@'; --OBTG:-20000--
     END IF;
   END IF;
 END IF;
 
 -- UPDATING inventory
 IF (TG_OP = 'UPDATE' OR TG_OP = 'DELETE') THEN
    IF (old.M_PRODUCT_ID IS NOT NULL AND OLD.M_LOCATOR_ID IS NOT NULL) THEN
   SELECT COUNT(*) INTO V_STOCKED
  FROM M_PRODUCT
  WHERE M_Product_ID=OLD.M_PRODUCT_ID
  AND IsStocked = 'Y' AND ProductType = 'I';
   IF V_STOCKED > 0 THEN
       PERFORM M_UPDATE_INVENTORY(OLD.AD_CLIENT_ID, OLD.AD_ORG_ID, OLD.UPDATEDBY, OLD.M_PRODUCT_ID, OLD.M_LOCATOR_ID,
    OLD.M_ATTRIBUTESETINSTANCE_ID, OLD.C_UOM_ID,
       OLD.M_PRODUCT_UOM_ID, NULL, NULL, NULL, v_qtyold, v_qtyorderold, v_movementdate, v_movementtype );
   END IF;
    END IF;
  END IF;
 IF (TG_OP = 'INSERT' OR TG_OP = 'UPDATE') THEN
   IF (NEW.M_PRODUCT_ID IS NOT NULL AND NEW.M_LOCATOR_ID IS NOT NULL) THEN
   SELECT COUNT(*) INTO V_STOCKED
  FROM M_PRODUCT
  WHERE M_Product_ID=NEW.M_PRODUCT_ID
  AND IsStocked = 'Y' AND ProductType = 'I';
   IF V_STOCKED > 0 THEN
       PERFORM M_UPDATE_INVENTORY(NEW.AD_CLIENT_ID, NEW.AD_ORG_ID, NEW.UPDATEDBY, NEW.M_PRODUCT_ID, NEW.M_LOCATOR_ID,
    NEW.M_ATTRIBUTESETINSTANCE_ID, NEW.C_UOM_ID,
       NEW.M_PRODUCT_UOM_ID, NULL, NULL, NULL, v_qty, v_qtyorder, v_movementdate, v_movementtype );
   END IF;
    END IF;
  END IF;
  IF (TG_OP = 'INSERT' OR TG_OP = 'UPDATE') THEN
   --Does not allow to change the attribute set value
   -- for products which attribute set value type is Fixed
   IF (NEW.M_PRODUCT_ID IS NOT NULL AND COALESCE(new.M_AttributeSetInstance_ID,'0')!='0') THEN
    SELECT ATTRSETVALUETYPE 
    INTO v_AttrSetValueType
    FROM M_PRODUCT 
    WHERE M_PRODUCT_ID=NEW.M_PRODUCT_ID;
    IF (v_AttrSetValueType='F') THEN
     RAISE EXCEPTION '%', '@AttrSetValueFixed@'; --OBTG:-20000--
    END IF;
   END IF;
  END IF;
IF TG_OP = 'DELETE' THEN RETURN OLD; ELSE RETURN NEW; END IF; 

END 

; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION m_inoutline_trg()
  OWNER TO tad;


/***********************************************************************************************
* Code Added On 12-July-2019
* changes In         : Core ad_get_doctype Stored Procedure
* Modifications      : On Generate Payment From Payment Proposal - Payment out Record Should Be
*                      Created With Document Type Name -> Bank Payment  
*************************************************************************************************/

CREATE OR REPLACE FUNCTION ad_get_doctype(p_clientid character varying, p_orgid character varying, p_docbasetype character varying, p_docsubtypeso character)
  RETURNS character varying AS
$BODY$ DECLARE 
/*************************************************************************
* The contents of this file are subject to the Openbravo  Public  License
* Version  1.1  (the  "License"),  being   the  Mozilla   Public  License
* Version 1.1  with a permitted attribution clause; you may not  use this
* file except in compliance with the License. You  may  obtain  a copy of
* the License at http://www.openbravo.com/legal/license.html
* Software distributed under the License  is  distributed  on  an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
* License for the specific  language  governing  rights  and  limitations
* under the License.
* The Original Code is Openbravo ERP.
* The Initial Developer of the Original Code is Openbravo SLU
* All portions are Copyright (C) 2001-2011 Openbravo SLU
* All Rights Reserved.
* Contributor(s):  ______________________________________.
************************************************************************/
  v_DocTypeId VARCHAR(32) ; --OBTG:varchar2--
  --TYPE RECORD IS REFCURSOR;
    Cur_DocType RECORD;

  BEGIN

----------------------------Part 1------------------------------------------
IF(p_docbasetype = 'ARR' OR p_docbasetype = 'APP' OR p_docbasetype = 'APPP' OR p_docbasetype = 'PPR' 
OR p_docbasetype = 'EXFINP_APR') THEN
  
    FOR Cur_DocType IN
      (SELECT C_DocType_ID
      FROM C_DOCTYPE
      WHERE DOCBASETYPE=p_DocBaseType AND name like 'Bank Payment'
        AND ISACTIVE='Y' 
        AND(p_DocSubTypeSO IS NULL
        OR DOCSUBTYPESO=p_DocSubTypeSO)
        AND AD_Client_Id=p_ClientId
        AND AD_ISORGINCLUDED(p_OrgId, AD_Org_ID, p_ClientId) <> -1
        AND COALESCE(isreturn, 'N') = 'N'
      ORDER BY AD_ISORGINCLUDED(p_OrgId, AD_Org_ID, p_ClientId),
        IsDefault DESC,
        C_DocType_ID
      )
    LOOP
      v_DocTypeId:=Cur_DocType.C_DocType_ID;
      EXIT;
    END LOOP;

----------------------------Part 2------------------------------------------
ELSE

FOR Cur_DocType IN
      (SELECT C_DocType_ID
      FROM C_DOCTYPE
      WHERE DOCBASETYPE=p_DocBaseType
        AND ISACTIVE='Y' 
        AND(p_DocSubTypeSO IS NULL
        OR DOCSUBTYPESO=p_DocSubTypeSO)
        AND AD_Client_Id=p_ClientId
        AND AD_ISORGINCLUDED(p_OrgId, AD_Org_ID, p_ClientId) <> -1
        AND COALESCE(isreturn, 'N') = 'N'
      ORDER BY AD_ISORGINCLUDED(p_OrgId, AD_Org_ID, p_ClientId),
        IsDefault DESC,
        C_DocType_ID
      )
    LOOP
      v_DocTypeId:=Cur_DocType.C_DocType_ID;
      EXIT;
    END LOOP;

------------------------------------------------------------
END IF;
------------------------------------------------------------

    RETURN v_DocTypeId;
END ; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION ad_get_doctype(character varying, character varying, character varying, character)
  OWNER TO tad;





/***********************************************************************************************
* Code Added On 11-September-2019
* changes In         : Core gl_journal_post Stored Procedure
* Modifications      : Added calling custom procedure
*                       
*************************************************************************************************/
-- Function: gl_journal_post(character varying, character varying)

-- DROP FUNCTION gl_journal_post(character varying, character varying);

CREATE OR REPLACE FUNCTION gl_journal_post(p_pinstance_id character varying, p_gl_journal_id character varying)
  RETURNS void AS
$BODY$ DECLARE 
/*************************************************************************
  * The contents of this file are subject to the Compiere Public
  * License 1.1 ("License"); You may not use this file except in
  * compliance with the License. You may obtain a copy of the License in
  * the legal folder of your Openbravo installation.
  * Software distributed under the License is distributed on an
  * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing rights
  * and limitations under the License.
  * The Original Code is  Compiere  ERP &  Business Solution
  * The Initial Developer of the Original Code is Jorg Janke and ComPiere, Inc.
  * Portions created by Jorg Janke are Copyright (C) 1999-2001 Jorg Janke,
  * parts created by ComPiere are Copyright (C) ComPiere, Inc.;
  * All Rights Reserved.
  * Contributor(s): Openbravo SLU
  * Contributions are Copyright (C) 2001-2015 Openbravo, S.L.U.
  *
  * Specifically, this derivative work is based upon the following Compiere
  * file and version.
  *************************************************************************
  * $Id: GL_Journal_Post.sql,v 1.2 2002/05/22 02:48:28 jjanke Exp $
  ***
  * Title: GL Journal Post (preparation)
  * Description:
  * - Check Control Amount
  ************************************************************************/
  -- Logistice
  v_ResultStr VARCHAR(2000):=''; --OBTG:VARCHAR2--
  v_Message VARCHAR(2000):=''; --OBTG:VARCHAR2--
  v_Result NUMERIC:=1; -- 0=failure
  v_DateAcctBelongsToPeriod NUMERIC;
  v_Record_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_AD_User_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_AD_Org_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_C_Period_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_DateAcct TIMESTAMP;
  v_DocType_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_BatchOrg_ID VARCHAR(32); --OBTG:VARCHAR2--
  -- Parameter
  --TYPE RECORD IS REFCURSOR;
    Cur_Parameter RECORD;
    Cur_Org_Lines RECORD;
    -- Parameter Variables
    -- Other Variables
    v_DocStatus GL_Journal.DocStatus%TYPE;
    v_DocAction GL_Journal.DocAction%TYPE;
    v_Processing GL_Journal.Processing%TYPE;
    v_Posted GL_Journal.Posted%TYPE;
    v_TotalDr GL_Journal.TotalDr%TYPE;
    v_TotalCr GL_Journal.TotalCr%TYPE;
    v_ControlAmt GL_Journal.ControlAmt%TYPE;
    FINISH_PROCESS BOOLEAN:=false;
    v_is_included NUMERIC:=0;
    v_available_period NUMERIC:=0;
    v_is_ready AD_Org.IsReady%TYPE;
    v_is_tr_allow AD_OrgType.IsTransactionsAllowed%TYPE;
    v_isacctle AD_OrgType.IsAcctLegalEntity%TYPE;
    v_org_bule_id AD_Org.AD_Org_ID%TYPE;
    v_documentNo GL_Journal.DocumentNo%TYPE;
    
  BEGIN
    --  Update AD_PInstance
    RAISE NOTICE '%','Updating PInstance - Processing ' || p_PInstance_ID ;
    IF(p_PInstance_ID IS NOT NULL) THEN
      v_ResultStr:='PInstanceNotFound';
      PERFORM AD_UPDATE_PINSTANCE(p_PInstance_ID, NULL, 'Y', NULL, NULL) ;
      -- Get Parameters
      v_ResultStr:='ReadingParameters';
      FOR Cur_Parameter IN
        (SELECT i.Record_ID,
          i.AD_User_ID,
          p.ParameterName,
          p.P_String,
          p.P_Number,
          p.P_Date
        FROM AD_PInstance i
        LEFT JOIN AD_PInstance_Para p
          ON i.AD_PInstance_ID=p.AD_PInstance_ID
        WHERE i.AD_PInstance_ID=p_PInstance_ID
        ORDER BY p.SeqNo
        )
      LOOP
        v_Record_ID:=Cur_Parameter.Record_ID;
        v_AD_User_ID:=Cur_Parameter.AD_User_ID;
      END LOOP; -- Get Parameter
    ELSE
      v_Record_ID:=p_GL_Journal_ID;
    END IF;
    RAISE NOTICE '%','  Record_ID=' || v_Record_ID ;
  BEGIN --BODY
    /**
    * Status - Actions
    * DR   CO, VO
    * CO   CL
    */

    PERFORM exfm_gljournaldocgen(p_gl_journal_id);
    
    v_ResultStr:='ReadingJournal';
    SELECT DocStatus,
      DocAction,
      Processing,
      Posted, AD_Org_ID, DateAcct, C_DocType_ID,
      C_Period_ID
    INTO v_DocStatus,
      v_DocAction,
      v_Processing,
      v_Posted, v_AD_Org_ID, v_DateAcct, v_DocType_ID,
      v_C_Period_ID
    FROM GL_Journal
    WHERE GL_Journal_ID=v_Record_ID  FOR UPDATE;
    /**
    * Closed, Voided or Reversed - No action possible
    */
    IF(v_DocStatus IN('CL', 'VO', 'RE')) THEN
      RAISE EXCEPTION '%', '@AlreadyPosted@' ; --OBTG:-20000--
    END IF;
    /**
    * Unlock
    */
    IF(NOT FINISH_PROCESS) THEN
      IF(v_DocAction='XL') THEN
        IF(v_AD_User_ID IS NOT NULL) THEN
          UPDATE GL_Journal
            SET Processing='N',
            DocAction='--',
            Updated=TO_DATE(NOW()),
            UpdatedBy=v_AD_User_ID
          WHERE GL_Journal_ID=v_Record_ID;
        ELSE
          UPDATE GL_Journal
            SET Processing='N',
            DocAction='--',
            Updated=TO_DATE(NOW())
          WHERE GL_Journal_ID=v_Record_ID;
        END IF;
        FINISH_PROCESS:=true;
      END IF;
    END IF; --FINISH_PROCESS
    IF(NOT FINISH_PROCESS) THEN
      IF(v_Processing='Y') THEN
        RAISE EXCEPTION '%', '@OtherProcessActive@' ; --OBTG:-20000--
      END IF;
    END IF; --FINISH_PROCESS
    /**
    * Close Order
    */
    IF(NOT FINISH_PROCESS) THEN
      IF(v_DocAction='CL') THEN
        IF(v_AD_User_ID IS NOT NULL) THEN
          UPDATE GL_Journal
            SET DocStatus='CL',
            DocAction='--',
            Processed='Y',
            Updated=TO_DATE(NOW()),
            UpdatedBy=v_AD_User_ID
          WHERE GL_Journal_ID=v_Record_ID;
        ELSE
          UPDATE GL_Journal
            SET DocStatus='CL',
            DocAction='--',
            Processed='Y',
            Updated=TO_DATE(NOW())
          WHERE GL_Journal_ID=v_Record_ID;
        END IF;
        FINISH_PROCESS:=true;
      END IF;
    END IF; --FINISH_PROCESS
    /**
    * Void Order
    */
    IF(NOT FINISH_PROCESS) THEN
      IF(v_DocAction='VO' AND v_DocStatus='DR') THEN
        -- Cancel all Lines
        UPDATE GL_JournalLine
          SET IsActive='N',
          Updated=TO_DATE(NOW())
        WHERE GL_Journal_ID=v_Record_ID;
        UPDATE GL_Journal
          SET DocStatus='VO',
          DocAction='--',
          Processed='Y',
          Updated=TO_DATE(NOW())
        WHERE GL_Journal_ID=v_Record_ID;
        FINISH_PROCESS:=true;
      END IF;
    END IF; --FINISH_PROCESS
    IF(NOT FINISH_PROCESS) THEN
      IF(v_DocAction='RE') THEN
        IF(v_Posted='Y') THEN
          RAISE EXCEPTION '%', '@GLJournalDocumentPosted@' ; --OBTG:-20000--
        END IF;
        IF(NOT FINISH_PROCESS) THEN
            UPDATE GL_Journal
              SET DocStatus='DR',
              DocAction='CO',
              Processed='N',
              Updated=TO_DATE(NOW())
            WHERE GL_Journal_ID=v_Record_ID;
            FINISH_PROCESS:=true;
        END IF;
      END IF;
    END IF; --FINISH_PROCESS
    IF(NOT FINISH_PROCESS) THEN
      --  Lock journal comes here
      /**
      * Process Journal
      */
      -- Check the header belongs to a organization where transactions are posible and ready to use
      SELECT AD_Org.IsReady, Ad_OrgType.IsTransactionsAllowed
      INTO v_is_ready, v_is_tr_allow
      FROM GL_JOURNAL, AD_Org, AD_OrgType
      WHERE AD_Org.AD_Org_ID=GL_JOURNAL.AD_Org_ID
      AND AD_Org.AD_OrgType_ID=AD_OrgType.AD_OrgType_ID
      AND GL_JOURNAL.GL_JOURNAL_ID=v_Record_ID;
      IF (v_is_ready='N') THEN
        RAISE EXCEPTION '%', '@OrgHeaderNotReady@'; --OBTG:-20000--
      END IF;
      IF (v_is_tr_allow='N') THEN
        RAISE EXCEPTION '%', '@OrgHeaderNotTransAllowed@'; --OBTG:-20000--
      END IF;

      -- Check if the gl journal has lines.
     
      SELECT max(documentNo) INTO v_documentNo
      FROM GL_Journal
      WHERE EXISTS (SELECT 1
                    FROM GL_JournalLine
                    WHERE GL_JournalLine.GL_Journal_ID = GL_Journal.GL_Journal_ID
                    AND GL_JournalLine.GL_Journal_ID = v_Record_ID);

      IF (v_documentno IS NULL) THEN
        SELECT documentNo INTO v_documentNo
        FROM GL_Journal
        WHERE GL_Journal_ID = v_Record_ID;
        
        RAISE EXCEPTION '%', '@GLJournalHasNoLines@' || ' ' || v_DocumentNo; --OBTG:-20000--
      END IF;
      
      SELECT AD_ORG_CHK_DOCUMENTS('GL_JOURNAL', 'GL_JOURNALLINE', v_Record_ID, 'GL_JOURNAL_ID', 'GL_JOURNAL_ID') INTO v_is_included FROM dual;
      IF (v_is_included=-1) THEN
        RAISE EXCEPTION '%', '@LinesAndHeaderDifferentLEorBU@'; --OBTG:-20000--
      END IF;   

      FOR Cur_Org_Lines IN
        (SELECT gll.ad_org_id,
             gll.ad_client_id
        FROM gl_journalline gll
        WHERE gll.gl_journal_id = v_Record_id
        )
      LOOP
        SELECT AD_ISORGINCLUDED(Cur_Org_Lines.ad_org_id, v_AD_Org_ID, Cur_Org_Lines.ad_client_id)
        INTO v_is_included
        FROM DUAL;

        IF (v_is_included=-1) THEN
          RAISE EXCEPTION '%', '@ForcedOrgNotMatchDocument@'; --OBTG:-20000--
        END IF;
      END LOOP;
      
      SELECT COALESCE(gl_journalbatch.ad_org_id, gl_journal.ad_org_id)
      INTO v_BatchOrg_ID
      FROM gl_journal LEFT JOIN gl_journalbatch
      ON gl_journal.gl_journalbatch_id = gl_journalbatch.gl_journalbatch_id
      WHERE gl_journal.gl_journal_id = v_Record_id;
      
      IF (v_BatchOrg_ID <> v_AD_Org_ID) THEN
        RAISE EXCEPTION '%', '@BatchAndHeaderDifferentOrg@'; --OBTG:-20000--
      END IF;
      
      -- Check if the Accounting Date belongs to the Period

      SELECT COUNT(*) INTO v_DateAcctBelongsToPeriod
  	  FROM c_period p
      WHERE p.c_period_id = v_C_Period_ID
      AND v_DateAcct BETWEEN p.startdate AND p.enddate;

      IF v_DateAcctBelongsToPeriod < 1 THEN
          RAISE EXCEPTION '%', '@PeriodNotValid@'; --OBTG:-20000--
      END IF;

      -- Check the period control is opened (only if it is legal entity with accounting)
      -- Gets the BU or LE of the document
      SELECT AD_GET_DOC_LE_BU('GL_JOURNAL', v_Record_ID, 'GL_JOURNAL_ID', 'LE')
      INTO v_org_bule_id
      FROM DUAL;
      
      SELECT AD_OrgType.IsAcctLegalEntity
      INTO v_isacctle
      FROM AD_OrgType, AD_Org
      WHERE AD_Org.AD_OrgType_ID = AD_OrgType.AD_OrgType_ID
      AND AD_Org.AD_Org_ID=v_org_bule_id;
      
      IF (v_isacctle='Y') THEN     	
        SELECT C_CHK_OPEN_PERIOD_GLJ(v_AD_Org_ID, v_C_Period_ID) 
        INTO v_available_period
        FROM DUAL;
        
        IF (v_available_period<>1) THEN
          RAISE EXCEPTION '%', '@PeriodNotAvailable@'; --OBTG:-20000--
        END IF;
      END IF;   
      
      -- Recalculate Totals
      v_ResultStr:='RecalculateTotals';
      UPDATE GL_Journal
        SET TotalDr=
        (SELECT COALESCE(SUM(AmtSourceDr), 0)
        FROM GL_JournalLine
        WHERE GL_Journal_ID=v_Record_ID
          AND IsActive='Y'
        )
        ,
        TotalCr=
        (SELECT COALESCE(SUM(AmtSourceCr), 0)
        FROM GL_JournalLine
        WHERE GL_Journal_ID=v_Record_ID
          AND IsActive='Y'
        )
      WHERE GL_Journal_ID=v_Record_ID;
      v_ResultStr:='ReadingAmounts';
      SELECT ControlAmt,
        TotalDr,
        TotalCr
      INTO v_ControlAmt,
        v_TotalDr,
        v_TotalCr
      FROM GL_Journal
      WHERE GL_Journal_ID=v_Record_ID  FOR UPDATE;
      IF(v_TotalDr<>v_TotalCr) THEN
        RAISE EXCEPTION '%', '@DistinctAmtError@' ; --OBTG:-20000--
      END IF;
    END IF; --FINISH_PROCESS
    IF(NOT FINISH_PROCESS) THEN
      -- Check ControlAmt
      IF(v_ControlAmt<>0 AND(v_ControlAmt<>v_TotalDr)) THEN
        RAISE EXCEPTION '%', '@ControlAmtError@' ; --OBTG:-20000--
      ELSE
        UPDATE GL_Journal
          SET DocStatus='CO',
          DocAction='RE',
          Processed='Y',
          Updated=TO_DATE(NOW())
        WHERE GL_Journal_ID=v_Record_ID;
      END IF;
    END IF; --FINISH_PROCESS
    ---- <<FINISH_PROCESS>>
    --  Update AD_PInstance
    RAISE NOTICE '%','Updating PInstance - Finished ' || v_Message ;
    IF(p_PInstance_ID IS NOT NULL) THEN
      PERFORM AD_UPDATE_PINSTANCE(p_PInstance_ID, NULL, 'N', v_Result, v_Message) ;
    END IF;
    RETURN;
  END; --BODY
EXCEPTION
WHEN OTHERS THEN
  v_ResultStr:= '@ERROR=' || SQLERRM;
  RAISE NOTICE '%',v_ResultStr ;
  -- ROLLBACK;
  IF(p_PInstance_ID IS NOT NULL) THEN
    PERFORM AD_UPDATE_PINSTANCE(p_PInstance_ID, NULL, 'N', 0, v_ResultStr) ;
  ELSE
    RAISE EXCEPTION '%', SQLERRM;
  END IF;
  RETURN;
END ; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION gl_journal_post(character varying, character varying)
  OWNER TO tad;


-- Function: c_order_post1(character varying, character varying, character varying)

-- DROP FUNCTION c_order_post1(character varying, character varying, character varying);

-- Function: c_order_post1(character varying, character varying, character varying)

-- DROP FUNCTION c_order_post1(character varying, character varying, character varying);

CREATE OR REPLACE FUNCTION c_order_post1(p_pinstance_id character varying, p_order_id character varying, p_recalculatediscounts character varying)
  RETURNS void AS
$BODY$ DECLARE 
/*************************************************************************
* The contents of this file are subject to the Openbravo  Public  License
* Version  1.1  (the  "License"),  being   the  Mozilla   Public  License
* Version 1.1  with a permitted attribution clause; you may not  use this
* file except in compliance with the License. You  may  obtain  a copy of
* the License at http://www.openbravo.com/legal/license.html
* Software distributed under the License  is  distributed  on  an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
* License for the specific  language  governing  rights  and  limitations
* under the License.
* The Original Code is Openbravo ERP.
* The Initial Developer of the Original Code is Openbravo SLU
* All portions are Copyright (C) 2001-2014 Openbravo SLU
* All Rights Reserved.
* Contributor(s):  ______________________________________.
************************************************************************/
  -- Logistics
  v_ResultStr VARCHAR(2000):=''; --OBTG:VARCHAR2--
  v_Message VARCHAR(2000):=''; --OBTG:VARCHAR2--
  v_Record_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_User VARCHAR(32); --OBTG:VARCHAR2--
  v_IsProcessing CHAR(1) ;
  v_IsProcessed VARCHAR(60) ;
  v_Result NUMERIC:=1; -- Success
  v_is_included NUMERIC:=0;
  v_is_ready AD_Org.IsReady%TYPE;
  v_is_tr_allow AD_OrgType.IsTransactionsAllowed%TYPE;
  -- Parameter
  --TYPE RECORD IS REFCURSOR;
    Cur_Parameter RECORD;
    Cur_line RECORD;
    Cur_Order RECORD;
  -- Record Info
  v_Client_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_Org_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_Warehouse_Org VARCHAR(32); --OBTG:VARCHAR2--
  v_Org_Name VARCHAR(60); --OBTG:VARCHAR2--
  v_UpdatedBy VARCHAR(32); --OBTG:VARCHAR2--
  v_DocAction VARCHAR(60) ;
  v_DocStatus VARCHAR(60) ;
  v_InvoiceRule VARCHAR(60) ;
  v_M_Warehouse_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_DocType_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_DocTypeTarget_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_DocSubTypeSO VARCHAR(60) ;
  v_DocSubTypeSOTarget VARCHAR(60) ;
  v_DocBaseTypeTarget VARCHAR(60);
  v_IsReturnDocType CHAR(1);
  v_IsBinding CHAR(1):='Y';
  v_istaxincluded CHAR(1);
  --
  ToDeliver NUMERIC:=0;
  ToInvoice NUMERIC:=0;
  ToDeliverOrToInvoice NUMERIC:=0;
  --
  InOut_ID VARCHAR(32); --OBTG:VARCHAR2--
  Invoice_ID VARCHAR(32); --OBTG:VARCHAR2--
  --Added by P.SAROBE
  v_documentno_Settlement VARCHAR(40); --OBTG:VARCHAR2--
  v_dateSettlement TIMESTAMP;
  v_Cancel_Processed VARCHAR(60);
  v_nameBankstatement VARCHAR (60); --OBTG:VARCHAR2--
  v_dateBankstatement TIMESTAMP;
  v_nameCash VARCHAR (60); --OBTG:VARCHAR2--
  v_dateCash TIMESTAMP;
  v_Bankstatementline_ID VARCHAR(32); --OBTG:VARCHAR2--
  --Finish added by P.Sarobe
  v_AuxCashLine_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_CashLine_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_ispaid CHAR(1);
  v_Settlement_Cancel_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_Cash_ID VARCHAR(32):=NULL; --OBTG:VARCHAR2--
  v_Line NUMERIC:=0;
  v_CashBook_ID VARCHAR(32):=NULL; --OBTG:VARCHAR2--
  v_Debtpayment_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_ISO_Code VARCHAR(10) ;
  v_DocumentNo VARCHAR(200) ; --OBTG:VARCHAR2--
  v_GrandTotal NUMERIC;
  v_Multiplier NUMERIC:=1;
  v_Date TIMESTAMP;
  v_WarehouseName VARCHAR(60) ; --OBTG:VARCHAR2--
  v_CashProcessed NUMERIC;
  v_count NUMERIC;
  v_isSoTrx CHAR(1) ;
  v_Aux NUMERIC;
  v_c_Bpartner_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_c_currency_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_C_PROJECT_ID VARCHAR(32); --OBTG:VARCHAR2--
  v_PriceList_ID VARCHAR(32); --OBTG:VARCHAR2--
  FINISH_PROCESS BOOLEAN:=FALSE;
  END_PROCESSING BOOLEAN:=FALSE;
  v_CBPartner_ID VARCHAR(32); --OBTG:VARCHAR2--
  rowcount NUMERIC;

  v_CumDiscount NUMERIC;
  v_OldCumDiscount NUMERIC;
  v_OrderLineSeqNo NUMERIC;
  Cur_COrderDiscount RECORD;
  Cur_TaxDiscount RECORD;
  v_OrderLine VARCHAR(32); --OBTG:VARCHAR2--
  v_Discount NUMERIC;
  v_precision NUMERIC;
  Cur_OrderLine RECORD;
  v_DiscountExist NUMERIC;
  v_gross_unit_price NUMERIC;
  v_line_gross_amount NUMERIC;
  v_acctAmount NUMERIC;
  v_reject_reason VARCHAR(32);
  v_dummy VARCHAR(2000); --OBTG:VARCHAR2--
  v_bpartner_blocked VARCHAR(1):='N'; --OBTG:VARCHAR2--
  v_orderBlocking VARCHAR(1):='N'; --OBTG:VARCHAR2--
  v_bpartner_name c_bpartner.name%TYPE;
  v_productname m_product.name%TYPE;

  v_iscashvat C_Order.IsCashVat%TYPE;
  v_recalculateDiscounts VARCHAR(1):='Y';
  v_isactive VARCHAR(1):='N';
  v_tolerancelimit varchar(1); --OBTG:VARCHAR2--

  BEGIN
    IF (p_PInstance_ID IS NOT NULL) THEN
      --  Update AD_PInstance
      RAISE NOTICE '%','Updating PInstance - Processing ' || p_PInstance_ID ;
      v_ResultStr:='PInstanceNotFound';
      PERFORM AD_UPDATE_PINSTANCE(p_PInstance_ID, NULL, 'Y', NULL, NULL) ;
      -- Get Parameters
      v_ResultStr:='ReadingParameters';
      FOR Cur_Parameter IN
        (SELECT i.Record_ID, i.AD_User_ID, p.ParameterName, p.P_String,
          p.P_Number, p.P_Date
        FROM AD_PINSTANCE i
        LEFT JOIN AD_PINSTANCE_PARA p
          ON i.AD_PInstance_ID=p.AD_PInstance_ID
        WHERE i.AD_PInstance_ID=p_PInstance_ID
        ORDER BY p.SeqNo
        )
      LOOP
        v_Record_ID:=Cur_Parameter.Record_ID;
        v_User:=Cur_Parameter.AD_User_ID;
      END LOOP; -- Get Parameter
    ELSE
      v_Record_ID:=p_Order_ID;
      v_recalculateDiscounts := p_recalculateDiscounts;
      SELECT CREATEDBY INTO v_User  FROM C_ORDER  WHERE C_ORDER_ID=p_Order_ID;
    END IF;
    RAISE NOTICE '%','  Record_ID=' || v_Record_ID ;
  BEGIN --BODY
  
  /*Orderline acct dimension*/
  SELECT C_ORDER.ISSOTRX , C_ORDER.c_bpartner_id
  INTO v_IsSOTrx, v_c_Bpartner_ID
  FROM C_ORDER
  WHERE C_ORDER_ID = v_Record_ID;

 
 
 
 PERFORM expur_tolerance_levels(v_Record_ID);
 
 
  
  
  IF (v_IsSOTrx = 'N') THEN
  
    FOR Cur_line IN
      (SELECT C_ORDERLINE.C_OrderLine_ID,
       C_ORDERLINE.LinenetAmt
       FROM C_ORDERLINE
       WHERE C_Order_ID = v_Record_ID
      )
    LOOP
      SELECT SUM(Amt) INTO v_acctAmount
      FROM C_ORDERLINE_ACCTDIMENSION
      WHERE C_OrderLine_ID = Cur_line.C_OrderLine_ID;
      IF (v_acctAmount <> Cur_line.LinenetAmt) THEN
        v_Message:='@QuantitiesNotMatch@';
        RAISE EXCEPTION '%', '@QuantitiesNotMatch@' ; --OBTG:-20000--
      END IF;
    END LOOP;
  END IF;

  /* Check active business partner*/
  SELECT isactive INTO v_isactive
  FROM C_Bpartner
  WHERE C_Bpartner_ID = v_C_Bpartner_ID;

  IF(v_isactive = 'N') THEN
    RAISE EXCEPTION '%', '@InActiveBusinessPartner@'; --OBTG:-20000--
  END IF;
  
    /**
    * Read Order
    */
    v_ResultStr:='ReadingOrder';
    SELECT Processing, Processed, DocAction, DocStatus,
      C_DocType_ID, C_DocTypeTarget_ID, c_order.AD_Client_ID,
      c_order.AD_Org_ID, c_order.UpdatedBy, M_Warehouse_ID, TRUNC(DateOrdered),
      Issotrx, c_Bpartner_Id, c_order.c_currency_id, C_PROJECT_ID,
      C_BPartner_ID, M_PriceList_ID, invoicerule, c_order.IsCashVat
    INTO v_IsProcessing, v_IsProcessed, v_DocAction, v_DocStatus,
      v_DocType_ID, v_DocTypeTarget_ID, v_Client_ID,
      v_Org_ID, v_UpdatedBy, v_M_Warehouse_ID, v_Date,
      v_isSoTrx, v_c_Bpartner_Id, v_c_currency_id, v_C_PROJECT_ID,
      v_CBPartner_ID, v_PriceList_ID, v_invoicerule, v_iscashvat
    FROM C_ORDER
    WHERE C_Order_ID=v_Record_ID  FOR UPDATE; --OBTG:  --

    SELECT m_pricelist.istaxincluded
    INTO v_istaxincluded
    FROM m_pricelist 
    WHERE m_pricelist_id= v_PriceList_ID;
    
    -- Get current DocSubTypeSO
    SELECT DocSubTypeSO
      INTO v_DocSubTypeSO
    FROM C_DOCTYPE
    WHERE C_DocType_ID=v_DocType_ID;
    SELECT DocSubTypeSO, isreturn
      INTO v_DocSubTypeSOTarget, v_isreturndoctype
    FROM C_DOCTYPE
    WHERE C_DocType_ID=v_DocTypetarget_ID;

  IF(v_isreturndoctype='Y' AND v_DocAction='CO') THEN
    DECLARE
    v_RefReturnQty NUMERIC:=0;
    v_RefMovementQty NUMERIC:=0;
    BEGIN
      v_Message:=NULL;
      FOR Cur_line IN
        (SELECT OL.M_INOUTLINE_ID, OL.LINE, OL.QTYORDERED
        FROM C_ORDERLINE OL
        WHERE OL.C_Order_ID = v_Record_ID
        AND OL.M_INOUTLINE_ID IS NOT NULL
        )
      LOOP
        SELECT COALESCE(SUM(OL.QtyOrdered),0) INTO v_RefReturnQty
        FROM C_ORDERLINE OL, C_ORDER O
        WHERE OL.M_INOUTLINE_ID = Cur_line.M_INOUTLINE_ID
        AND OL.C_ORDER_ID = O.C_ORDER_ID
        AND O.PROCESSED='Y';
        SELECT MovementQty INTO v_RefMovementQty
        FROM M_INOUTLINE WHERE M_INOUTLINE_ID = Cur_line.M_INOUTLINE_ID;
        v_RefReturnQty:=ABS(v_RefReturnQty) + ABS(Cur_Line.QtyOrdered);
        IF(v_RefReturnQty > v_RefMovementQty) THEN
          IF(v_Message IS NULL) THEN
            v_Message:=Cur_line.LINE;
          ELSE
            v_Message:=v_Message||', '||Cur_line.LINE;
          END IF;
        END IF;
      END LOOP;
      IF(v_Message IS NOT NULL) THEN
        RAISE EXCEPTION '%','@ReturnQtyMismatch@'||v_Message; --OBTG:-20000--
      END IF;
    END;
  END IF;

    --Check whether warehouse belongs to the organization.
    SELECT count(AD_ORG_ID)
    INTO v_count
    FROM AD_Org_Warehouse
    WHERE M_Warehouse_ID=v_M_Warehouse_ID
    AND AD_Org_ID = v_Org_ID;

    IF v_count = 0 AND v_IsSOTrx = 'Y' THEN
    RAISE EXCEPTION '%','@WrongWarehouse@' ; --OBTG:-20000--
    END IF;

    SELECT AD_Org_ID
    INTO v_Warehouse_Org
    FROM M_Warehouse
    WHERE M_Warehouse_ID = v_M_Warehouse_ID;

    IF(ad_org_isinnaturaltree(v_Warehouse_Org, v_Org_ID, v_Client_ID) = 'N' AND v_isSoTrx = 'N') THEN
      RAISE EXCEPTION '%','@WrongWarehouse@'; --OBTG:-20000--
    END IF;

    SELECT CASE WHEN (m.ISSOTRX='Y') THEN customer_blocking  ELSE vendor_blocking END ,  
    CASE WHEN (m.ISSOTRX='Y') THEN so_order_blocking ELSE po_order_blocking  END, name, DocAction
      INTO v_bpartner_blocked, v_orderBlocking, v_bpartner_name, v_DocAction
    FROM C_ORDER m, C_BPartner bp
    WHERE m.c_bpartner_id=bp.c_bpartner_id
    AND m.C_ORDER_ID=v_Record_ID
    AND m.C_BPARTNER_ID=v_c_Bpartner_ID;
    IF (v_DocAction = 'CO' AND v_bpartner_blocked = 'Y' AND v_orderBlocking = 'Y' AND v_isreturndoctype='N' ) THEN
      RAISE EXCEPTION '%','@ThebusinessPartner@'||' '|| v_bpartner_name ||' '||'@BusinessPartnerBlocked@'; --OBTG:-20000--
    END IF;
    -- Get the name of the org of the Order. Added by P.Sarobe
    SELECT name INTO v_Org_Name FROM AD_ORG WHERE ad_org_id = v_Org_ID;
    RAISE NOTICE '%','DocAction=' || v_DocAction || ', DocStatus=' || v_DocStatus || ', DocType_ID=' || v_DocType_ID || ', DocTypeTarget_ID=' || v_DocTypeTarget_ID || ', DocSubTypeSO=' || v_DocSubTypeSO ;

    SELECT count(*) INTO v_count
    FROM dual
    WHERE EXISTS (
        SELECT 1
        FROM c_orderline ol JOIN m_product p ON ol.m_product_id = p.m_product_id
        WHERE ol.c_order_id = v_record_id
          AND p.isgeneric = 'Y');
    IF (v_count > 0) THEN
      SELECT max(p.name) INTO v_productname
      FROM c_orderline ol JOIN m_product p ON ol.m_product_id = p.m_product_id
      WHERE ol.c_order_id = v_record_id
        AND p.isgeneric = 'Y';
      RAISE EXCEPTION '%', '@CannotUseGenericProduct@ ' || v_productName; --OBTG:-20000--
    END IF;

    /** 
    * Quotations
    */
    IF (v_DocSubTypeSOTarget = 'OB'AND v_DocAction = 'RJ') THEN
      SELECT c_reject_reason_id
        INTO v_reject_reason
      FROM C_ORDER
      WHERE C_Order_ID=v_Record_ID;
      IF (v_reject_reason IS NULL) THEN
        RAISE EXCEPTION '%', '@NoRejectReason@' ; --OBTG:-20000--
      END IF;
      /*
        * Undo inventory reservation
        */
        BEGIN
          v_ResultStr:='ReserveInventory';
          -- Set reserved quantity to 0
          UPDATE C_ORDERLINE
          SET QtyReserved = 0,
              Updated=TO_DATE(NOW()),
              UpdatedBy=v_User
          WHERE c_orderline_id IN (select c_orderline_id
                                   from c_orderline
                                   where c_order_id = v_Record_id);
        END;
      UPDATE C_ORDER
      SET DocStatus='CJ',
          DocAction='--',
          Processed='Y',
          Updated=TO_DATE(NOW()),
          UpdatedBy=v_User
      WHERE C_Order_ID=v_Record_ID;
      IF (p_PInstance_ID IS NOT NULL) THEN
      	--  Update AD_PInstance
      	RAISE NOTICE '%','Updating PInstance - Finished - ' || v_Message ;
        PERFORM AD_UPDATE_PINSTANCE(p_PInstance_ID, NULL, 'N', v_Result, v_Message) ;
      END IF;
      RETURN;
    END IF;

    /**
    * Check if order has lines
    */
    IF (v_DocAction = 'CO' OR v_DocAction = 'PR') THEN
      SELECT COUNT(*)
        INTO v_Aux
       FROM C_ORDERLINE
       WHERE C_ORDER_ID = v_Record_ID;
       IF v_Aux=0 THEN
         RAISE EXCEPTION '%', '@OrderWithoutLines@'; --OBTG:-20000--
       END IF;
    END IF;

    -- Check the cash vat flag for all the taxes matches the order one
    IF (v_DocAction IN ('CO', 'PR')) THEN
      select count(1)
      into v_Aux
      from c_ordertax ot inner join c_tax t on (ot.c_tax_id = t.c_tax_id)
      where ot.c_order_id = v_Record_ID
      and t.iswithholdingtax = 'N'
      and t.rate <> 0
      and t.IsCashVat <> v_iscashvat;

      IF (v_Aux > 0) THEN
        RAISE EXCEPTION '%', '@CashVATNotMatch@'; --OBTG:-20000--
      END IF;
    END IF;

    /**
    * Order Closed, Voided or Reversed - No action possible
    */
    IF(v_DocStatus IN('CL', 'VO', 'RE')) THEN
      RAISE EXCEPTION '%', '@AlreadyPosted@' ; --OBTG:-20000--
    END IF;

    /**
    * Waiting on Prepayment  can only be closed
    */
    IF(v_DocStatus='WP' AND v_DocAction<>'CL') THEN
      RAISE EXCEPTION '%', '@WaitingPayment@' ; --OBTG:-20000--
    END IF;

    IF (v_DocSubTypeSOTarget='PR' AND v_invoicerule <> 'I') THEN
      RAISE EXCEPTION '%', '@PrepayMustImmediate@'; --OBTG:-20000--
    END IF;
    /**
    * Unlock
    */
    IF(v_DocAction='XL') THEN
      UPDATE C_ORDER
        SET Processing='N',
        DocAction='--',
        Updated=TO_DATE(NOW()),
        UpdatedBy=v_User
      WHERE C_Order_ID=v_Record_ID;
      FINISH_PROCESS:=TRUE;
    END IF;
    IF(NOT FINISH_PROCESS) THEN
      IF(v_IsProcessing='Y') THEN
        RAISE EXCEPTION '%', '@OtherProcessActive@' ; --OBTG:-20000--
      END IF;

      /**
      * Re-activate
      */
      IF (v_DocAction='RE') THEN
        IF (v_DocSubTypeSO IN ('WR', 'WI')) THEN
          RAISE EXCEPTION '%', '@ActionNotSupported@'; --OBTG:-20000--
        END IF;
        --Verify not managed debtPayments added by ALO
        --Added by P.Sarobe. New messages
        SELECT max(c_debt_payment_id), COUNT(*)
          INTO v_Debtpayment_ID, v_Aux
        FROM C_DEBT_PAYMENT
        WHERE C_Order_ID=v_Record_ID
          AND C_Debt_Payment_Status(C_Settlement_Cancel_ID, Cancel_Processed, Generate_Processed, IsPaid, IsValid, C_CashLine_ID, C_BankStatementLine_ID)!='P';
        IF (v_Aux != 0) THEN
          --Added by P.Sarobe. New messages
          SELECT c_Bankstatementline_Id, c_cashline_id, c_settlement_cancel_id, ispaid, cancel_processed
            INTO v_Bankstatementline_ID, v_CashLine_ID, v_Settlement_Cancel_ID, v_ispaid, v_Cancel_Processed
          FROM C_DEBT_PAYMENT WHERE C_Debt_Payment_ID = v_Debtpayment_ID;

          IF (v_Bankstatementline_ID IS NOT NULL) THEN
            SELECT C_BANKSTATEMENT.NAME, C_BANKSTATEMENT.STATEMENTDATE
              INTO v_nameBankstatement, v_dateBankstatement
            FROM C_BANKSTATEMENT, C_BANKSTATEMENTLINE
            WHERE C_BANKSTATEMENT.C_BANKSTATEMENT_ID = C_BANKSTATEMENTLINE.C_BANKSTATEMENT_ID
              AND C_BANKSTATEMENTLINE.C_BANKSTATEMENTLINE_ID = v_Bankstatementline_ID;
            RAISE EXCEPTION '%', '@ManagedDebtPaymentOrderBank@'||v_nameBankstatement||' '||'@Bydate@'||v_dateBankstatement ; --OBTG:-20000--
          END IF;
          IF (v_CashLine_ID IS NOT NULL) THEN
            SELECT C_CASH.NAME, C_CASH.STATEMENTDATE
              INTO v_nameCash, v_dateCash
            FROM C_CASH, C_CASHLINE
            WHERE C_CASH.C_CASH_ID = C_CASHLINE.C_CASH_ID
              AND C_CASHLINE.C_CASHLINE_ID = v_CashLine_ID;
            RAISE EXCEPTION '%', '@ManagedDebtPaymentOrderCash@'||v_nameCash||' '||'@Bydate@'||v_dateCash ; --OBTG:-20000--
          END IF;
          IF (v_Cancel_Processed='Y' AND v_ispaid='N') THEN
            SELECT documentno, datetrx
              INTO v_documentno_Settlement, v_dateSettlement
            FROM C_SETTLEMENT
            WHERE C_SETTLEMENT_ID = v_Settlement_Cancel_ID;
            RAISE EXCEPTION '%', '@ManagedDebtPaymentOrderCancel@'||v_documentno_Settlement||' '||'@Bydate@'||v_dateSettlement ; --OBTG:-20000--
          END IF;
        END IF;

        RAISE NOTICE '%','Re-Activating ' || v_DocSubTypeSO || ': ' || v_Record_ID ;
        IF(v_DocSubTypeSO IN ('WI', 'WP', 'WR')) THEN
          -- Cancel existing Deli very + Invoice Documents
          PERFORM M_INOUT_CANCEL(NULL, v_Record_ID) ;
          IF (v_DocSubTypeSO<>'WP') THEN
            PERFORM C_INVOICE_CANCEL(NULL, v_Record_ID);
          END IF;
        END IF;
        -- Update Order
        v_ResultStr:='ReActivate';
        UPDATE C_ORDER
        SET DocStatus='IP', -- In Progress
            DocAction='CO',
            Processing='N',
            Processed='N',
            Updated=TO_DATE(NOW()),
            UpdatedBy=v_User
        WHERE C_Order_ID=v_Record_ID;
        UPDATE M_INOUTLINE SET C_ORDERLINE_ID = NULL
        WHERE (SELECT DISTINCT A.DOCSTATUS FROM M_INOUT A, M_INOUTLINE B, C_ORDERLINE C
               WHERE A.M_INOUT_ID = B.M_INOUT_ID AND B.C_ORDERLINE_ID = C.C_ORDERLINE_ID
                 AND C.C_ORDER_DISCOUNT_ID IS NOT NULL AND C.C_ORDER_ID = v_Record_ID) = 'VO'
                 AND C_ORDERLINE_ID IN (SELECT C_ORDERLINE_ID FROM C_ORDERLINE WHERE C_ORDER_DISCOUNT_ID IS NOT NULL 
                 AND C_ORDER_ID = v_Record_ID);
        DELETE
        FROM C_ORDERLINE
        WHERE C_ORDER_DISCOUNT_ID IS NOT NULL
          AND C_ORDER_ID=v_Record_ID;
        --ADDED BY E.ARGAL
        --Invalidate debt payments added by ALO
        UPDATE C_DEBT_PAYMENT
        SET IsValid='N',
            Updated=TO_DATE(NOW()),
            UpdatedBy=v_User
        WHERE C_Order_ID=v_Record_ID
          AND IsAutomaticGenerated='N';

        DELETE
        FROM C_CASHLINE
        WHERE C_Debt_Payment_Id IN
            (SELECT C_DEBT_PAYMENT_ID
            FROM C_DEBT_PAYMENT
            WHERE C_Order_ID=v_Record_ID
              AND COALESCE(IsAutomaticGenerated, 'Y')='Y'
            );
        DELETE
        FROM C_DEBT_PAYMENT
        WHERE C_Order_ID=v_Record_ID
          AND COALESCE(IsAutomaticGenerated, 'Y')='Y';
        /*
        * Undo inventory reservation
        */
        DECLARE
          Cur_ResLine RECORD;
          v_QtySO NUMERIC; -- Reserved
          v_QtyOrderSO NUMERIC;
          v_QtyPO NUMERIC; -- Ordered
          v_QtyOrderPO NUMERIC;
        BEGIN
          v_ResultStr:='ReserveInventory';
          -- For all lines needing reservation
          FOR Cur_ResLine IN
            (SELECT l.M_Warehouse_ID, l.M_Product_ID, l.M_AttributeSetInstance_ID, l.C_OrderLine_ID,
                 l.QtyOrdered AS Qty, l.QUANTITYORDER, l.qtyreserved, l.qtydelivered,
                l.C_UOM_ID, l.M_PRODUCT_UOM_ID
             FROM C_ORDERLINE l, M_PRODUCT p
             WHERE l.C_Order_ID=v_Record_ID  -- Reserve Products (not: services, null products)
               AND l.M_Product_ID=p.M_Product_ID
               AND p.IsStocked='Y'
               AND p.ProductType='I' 
             )
            LOOP
            -- Qty corrected for SO/PO
            IF (v_DocSubTypeSO IS NULL) THEN
              v_QtySO:=0;
              v_QtyOrderSO:=NULL;
              v_QtyPO:=Cur_ResLine.qtydelivered-Cur_ResLine.qty;
              v_QtyOrderPO:=NULL;
              IF (Cur_ResLine.QtyDelivered=0) THEN
                v_QtyOrderPO := -Cur_ResLine.QuantityOrder;
              ELSIF Cur_ResLine.M_Product_UOM_ID IS NOT NULL THEN
                v_QtyOrderPO := -C_Uom_Convert(v_QtyPO, Cur_ResLine.C_UOM_ID, Cur_ResLine.M_Product_UOM_ID, 'Y');
              END IF;
            ELSE
              v_QtySO:=-Cur_ResLine.QtyReserved;
              IF (Cur_ResLine.QtyReserved=Cur_ResLine.Qty) THEN
                v_QtyOrderSO := -Cur_ResLine.QuantityOrder;
              ELSIF Cur_ResLine.M_Product_UOM_ID IS NOT NULL THEN
                v_QtyOrderSO := -C_Uom_Convert(v_QtySO, Cur_ResLine.C_UOM_ID, Cur_ResLine.M_Product_UOM_ID, 'Y');
              END IF;
              v_QtyPO:=0;
              v_QtyOrderPO:=NULL;
            END IF;
            IF ((v_DocStatus<>'IP' OR v_DocAction<>'CO') AND COALESCE(v_DocSubTypeSO, '')<>'OB') THEN
              PERFORM M_UPDATE_STORAGE_PENDING(v_Client_ID, v_Org_ID, v_UpdatedBy, Cur_ResLine.M_Product_ID, Cur_ResLine.M_Warehouse_ID, Cur_ResLine.M_AttributeSetInstance_ID, Cur_ResLine.C_UOM_ID, Cur_ResLine.M_PRODUCT_UOM_ID, v_QtySO, v_QtyOrderSO, v_QtyPO, v_QtyOrderPO) ;
            END IF;
          END LOOP;
          -- Set reserved quantity to 0
          UPDATE C_ORDERLINE
          SET QtyReserved = 0,
              Updated=TO_DATE(NOW()),
              UpdatedBy=v_User
          WHERE c_orderline_id IN (select c_orderline_id
                                   from c_orderline
                                   where c_order_id = v_Record_id);
        END;
        /**
        *  Manage Stock Reservations
        */
        SELECT COUNT(1) INTO v_count
        FROM ad_preference
        WHERE property = 'StockReservations';
        IF (v_count > 1) THEN
          v_dummy := AD_GET_PREFERENCE_VALUE('StockReservations', 'Y', v_client_id, v_org_id, NULL, NULL, NULL);
        ELSIF (v_count = 1) THEN
          UPDATE c_orderline
          SET so_res_status = NULL
          WHERE c_order_id = v_Record_id;
          UPDATE c_order
          SET so_res_status = NULL
          WHERE c_order_id = v_record_id;
        END IF;

        --ADDED BY P.SAROBE but to be deprecated 26052007
        SELECT MAX(C_CASHLINE_ID)
          INTO v_CashLine_ID
        FROM C_CASHLINE
        WHERE C_ORDER_ID=v_Record_ID;
        IF (v_CashLine_ID IS NOT NULL) THEN
          SELECT PROCESSED
            INTO v_IsProcessed
          FROM C_CASH, C_CASHLINE
          WHERE C_CASH.C_CASH_ID=C_CASHLINE.C_CASH_ID
            AND C_CASHLINE_ID=v_CashLine_ID;
          IF (v_IsProcessed='N') THEN
            DELETE FROM C_CASHLINE WHERE C_CASHLINE_ID=v_CashLine_ID;
          ELSE
            SELECT C_CASH.NAME, C_CASH.STATEMENTDATE, C_CASHLINE.LINE
              INTO v_nameCash, v_dateCash, v_Line
            FROM C_CASH, C_CASHLINE
            WHERE C_CASH.C_CASH_ID = C_CASHLINE.C_CASH_ID
              AND C_CASHLINE.C_CASHLINE_ID = v_CashLine_ID;
            RAISE EXCEPTION '%', '@Ordercahslineprocessed@'||v_nameCash||' '||'@Bydate@'||v_dateCash||' '||'@line@'||v_Line ; --OBTG:-20000--
          END IF;
        END IF;

        UPDATE C_ORDER
        SET DocStatus='DR', -- Draft
            DocAction='CO',
            Processing='N',
            Updated=TO_DATE(NOW()),
            UpdatedBy=v_User
        WHERE C_Order_ID=v_Record_ID;

        FINISH_PROCESS:=TRUE;
      END IF;
    END IF;--FINISH_PROCESS
    IF (NOT FINISH_PROCESS) THEN
      SELECT COUNT(*)
        INTO v_Count
      FROM C_ORDER C, C_DOCTYPE
      WHERE C_DocType.DocBaseType IN ('SOO', 'POO')
        AND C_DocType.IsSOTrx=C.ISSOTRX
        AND AD_ISORGINCLUDED(C.AD_Org_ID,C_DocType.AD_Org_ID, C.AD_Client_ID) <> -1
        AND C.C_DOCTYPETARGET_ID = C_DOCTYPE.C_DOCTYPE_ID
        AND C.C_ORDER_ID = v_Record_ID;
      IF (v_Count=0) THEN
        RAISE EXCEPTION '%', '@NotCorrectOrgDoctypeOrder@' ; --OBTG:-20000--
      END IF;

      SELECT COUNT(*)
        INTO v_Count
      FROM C_ORDER C, C_ORDERLINE OL
      WHERE C.C_ORDER_ID = OL.C_ORDER_ID
        AND AD_ISORGINCLUDED(OL.AD_Org_ID, C.AD_Org_ID, C.AD_Client_ID) = -1
        AND C.C_ORDER_ID = v_Record_ID;
      IF (v_Count>0) THEN
        RAISE EXCEPTION '%', '@NotCorrectOrgLines@' ; --OBTG:-20000--
      END IF;
      

      /**
      * Close Order - prepare
      */
      DECLARE
          Cur_Inventory RECORD;
          v_QtyOrdered NUMERIC;
          v_QuantityOrder NUMERIC;
          v_linenetamt NUMERIC;
          v_linegrossamt NUMERIC;
          v_ProductUOM M_PRODUCT_UOM.C_UOM_ID%TYPE;
      BEGIN

        -- When closing the order it calculates the difference between the ordered and received/delivered quantities ant it
        -- updates the m_storage_pending.
        IF (v_DocAction='CL') THEN
          -- Cancel undelivered Items
          IF (v_isSoTrx='Y') THEN --Sales orders
            FOR Cur_Inventory IN (
              SELECT QtyInvoiced, QtyDelivered ,QtyOrdered, QuantityOrder, priceactual, gross_unit_price,
	      
	      C_ORDERLINE_ID AS ID,
	      M_Product_ID,
	      M_Warehouse_ID,
	      M_AttributeSetInstance_ID,
	      C_UOM_ID,
	      M_PRODUCT_UOM_ID,
          C_Currency_ID
	      FROM C_ORDERLINE
	      WHERE C_Order_ID=v_Record_ID
                AND QtyOrdered <> (SELECT (CASE WHEN (qtyinvoiced = 0) THEN QtyDelivered ELSE 
			  	    (CASE WHEN (QtyDelivered = 0) THEN qtyinvoiced ELSE 
					(CASE WHEN (QtyDelivered < 0 AND qtyinvoiced < 0) THEN LEAST(QtyDelivered, qtyinvoiced) ELSE GREATEST(QtyDelivered, qtyinvoiced) END) END) END)
                                  FROM C_ORDERLINE COL
                                  WHERE COL.C_ORDERLINE_ID = C_ORDERLINE.C_ORDERLINE_ID)
                AND m_product_id IS NOT NULL
            )
            LOOP
              v_QtyOrdered := CASE WHEN (Cur_Inventory.QtyDelivered < 0) THEN LEAST(Cur_Inventory.QtyDelivered, Cur_Inventory.QtyInvoiced) ELSE GREATEST(Cur_Inventory.QtyDelivered, Cur_Inventory.QtyInvoiced) END;
              v_linenetamt := ROUND(v_QtyOrdered * Cur_Inventory.priceactual, C_GET_CURRENCY_PRECISION(Cur_Inventory.C_Currency_ID, 'A'));
              v_linegrossamt := ROUND(v_QtyOrdered * Cur_Inventory.gross_unit_price, C_GET_CURRENCY_PRECISION(Cur_Inventory.C_Currency_ID, 'A'));
              SELECT MAX(UOM.C_UOM_ID)
              INTO v_ProductUOM
              FROM M_PRODUCT_UOM UOM 
              WHERE UOM.M_PRODUCT_UOM_ID=Cur_Inventory.M_PRODUCT_UOM_ID;
              v_QuantityOrder := CASE WHEN Cur_Inventory.M_PRODUCT_UOM_ID IS NULL THEN Cur_Inventory.QuantityOrder
                                ELSE (c_uom_convert((CASE WHEN (Cur_Inventory.QtyDelivered < 0) THEN LEAST(Cur_Inventory.QtyDelivered, Cur_Inventory.QtyInvoiced) ELSE GREATEST(Cur_Inventory.QtyDelivered, Cur_Inventory.QtyInvoiced) END),
                    Cur_Inventory.C_UOM_ID, v_ProductUOM,'Y')) END;

              IF (Cur_Inventory.QtyOrdered <> v_QtyOrdered) THEN
                PERFORM M_UPDATE_STORAGE_PENDING(v_Client_ID, v_Org_ID, v_UpdatedBy, Cur_Inventory.M_Product_ID, Cur_Inventory.M_Warehouse_ID, Cur_Inventory.M_AttributeSetInstance_ID,
                Cur_Inventory.C_UOM_ID, Cur_Inventory.M_PRODUCT_UOM_ID, -(Cur_Inventory.QtyOrdered - v_QtyOrdered), -(Cur_Inventory.QuantityOrder - v_QuantityOrder), 0, null);
              END IF;

              -- UPDATE C_ORDERLINE
              UPDATE C_ORDERLINE
              SET QtyOrdered=v_QtyOrdered,
                linenetamt=v_linenetamt,
                line_gross_amount=v_linegrossamt,
                QuantityOrder=v_QuantityOrder,
                Updated=TO_DATE(NOW())
              WHERE C_ORDERLINE_ID = Cur_Inventory.ID;
            END LOOP;
            -- For Purchase orders, M_MatchPO table used. Notice that only delivered lines(C_Invoiceline_Id is null) using
          ELSE
            FOR Cur_Inventory IN (
              SELECT 
                COALESCE((SELECT SUM(CASE WHEN M_MATCHPO.M_INOUTLINE_ID IS NULL THEN M_MATCHPO.QTY ELSE 0 END)
                FROM M_MATCHPO
                WHERE M_MATCHPO.C_ORDERLINE_ID=C_ORDERLINE.C_ORDERLINE_ID), 0) AS QtyDelivered,
		COALESCE((SELECT   SUM(CASE WHEN M_MATCHPO.C_INVOICELINE_ID IS NULL THEN M_MATCHPO.QTY ELSE 0 END)
                FROM M_MATCHPO
                WHERE M_MATCHPO.C_ORDERLINE_ID=C_ORDERLINE.C_ORDERLINE_ID), 0) AS QtyInvoiced,
                QtyOrdered,
                QuantityOrder,
		priceactual,
		gross_unit_price,
		linenetamt,
                C_ORDERLINE_ID AS ID,
	        M_Product_ID,
	        M_Warehouse_ID,
	        M_AttributeSetInstance_ID,
	        C_UOM_ID,
	        M_PRODUCT_UOM_ID,
	        C_Currency_ID
              FROM C_ORDERLINE
              WHERE C_ORDERLINE.C_ORDER_ID=v_Record_ID
                AND qtyordered <> COALESCE((
                    SELECT (CASE WHEN (SUM(CASE WHEN M_MATCHPO.M_INOUTLINE_ID IS NULL THEN M_MATCHPO.QTY ELSE 0 END) = 0) 
				THEN SUM(CASE WHEN M_MATCHPO.C_INVOICELINE_ID IS NULL THEN M_MATCHPO.QTY ELSE 0 END) ELSE 
					(CASE WHEN (SUM(CASE WHEN M_MATCHPO.C_INVOICELINE_ID IS NULL THEN M_MATCHPO.QTY ELSE 0 END) = 0) 
						THEN SUM(CASE WHEN M_MATCHPO.M_INOUTLINE_ID IS NULL THEN M_MATCHPO.QTY ELSE 0 END)  
						ELSE (CASE WHEN (SUM(CASE WHEN M_MATCHPO.M_INOUTLINE_ID IS NULL THEN M_MATCHPO.QTY ELSE 0 END) < 0 AND SUM(CASE WHEN M_MATCHPO.C_INVOICELINE_ID IS NULL THEN M_MATCHPO.QTY ELSE 0 END) < 0)  
							THEN LEAST(SUM(CASE WHEN M_MATCHPO.M_INOUTLINE_ID IS NULL THEN M_MATCHPO.QTY ELSE 0 END),SUM(CASE WHEN M_MATCHPO.C_INVOICELINE_ID IS NULL THEN M_MATCHPO.QTY ELSE 0 END)) 
							ELSE GREATEST(SUM(CASE WHEN M_MATCHPO.M_INOUTLINE_ID IS NULL THEN M_MATCHPO.QTY ELSE 0 END),SUM(CASE WHEN M_MATCHPO.C_INVOICELINE_ID IS NULL THEN M_MATCHPO.QTY ELSE 0 END)) END) 
					END)
				END)
                    FROM M_MATCHPO
                    WHERE M_MATCHPO.C_ORDERLINE_ID=C_ORDERLINE.C_ORDERLINE_ID
                    ), 0)
            )
            LOOP
              v_QtyOrdered := COALESCE(CASE WHEN (Cur_Inventory.QtyDelivered < 0) THEN LEAST(Cur_Inventory.QtyDelivered, Cur_Inventory.QtyInvoiced) ELSE GREATEST(Cur_Inventory.QtyDelivered, Cur_Inventory.QtyInvoiced) END, 0);
              v_linenetamt := ROUND(COALESCE(v_QtyOrdered, 0) * Cur_Inventory.priceactual, C_GET_CURRENCY_PRECISION(Cur_Inventory.C_Currency_ID, 'A'));
              v_linegrossamt := ROUND(COALESCE(v_QtyOrdered, 0) * Cur_Inventory.gross_unit_price, C_GET_CURRENCY_PRECISION(Cur_Inventory.C_Currency_ID, 'A'));
              SELECT MAX(UOM.C_UOM_ID)
              INTO v_ProductUOM
              FROM M_PRODUCT_UOM UOM 
              WHERE UOM.M_PRODUCT_UOM_ID=Cur_Inventory.M_PRODUCT_UOM_ID;
              v_QuantityOrder := CASE WHEN Cur_Inventory.M_PRODUCT_UOM_ID IS NULL THEN Cur_Inventory.QuantityOrder
                                ELSE (COALESCE(c_uom_convert((CASE WHEN (Cur_Inventory.QtyDelivered < 0) THEN LEAST(Cur_Inventory.QtyDelivered, Cur_Inventory.QtyInvoiced) ELSE GREATEST(Cur_Inventory.QtyDelivered, Cur_Inventory.QtyInvoiced) END),
                    Cur_Inventory.C_UOM_ID, v_ProductUOM,'Y'), 0)) END;
              IF (Cur_Inventory.QtyOrdered <> v_QtyOrdered) THEN
                PERFORM M_UPDATE_STORAGE_PENDING(v_Client_ID, v_Org_ID, v_UpdatedBy, Cur_Inventory.M_Product_ID, Cur_Inventory.M_Warehouse_ID, Cur_Inventory.M_AttributeSetInstance_ID,
                Cur_Inventory.C_UOM_ID, Cur_Inventory.M_PRODUCT_UOM_ID, 0, null, -(Cur_Inventory.QtyOrdered - v_QtyOrdered), -(Cur_Inventory.QuantityOrder - v_QuantityOrder));
              END IF;

              -- UPDATE C_ORDERLINE
              UPDATE C_ORDERLINE
              SET QtyOrdered=v_QtyOrdered,
                linenetamt=v_linenetamt,
                line_gross_amount=v_linegrossamt,
                QuantityOrder=v_QuantityOrder,
                Updated=TO_DATE(NOW())
              WHERE C_ORDERLINE_ID = Cur_Inventory.ID;
            END LOOP;
          END IF;
          -- if there is no change, the tax calculation, etc. is not needed.
          -- potential problem, if posted (i.e. encumbered) for full amount
          -- and the rest then cancelled out.
        END IF;
      END;

      /**
      *Update Product purchasing Plan Table
      * Return Material orders do not update the last price.
      */
      IF (v_isSoTrx ='N' AND v_isreturndoctype = 'N') THEN
        FOR Cur_OrderLine IN (SELECT * FROM C_ORDERLINE WHERE C_Order_Id =  v_Record_ID)
        LOOP
          UPDATE M_PRODUCT_PO SET PriceLastPO=Cur_OrderLine.PriceActual 
          Where C_BPARTNER_ID = v_CBPartner_ID AND M_PRODUCT_ID = Cur_OrderLine.M_PRODUCT_ID
          AND Ad_Isorgincluded(Cur_OrderLine.AD_ORG_ID,AD_ORG_ID, Cur_OrderLine.AD_Client_ID) <> -1;
        END LOOP;
      END IF;
      /**
      * Void Order - prepare
      */
      IF (v_DocAction='VO') THEN
        -- Cancel all Items
        UPDATE C_ORDERLINE
          SET QtyOrdered=0,
          --MODIFIED BY F.IRIAZABAL
          QuantityOrder = CASE WHEN M_PRODUCT_UOM_ID IS NULL THEN NULL ELSE 0 END,
          LineNetAmt=0,
          Updated=TO_DATE(NOW())
        WHERE C_Order_ID=v_Record_ID
          AND QtyOrdered<>0;
      END IF;

     /**************************************************************************
      * Start Processing ------------------------------------------------------
      *************************************************************************/
      -- Check the header belongs to a organization where transactions are posible and ready to use
      SELECT AD_Org.IsReady, Ad_OrgType.IsTransactionsAllowed
        INTO v_is_ready, v_is_tr_allow
      FROM C_ORDER, AD_Org, AD_OrgType
      WHERE AD_Org.AD_Org_ID=C_ORDER.AD_Org_ID
        AND AD_Org.AD_OrgType_ID=AD_OrgType.AD_OrgType_ID
        AND C_ORDER.C_ORDER_ID=v_Record_ID;
      IF (v_is_ready='N') THEN
        RAISE EXCEPTION '%', '@OrgHeaderNotReady@'; --OBTG:-20000--
      END IF;
      IF (v_is_tr_allow='N') THEN
        RAISE EXCEPTION '%', '@OrgHeaderNotTransAllowed@'; --OBTG:-20000--
      END IF;
      SELECT AD_ORG_CHK_DOCUMENTS('C_ORDER', 'C_ORDERLINE', v_Record_ID, 'C_ORDER_ID', 'C_ORDER_ID') INTO v_is_included FROM dual;
      IF (v_is_included=-1) THEN
        RAISE EXCEPTION '%', '@LinesAndHeaderDifferentLEorBU@'; --OBTG:-20000--
      END IF;

      IF (p_PInstance_ID IS NOT NULL) THEN
        v_ResultStr:='LockingOrder';
        UPDATE C_ORDER  SET Processing='Y'  WHERE C_Order_ID=v_Record_ID;
        -- COMMIT;
        -- Now, needs to go to END_PROCESSING to unlock
      END IF;
      /**
      * Allowed Actions:  AProve, COmplete, PRocess, CLose, VOid
      */
      IF (v_DocAction IN('AP', 'CO', 'PR', 'CL', 'VO')) THEN
        NULL;
      ELSE
        RAISE EXCEPTION '%', '@ActionNotAllowedHere@' ; --OBTG:-20000--
      END IF;

      SELECT COUNT(*)
        INTO v_count
      FROM AD_CLIENTINFO
      WHERE AD_CLIENT_ID=v_Client_ID
        AND CHECKORDERORG='Y';
      IF (v_count > 0) THEN
        v_ResultStr:='CheckingRestrictions - C_ORDER ORG IS IN C_BPARTNER ORG TREE';
        SELECT COUNT(*)
          INTO v_count
        FROM C_ORDER c, C_BPARTNER bp
        WHERE c.C_Order_ID=v_Record_ID
          AND c.C_BPARTNER_ID=bp.C_BPARTNER_ID
          AND Ad_Isorgincluded(c.AD_ORG_ID, bp.AD_ORG_ID, bp.AD_CLIENT_ID)=-1;
        IF (v_count > 0) THEN
          RAISE EXCEPTION '%', '@NotCorrectOrgBpartnerOrder@' ; --OBTG:-20000--
        END IF;
      END IF;

     /**************************************************************************
      * Calculate promotions                                                   
      *************************************************************************/
      IF (v_DocAction = 'CO' AND v_isreturndoctype = 'N' AND v_recalculateDiscounts = 'Y') THEN
         PERFORM M_PROMOTION_CALCULATE('O', v_Record_ID, v_User);
      END IF;

     /**************************************************************************
      * Calculate Discounts
      *************************************************************************/

      -- if sales order was created from quotation with "firm quotation" check
      -- then discounts are not recalculated
      IF (v_recalculateDiscounts = 'Y') THEN
        -- Delete first previous discounts (if possible) and then recalculate them
        UPDATE C_ORDER
        SET DocStatus='IP', -- In progress
            Processing='N',
            Processed='N',
            Updated=TO_DATE(NOW()),
            UpdatedBy=v_User
        WHERE C_Order_ID=v_Record_ID;

        DELETE
        FROM C_ORDERLINE
        WHERE C_ORDER_DISCOUNT_ID IS NOT NULL
          AND C_ORDER_ID = v_Record_ID
          AND NOT EXISTS (SELECT C_INVOICELINE_ID FROM C_INVOICELINE WHERE C_INVOICELINE.C_ORDERLINE_ID = C_ORDERLINE.C_ORDERLINE_ID)
          AND NOT EXISTS (SELECT M_INOUTLINE_ID FROM M_INOUTLINE WHERE M_INOUTLINE.C_ORDERLINE_ID = C_ORDERLINE.C_ORDERLINE_ID)
          AND NOT EXISTS (SELECT M_MATCHPO_ID FROM M_MATCHPO WHERE M_MATCHPO.C_ORDERLINE_ID = C_ORDERLINE.C_ORDERLINE_ID);

        UPDATE C_ORDERLINE
        SET pricelist = 0, priceactual = 0, pricelimit = 0, linenetamt = 0, pricestd = 0
        WHERE C_ORDER_DISCOUNT_ID IS NOT NULL
          AND C_ORDER_ID=v_Record_ID;

        UPDATE C_ORDER
        SET DocStatus=v_DocStatus, -- restore
            Processing=v_IsProcessing,
            Processed=v_IsProcessed,
            Updated=TO_DATE(NOW()),
            UpdatedBy=v_User
        WHERE C_Order_ID=v_Record_ID;

        v_CumDiscount:=0;
        v_OldCumDiscount:=0;
        v_Line:=10;
        v_precision:=0;
        SELECT MAX(LINE)
          INTO v_OrderLineSeqNo
        FROM C_ORDERLINE
        WHERE C_ORDER_ID=v_Record_ID;
        SELECT PricePrecision INTO v_precision
        FROM C_ORDER o, C_CURRENCY c
        WHERE o.C_ORDER_ID = v_Record_ID AND  o.C_CURRENCY_ID = c.C_CURRENCY_ID;
        FOR Cur_COrderDiscount IN
           (SELECT C_ORDER_DISCOUNT.C_ORDER_DISCOUNT_ID, C_DISCOUNT.DISCOUNT, C_DISCOUNT.M_PRODUCT_ID, C_DISCOUNT.NAME,
              C_ORDER_DISCOUNT.CASCADE, C_DISCOUNT.C_DISCOUNT_ID, M_PRODUCT.C_UOM_ID
            FROM C_ORDER_DISCOUNT, C_DISCOUNT, M_PRODUCT
            WHERE C_ORDER_DISCOUNT.C_DISCOUNT_ID=C_DISCOUNT.C_DISCOUNT_ID
              AND C_DISCOUNT.M_PRODUCT_ID=M_PRODUCT.M_PRODUCT_ID
              AND C_ORDER_DISCOUNT.C_ORDER_ID=v_Record_ID
              AND C_ORDER_DISCOUNT.ISACTIVE='Y'
              AND C_DISCOUNT.ISACTIVE='Y'
            ORDER BY C_ORDER_DISCOUNT.LINE
            )
        LOOP
          v_CumDiscount:=(1-v_OldCumDiscount) * Cur_COrderDiscount.Discount/100;
          v_OldCumDiscount:=v_OldCumDiscount + v_CumDiscount;
          FOR Cur_TaxDiscount IN
             (SELECT C_ORDERLINE.C_TAX_ID,
                SUM(C_ORDERLINE.LINENETAMT) AS LINENETAMT,
                SUM(C_ORDERLINE.LINE_GROSS_AMOUNT) AS LINEGROSSAMT
              FROM C_ORDERLINE
              WHERE C_ORDER_ID=v_Record_ID
                AND C_ORDERLINE.LINENETAMT<>0
                AND C_ORDER_DISCOUNT_ID IS NULL
              GROUP BY C_TAX_ID
              )
          LOOP
            IF (v_istaxincluded = 'Y') THEN
              IF (Cur_COrderDiscount.CASCADE='Y') THEN
                v_line_gross_amount:=(-1) * Cur_TaxDiscount.LINEGROSSAMT * v_CumDiscount;
              ELSE
                v_line_gross_amount:=(-1) * Cur_TaxDiscount.LINEGROSSAMT * Cur_COrderDiscount.Discount/100;
              END IF;
              v_Discount:= C_GET_NET_PRICE_FROM_GROSS(Cur_TaxDiscount.C_TAX_ID, v_line_gross_amount, 0, v_precision, 1);
              v_gross_unit_price:= v_line_gross_amount;
            ELSE
              IF (Cur_COrderDiscount.CASCADE='Y') THEN
                v_Discount:=(-1) * Cur_TaxDiscount.LINENETAMT * v_CumDiscount;
              ELSE
                v_Discount:=(-1) * Cur_TaxDiscount.LINENETAMT * Cur_COrderDiscount.Discount/100;
              END IF;
              v_gross_unit_price:= 0;
              v_line_gross_amount:= 0;
            END IF;

            SELECT COUNT(*) INTO v_DiscountExist FROM C_ORDERLINE
            WHERE C_ORDERLINE.C_ORDER_DISCOUNT_ID = Cur_COrderDiscount.C_ORDER_DISCOUNT_ID
              AND C_ORDERLINE.C_TAX_ID = Cur_TaxDiscount.C_TAX_ID;

            IF (v_DiscountExist = 0) THEN
              v_OrderLineSeqNo:=10 + v_OrderLineSeqNo;
              v_OrderLine:=get_uuid();
              INSERT INTO c_orderline
                (
                  c_orderline_id, ad_client_id, ad_org_id, isactive, created, createdby,
                  updated, updatedby, c_order_id, line, c_bpartner_id, c_bpartner_location_id,
                  dateordered, datepromised, datedelivered, dateinvoiced, description,
                  m_product_id, m_warehouse_id, directship, c_uom_id, qtyordered,
                  qtyreserved, qtydelivered, qtyinvoiced, m_shipper_id, c_currency_id,
                  pricelist, priceactual, pricelimit, linenetamt, discount, freightamt,
                  c_charge_id, chargeamt, c_tax_id, s_resourceassignment_id, ref_orderline_id,
                  m_attributesetinstance_id, isdescription, quantityorder, m_product_uom_id,
                  m_offer_id, pricestd, C_ORDER_DISCOUNT_ID,
                  gross_unit_price, taxbaseamt,line_gross_amount
                )
              VALUES
                (
                  v_OrderLine, v_Client_ID, v_Org_ID, 'Y', TO_DATE(NOW()), v_UpdatedBy,
                  TO_DATE(NOW()), v_UpdatedBy, v_Record_ID, v_OrderLineSeqNo, NULL, NULL,
                  TO_DATE(NOW()), TO_DATE(NOW()), TO_DATE(NOW()), TO_DATE(NOW()), Cur_COrderDiscount.NAME,
                  Cur_COrderDiscount.M_PRODUCT_ID, v_M_Warehouse_ID, 'N', Cur_COrderDiscount.C_UOM_ID, 1,
                  0, 0, 0, NULL, v_c_currency_id,
                  ROUND(v_Discount,v_precision), ROUND(v_Discount,v_precision), ROUND(v_Discount,v_precision), ROUND(v_Discount,v_precision), 0, 0,
                  NULL, NULL, Cur_TaxDiscount.C_TAX_ID, NULL, NULL,
                  NULL, 'N', NULL, NULL,
                  NULL, ROUND(v_Discount,v_precision), NULL,
                  ROUND(v_gross_unit_price, v_precision), ROUND(v_Discount,v_precision),ROUND(v_line_gross_amount, v_precision)
                );

              UPDATE C_ORDERLINE
              SET C_ORDER_DISCOUNT_ID=Cur_COrderDiscount.C_ORDER_DISCOUNT_ID
              WHERE C_ORDERLINE_ID=v_OrderLine;
            ELSE
              UPDATE C_ORDERLINE 
              SET pricelist = ROUND(v_Discount,v_precision), priceactual = ROUND(v_Discount,v_precision), pricelimit = ROUND(v_Discount,v_precision), linenetamt = ROUND(v_Discount,v_precision), pricestd = ROUND(v_Discount,v_precision)
              WHERE C_ORDERLINE.C_ORDER_DISCOUNT_ID = Cur_COrderDiscount.C_ORDER_DISCOUNT_ID
                AND C_ORDERLINE.C_TAX_ID = Cur_TaxDiscount.C_TAX_ID;
            END IF;
          END LOOP;
          v_Line:=v_Line + 10;
        END LOOP;
      END IF;

      /**
      * Convert to Target DocType
      */
      DECLARE
        v_DocSubTypeSO_Target VARCHAR(60) ;
      BEGIN
        v_ResultStr:='ConvertingDocType';
        IF (v_DocType_ID <> v_DocTypeTarget_ID) THEN
          -- New
          IF (v_DocStatus='DR' OR v_DocType_ID='0') THEN
            -- Update to Target Document Type
            WHILE(v_DocType_ID<>v_DocTypeTarget_ID)
            LOOP
              BEGIN
                v_ResultStr:='UpdateDocType';
                UPDATE C_ORDER
                SET C_DocType_ID=v_DocTypeTarget_ID,
                    Updated=TO_DATE(NOW()),
                    UpdatedBy=v_User
                WHERE C_Order_ID=v_Record_ID;
                v_DocType_ID:=v_DocTypeTarget_ID;
              EXCEPTION
              WHEN OTHERS THEN
                v_ResultStr:='UpdateDocumentNo';
                UPDATE C_ORDER  SET DocumentNo=DocumentNo || '.'  WHERE C_Order_ID=v_Record_ID;
              END;
            END LOOP;
          ELSE
            v_ResultStr:='GetTargetDocType';
            SELECT DocSubTypeSO
              INTO v_DocSubTypeSO_Target
            FROM C_DOCTYPE
            WHERE C_DocType_ID=v_DocTypeTarget_ID;
            RAISE NOTICE '%','Changing DocType from ' || v_DocSubTypeSO || ' to ' || v_DocSubTypeSO_Target ;
            -- Change Offer to anything, Change InProcess to anything
            IF (v_DocSubTypeSO IN('ON', 'OB') OR v_DocStatus='IP') THEN
              -- Update to Target Document Type
              WHILE(v_DocType_ID<>v_DocTypeTarget_ID)
              LOOP
                BEGIN
                  v_ResultStr:='UpdateDocType';
                  UPDATE C_ORDER
                  SET C_DocType_ID=v_DocTypeTarget_ID,
                      Updated=TO_DATE(NOW()),
                      UpdatedBy=v_User
                  WHERE C_Order_ID=v_Record_ID;
                  v_DocType_ID:=v_DocTypeTarget_ID;
                EXCEPTION
                WHEN OTHERS THEN
                  v_ResultStr:='UpdateDocumentNo';
                  UPDATE C_ORDER  SET DocumentNo=DocumentNo || '.'  WHERE C_Order_ID=v_Record_ID;
                END;
              END LOOP;
            ELSE
              -- Change Back
              UPDATE C_ORDER
                SET C_DocTypeTarget_ID=v_DocType_ID
              WHERE C_Order_ID=v_Record_ID;
              RAISE EXCEPTION '%', '@CannotChangeDocType@' ; --OBTG:-20000--
            END IF;
          END IF;
        END IF; -- C_DocType_ID <> C_DocTypeTarget_ID
      END; -- Conversion

    /**
      * Get DocSubTypeSO + Is it Binding :1:2
      */
      v_ResultStr:='TestBinding DocType_ID=' || v_DocType_ID;
      SELECT CASE DocSubTypeSO WHEN 'ON' THEN 'N' ELSE 'Y' END, DocSubTypeSO
        INTO v_IsBinding, v_DocSubTypeSO
      FROM C_DOCTYPE
      WHERE C_DocType_ID=v_DocType_ID;
      RAISE NOTICE '%','DocSubTypeSO=' || v_DocSubTypeSO || ' IsBinding=' || v_IsBinding ;

    /**************************************************************************
      * Resolve not-stocked BOMs
      *************************************************************************/
      DECLARE
        -- Order Lines with non-stocked BOMs
        CUR_BOM_Line RECORD;
        -- BOM Product List
        CountNo NUMERIC;
      BEGIN
        FOR CUR_BOM_Line IN
          (SELECT l.c_orderline_id
           FROM C_ORDERLINE l
           WHERE l.C_Order_ID=v_Record_ID
             AND l.IsActive='Y'
             AND l.explode='N'
             AND EXISTS
               (SELECT *
                FROM M_PRODUCT p
                WHERE l.M_Product_ID=p.M_Product_ID
                  AND p.IsBOM='Y'
                  AND p.IsStocked='N'
                )
              ORDER BY l.Line
             )
        LOOP
          PERFORM M_EXPLODEBOMNOTSTOCK(null, CUR_BOM_Line.c_orderline_ID);
        END LOOP;
      END;
    /**************************************************************************
      * Always check and (un) Reserve Inventory  (counterpart: M_InOut_Post)
      *************************************************************************/
      IF (v_DocAction<>'CL') THEN
        DECLARE
          Cur_ResLine RECORD;

          v_QtySO       NUMERIC; -- Reserved
          v_QtyOrderSO  NUMERIC;
          v_QtyPO       NUMERIC; -- Ordered
          v_QtyOrderPO  NUMERIC;
        BEGIN
          v_ResultStr := 'ReserveInventory';
          -- For all lines needing reservation
          FOR Cur_ResLine IN (SELECT l.M_Warehouse_ID, l.M_Product_ID, l.M_AttributeSetInstance_ID, l.C_OrderLine_ID,
                -- Target Level = 0 if DirectShip='Y' or Binding='N'
                (CASE l.DirectShip WHEN 'Y' THEN 0 ELSE (CASE v_IsBinding WHEN 'N' THEN 0 ELSE l.QtyOrdered END) END)
                 -l.QtyReserved-l.QtyDelivered AS Qty, l.QUANTITYORDER,
                l.QtyReserved, l.QtyDelivered, l.DatePromised, l.C_UOM_ID,
                l.M_PRODUCT_UOM_ID
              FROM C_ORDERLINE l, M_PRODUCT p
              WHERE l.C_Order_ID=v_Record_ID
                -- Reserve Products (not: services, null products) --
                AND l.M_Product_ID=p.M_Product_ID
                AND p.IsStocked='Y' AND p.ProductType='I'
                -- Target Level = 0 if DirectShip='Y' or Binding='N'
                AND (CASE l.DirectShip WHEN 'Y' THEN 0 ELSE (CASE v_IsBinding WHEN 'N' THEN 0 ELSE l.QtyOrdered END)END)
                -l.QtyReserved-l.QtyDelivered <> 0)
          LOOP
          
            -- Qty corrected for SO/PO
            IF (v_DocSubTypeSO IS NOT NULL) THEN
              v_QtySO   := Cur_ResLine.Qty;
              v_QtyOrderSO := NULL;
              IF (Cur_ResLine.QtyReserved = 0 AND Cur_ResLine.QtyDelivered = 0) THEN
                v_QtyOrderSO := Cur_ResLine.QuantityOrder;
              ELSIF (Cur_ResLine.M_Product_UOM_ID IS NOT NULL) THEN
                v_QtyOrderSO := C_Uom_Convert(v_QtySO, Cur_ResLine.C_UOM_ID, Cur_ResLine.M_Product_UOM_ID, 'Y');
              END IF;
              v_QtyPO   := 0;
              v_QtyOrderPO := NULL;
            ELSE -- PO
              v_QtySO := 0;
              v_QtyOrderSO := NULL;
              v_QtyPO := Cur_ResLine.Qty;
              v_QtyOrderPO := NULL;
              IF (Cur_ResLine.QtyReserved = 0 AND Cur_ResLine.QtyDelivered = 0) THEN
                v_QtyOrderPO := Cur_ResLine.QuantityOrder;
              ELSIF (Cur_ResLine.M_Product_UOM_ID IS NOT NULL) THEN
                v_QtyOrderPO := C_Uom_Convert(v_QtyPO, Cur_ResLine.C_UOM_ID, Cur_ResLine.M_Product_UOM_ID, 'Y');
              END IF;
            END IF;
            IF ((v_DocStatus<>'IP' OR v_DocAction<>'CO') AND COALESCE(v_DocSubTypeSO, '')<>'OB') THEN
              PERFORM M_UPDATE_STORAGE_PENDING(v_Client_ID, v_Org_ID, v_UpdatedBy, Cur_ResLine.M_Product_ID, Cur_ResLine.M_Warehouse_ID, Cur_ResLine.M_AttributeSetInstance_ID,
              Cur_ResLine.C_UOM_ID, Cur_ResLine.M_PRODUCT_UOM_ID, v_QtySO, v_QtyOrderSO, v_QtyPO, v_QtyOrderPO);
            END IF;
            RAISE NOTICE '%','Reserved Warehouse=' || Cur_ResLine.M_Warehouse_ID || ', Product=' || Cur_ResLine.M_Product_ID || ', Attrib=' || Cur_ResLine.M_AttributeSetInstance_ID || ', Qty=' || v_QtySO || '/' || v_QtyPO;

            -- Update Order Line
            IF (v_DocSubTypeSO IS NOT NULL) THEN
              UPDATE C_ORDERLINE
              SET QtyReserved = QtyReserved + v_QtySO
              WHERE C_OrderLine_ID = Cur_ResLine.C_OrderLine_ID;
            END IF;
            GET DIAGNOSTICS  rowcount:=ROW_COUNT;
            IF (rowcount <> 1) THEN
              IF (p_PInstance_ID IS NOT NULL) THEN
                -- ROLLBACK;
                v_ResultStr := 'LockingOrder';
                UPDATE C_ORDER
                SET Processing = 'N',
                Updated=TO_DATE(NOW()),
                UpdatedBy=v_User
                WHERE C_Order_ID = v_Record_ID;
                RAISE EXCEPTION '%','DATA_EXCEPTION';
                -- COMMIT;
              END IF;
              RAISE EXCEPTION '%', '@20011@'; --OBTG:-20000--
            END IF;
          END LOOP; -- For all lines needing reservation
        END;
      END IF; -- Reserve Inventory

     /**************************************************************************
      * Stock Reservations management.
      *************************************************************************/
      SELECT COUNT(1) INTO v_count
      FROM ad_preference
      WHERE property = 'StockReservations';
      IF (v_count > 0) THEN
        IF (v_count > 1) THEN
          v_dummy := AD_GET_PREFERENCE_VALUE('StockReservations', 'Y', v_client_id, v_org_id, NULL, NULL, NULL);
        END IF;
        DECLARE
          v_reservation_id      VARCHAR(32); --OBTG:VARCHAR2--
          v_quantity            NUMERIC;
          v_reservedqty         NUMERIC;
          v_releasedqty         NUMERIC;
          v_allocated           NUMERIC;
          v_pendingtounreserve  NUMERIC;
          v_qtyaux              NUMERIC;
          v_res_status          M_RESERVATION.RES_STATUS%TYPE;
          v_linecount           NUMERIC;
          v_creservedcount      NUMERIC;
          v_preservedcount      NUMERIC;
          
          cur_res_stock         RECORD;
        BEGIN
          IF (v_issotrx = 'Y') THEN
            FOR cur_orderline IN (
                SELECT ol.c_orderline_id, ol.create_reservation, ol.qtyordered
                FROM c_orderline ol
                    JOIN m_product p ON ol.m_product_id = p.m_product_id
                    LEFT JOIN m_reservation r ON ol.c_orderline_id = r.c_orderline_id
                WHERE ol.c_order_id = v_record_id
                  AND ((
                      ol.qtyordered > 0
                      AND p.isstocked = 'Y'
                      AND p.producttype = 'I'
                    ) OR (
                      r.m_reservation_id IS NOT NULL
                    )
                  )
            ) LOOP
              SELECT count(*), max(m_reservation_id)
                INTO v_aux, v_reservation_id
              FROM m_reservation
              WHERE c_orderline_id = cur_orderline.c_orderline_id;
              -- Initialize so_res_status
              UPDATE c_orderline
              SET so_res_status = 'NR'
              WHERE c_orderline_id = cur_orderline.c_orderline_id;
              IF (v_aux > 1) THEN
                RAISE EXCEPTION '%', '@SOLineWithMoreThanOneOpenReservation@'; --OBTG:-20000--
              ELSIF (v_aux = 1) THEN
                -- Update reservation when possible.
                -- Read reservation.
                SELECT r.quantity, r.reservedqty, r.releasedqty, r.res_status,
                      COALESCE(SUM(CASE rs.isallocated WHEN 'Y' THEN rs.quantity - COALESCE(rs.releasedqty, 0) ELSE 0 END), 0)
                  INTO v_quantity, v_reservedqty, v_releasedqty, v_res_status,
                      v_allocated
                FROM m_reservation r
                    LEFT JOIN m_reservation_stock rs ON r.m_reservation_id = rs.m_reservation_id
                WHERE r.m_reservation_id = v_reservation_id
                GROUP BY r.quantity, r.reservedqty, r.releasedqty, r.res_status;
                IF (v_quantity != cur_orderline.qtyordered) THEN
                  IF (cur_orderline.qtyordered < v_allocated) THEN
                    RAISE EXCEPTION '%', '@ThereIsMoreAllocatedQtyThanOrdered@'; --OBTG:-20000--
                  END IF;
                  IF (cur_orderline.qtyordered < v_releasedqty) THEN
                    RAISE EXCEPTION '%', '@CannotOrderLessThanReleasedQty@'; --OBTG:-20000--
                  END IF;
                  IF (cur_orderline.qtyordered < v_reservedqty) THEN
                    --Reservation quantity to decrease with more reserved quantity than new quantity, unreserve stock
                    v_pendingtounreserve := v_reservedqty - cur_orderline.qtyordered;
                    FOR cur_res_stock IN (
                        SELECT m_reservation_stock_id, quantity - COALESCE(releasedqty, 0) AS reservedqty
                        FROM m_reservation_stock
                        WHERE m_reservation_id = v_reservation_id
                        ORDER BY COALESCE(releasedqty, 0), quantity - COALESCE(releasedqty, 0)
                    ) LOOP
                      v_qtyaux := LEAST(v_pendingtounreserve, cur_res_stock.reservedqty);
                      UPDATE m_reservation_stock
                      SET quantity = quantity - v_qtyaux,
                          updated = TO_DATE(NOW()),
                          updatedby = v_user
                      WHERE m_reservation_stock_id = cur_res_stock.m_reservation_stock_id;
                      v_reservedqty := v_reservedqty - v_qtyaux;
                      v_pendingtounreserve := v_pendingtounreserve - v_qtyaux;
                      IF (v_pendingtounreserve = 0) THEN
                        EXIT;
                      END IF;
                    END LOOP;
                    IF (v_pendingtounreserve > 0) THEN
                      RAISE EXCEPTION '%', '@CouldNotUnreserveNeededQty@'; --OBTG:-20000--
                    END IF;
                    -- Delete reservation lines with quantity zero.
                    DELETE FROM m_reservation_stock
                    WHERE quantity = 0
                      AND COALESCE(releasedqty, 0) = 0
                      AND m_reservation_id = v_reservation_id;
                  END IF;
                  UPDATE m_reservation
                  SET quantity = cur_orderline.qtyordered,
                      updated = TO_DATE(NOW()),
                      updatedby = v_user
                  WHERE m_reservation_id = v_reservation_id;
                  IF (v_quantity < cur_orderline.qtyordered AND v_res_status = 'CO') THEN
                    --Reservation processed with higher quantity. Try to reserve the new quantity.
                    SELECT * INTO  v_reservedqty FROM M_RESERVE_STOCK_AUTO(v_reservation_id, v_user);
                  END IF;
                END IF;
                
                IF (v_res_status <> 'DR') THEN
                  -- Update so_res_status
                  UPDATE c_orderline
                  SET so_res_status = CASE WHEN cur_orderline.qtyordered = v_reservedqty THEN 'CR'
					   WHEN cur_orderline.qtyordered > v_reservedqty AND v_reservedqty > 0 THEN 'PR'
                                           ELSE 'NR'
                                      END
                  WHERE c_orderline_id = cur_orderline.c_orderline_id;
                END IF;
              ELSIF (cur_orderline.create_reservation = 'CRP') THEN
                SELECT * INTO  v_reservation_id FROM M_CREATE_RESERVE_FROM_SOL(cur_orderline.c_orderline_id, 'Y', v_user);
              ELSIF (cur_orderline.create_reservation = 'CR') THEN
                SELECT * INTO  v_reservation_id FROM M_CREATE_RESERVE_FROM_SOL(cur_orderline.c_orderline_id, 'N', v_user);
              END IF;
            END LOOP;
            SELECT COUNT(*), SUM(CASE ol.so_res_status WHEN 'CR' THEN 1 ELSE 0 END), SUM(CASE ol.so_res_status WHEN 'PR' THEN 1 ELSE 0 END)
              INTO v_linecount, v_creservedcount, v_preservedcount
            FROM c_orderline ol
                JOIN m_product p ON ol.m_product_id = p.m_product_id
            WHERE ol.c_order_id = v_record_id
              AND ol.qtyordered > 0
              AND p.isstocked = 'Y'
              AND p.producttype = 'I';
            UPDATE c_order
            SET so_res_status = CASE WHEN v_linecount = v_creservedcount THEN 'CR'
                                     WHEN v_creservedcount + v_preservedcount > 0 THEN 'PR'
                                     ELSE 'NR'
                                END
            WHERE c_order_id = v_record_id;
          END IF;
        END;
      END IF;

     /**************************************************************************
      * Calculate Taxes and Totals
      *************************************************************************/
      DECLARE
        Cur_Tax RECORD;
        Cur_MultiTax RECORD;
        xTotalLines NUMERIC:=0;
        v_LineNetAmt NUMERIC:=0;
        xTaxAmt NUMERIC:=0;
        xGrandTotal NUMERIC:=0;
        HeaderNotAdded BOOLEAN:=TRUE;
        v_FirstLine BOOLEAN;
        v_ActualBaseAmt NUMERIC;
        v_lineNo NUMERIC:= 0;
      BEGIN
        v_ResultStr:='DeleteOldTaxes';
        DELETE FROM C_ORDERLINETAX  WHERE C_OrderLine_ID IN (SELECT C_OrderLine_ID FROM C_OrderLine
                                                             WHERE C_Order_ID = v_Record_ID);
        DELETE FROM C_ORDERTAX  WHERE C_Order_ID=v_Record_ID;
        -- For all Tax Rates
        v_ResultStr:='InsertNewTaxes';
        FOR Cur_Tax IN
            (SELECT l.C_OrderLine_ID, l.C_Tax_ID, o.IsTaxIncluded, l.line_gross_amount,
                SUM(l.LineNetAmt) + SUM(l.FreightAmt) + SUM(coalesce(l.ChargeAmt,0)) AS LineNetAmt,
                SUM(l.TaxBaseAmt) + SUM(l.FreightAmt) + SUM(coalesce(l.ChargeAmt,0)) AS TaxBaseAmt,
                SUM(o.FreightAmt) + SUM(coalesce(o.ChargeAmt,0)) AS HeaderNet,
                t.Rate, t.IsSummary, c.StdPrecision, t.BaseAmount, o.C_Order_ID
            FROM C_ORDER o,  C_ORDERLINE l, C_TAX t, C_CURRENCY c
            WHERE o.C_Order_ID=l.C_Order_ID
              AND o.C_Order_ID=v_Record_ID -- Parameter
              AND l.C_Tax_ID=t.C_Tax_ID
              AND o.C_Currency_ID=c.C_Currency_ID
            GROUP BY l.C_OrderLine_ID, l.C_Tax_ID, l.line_gross_amount, o.IsTaxIncluded, t.Rate,
                     t.IsSummary, c.StdPrecision, t.BaseAmount, o.C_Order_ID
            ORDER BY 4 DESC
            )
        LOOP
          v_LineNetAmt:=Cur_Tax.LineNetAmt;
          xTotalLines:=xTotalLines + v_LineNetAmt; -- w/o Header Freight/Charge
          IF (HeaderNotAdded) THEN --  add header net to first tax
            HeaderNotAdded:=FALSE;
            v_LineNetAmt:=v_LineNetAmt + Cur_Tax.HeaderNet;
          END IF;
          PERFORM C_ORDERLINETAX_INSERT(v_Org_ID, Cur_Tax.C_Order_ID, Cur_Tax.C_OrderLine_ID, v_UpdatedBy, Cur_Tax.C_Tax_ID, Cur_Tax.C_Tax_ID, Cur_Tax.LineNetAmt, Cur_Tax.TaxBaseAmt, Cur_Tax.StdPrecision);
          IF (v_istaxincluded = 'Y') THEN
            PERFORM C_ORDERLINETAX_ROUNDING(Cur_Tax.C_OrderLine_ID, Cur_Tax.line_gross_amount, Cur_Tax.LineNetAmt);
          END IF;
        END LOOP; -- Insert New Taxes
        IF (v_istaxincluded = 'Y') THEN
          SELECT COALESCE(SUM(line_gross_amount), 0) INTO xGrandTotal
          FROM c_orderline
          WHERE c_order_id = v_record_id;
        ELSE
          SELECT COALESCE(SUM(TAXAMT), 0) INTO xGrandTotal
          FROM C_ORDERTAX
          WHERE C_ORDER_ID = v_Record_ID;
          xGrandTotal:=xGrandTotal+ xTotalLines;
        END IF;
        -- Update Header
        UPDATE C_ORDER
        SET TotalLines=xTotalLines,
            GrandTotal=xGrandTotal
        WHERE C_Order_ID=v_Record_ID;
        PERFORM C_ORDERTAX_ROUNDING(v_Record_ID, xGrandTotal, xTotalLines);
        RAISE NOTICE '%','GrandTotal=' || xGrandTotal ;
      END; -- Calculate Tax and Totals
      -- Synchronize Client/Org Ownership
      UPDATE C_ORDERLINE
      SET AD_Client_ID=v_Client_ID
      WHERE C_Order_ID=v_Record_ID
        AND (AD_Client_ID<>v_Client_ID) ;

      IF (v_docaction = 'CO' AND v_issotrx = 'N') THEN
          UPDATE m_transaction
          SET checkpricedifference = 'Y'
          WHERE m_transaction_id IN (
            SELECT trx.m_transaction_id 
            FROM c_orderline  ol
                 JOIN m_matchpo mpo ON mpo.c_orderline_id = ol.c_orderline_id
                 JOIN m_transaction trx ON mpo.m_inoutline_id = trx.m_inoutline_id
            WHERE trx.iscostcalculated = 'Y' AND  ol.c_order_id = v_record_id);
      END IF;

    /**************************************************************************
     * Order Complete:5 - Something to do:6
     */
      BEGIN
        v_ResultStr:='OrderCompleteCheck';
        SELECT COUNT(*) INTO ToDeliverOrToInvoice FROM DUAL
        WHERE 0 <> ANY (select QtyOrdered - QtyDelivered from c_orderline where c_order_id = v_Record_ID)
        OR    0 <> ANY (select QtyOrdered - QtyInvoiced  from c_orderline where c_order_id = v_Record_ID);
        -- If something to deliver or to invoice, then ToDeliverOrToInvoice = 1
        IF (ToDeliverOrToInvoice = 0) THEN
          RAISE NOTICE '%','OrderComplete' ;
          IF (v_DocAction='CL') THEN
            END_PROCESSING:=TRUE;
          ELSIF (v_DocAction='VO') THEN
            UPDATE C_ORDER
            SET DocStatus='VO',
                DocAction='--',
                Processed='Y',
                Updated=TO_DATE(NOW()),
                UpdatedBy=v_User
            WHERE C_Order_ID=v_Record_ID;
            END_PROCESSING:=TRUE;
          ELSE
            UPDATE C_ORDER
            SET DocStatus='CO',
                DocAction='--',
                Processed='Y',
                Updated=TO_DATE(NOW()),
                UpdatedBy=v_User
            WHERE C_Order_ID=v_Record_ID;
            END_PROCESSING:=TRUE;
          END IF;
          IF (NOT END_PROCESSING) THEN
            RAISE EXCEPTION '%', '@AlreadyPosted@'; --OBTG:-20000--
          END IF;--END_PROCESSING
        END IF;
      END;
    END IF;--FINISH_PROCESS
    IF (NOT FINISH_PROCESS AND NOT END_PROCESSING) THEN
     /**
      * In Progress -----------------------------------------------------------
      */
      UPDATE C_ORDER
      SET DocStatus='IP',
          DateAcct=DateOrdered,
          Updated=TO_DATE(NOW()),
          UpdatedBy=v_User
      WHERE C_Order_ID=v_Record_ID;
      IF (p_PInstance_ID IS NOT NULL) THEN
        -- COMMIT;
      END IF;

    /**
      * Finished with processing
      */
      IF (v_DocAction='PR') THEN
        v_ResultStr:='FinishProcessing';
        UPDATE C_ORDER
        SET DocStatus='IP',
            DocAction='CO',
            Processed='N',
            Updated=TO_DATE(NOW()),
            UpdatedBy=v_User
        WHERE C_Order_ID=v_Record_ID;
        -- C_Order_PickList(NULL, v_Record_ID);  -- Print PickList
        END_PROCESSING:=TRUE;
      END IF;
    END IF;--FINISH_PROCESS
    IF (NOT FINISH_PROCESS AND NOT END_PROCESSING) THEN
    /**************************************************************************
      * Prepayment Order  Create Invoice
      *************************************************************************/
      IF (v_DocSubTypeSO='PR' AND v_DocStatus<>'WP') THEN
        RAISE NOTICE '%','Create PreInvoice - ' || v_Record_ID ;
        v_ResultStr:='CreatePreInvoice';
        SELECT * INTO  Invoice_ID FROM C_Invoice_Create(NULL, v_Record_ID) ;
        RAISE NOTICE '%','  PreInvoice - ' || Invoice_ID ;
        IF (Invoice_ID='0') THEN
          RAISE EXCEPTION '%', '@PreInvoiceCreateFailed@'; --OBTG:-20000--
        END IF;
        PERFORM C_INVOICE_POST(NULL, Invoice_ID) ;
        --
        UPDATE C_ORDER
        SET DocStatus='WP',
            DocAction='--',
            Processed='Y',
            Updated=TO_DATE(NOW()),
            UpdatedBy=v_User
        WHERE C_Order_ID=v_Record_ID;
        --
        END_PROCESSING:=TRUE;
      END IF;
      IF (NOT END_PROCESSING) THEN
       /**
        * Deliver Direct Shipments
        */
        v_ResultStr:='NonInventoryDelivery';
        UPDATE C_ORDERLINE
        SET QtyDelivered=QtyOrdered
        WHERE DirectShip='Y'
          AND C_Order_ID=v_Record_ID;
      END IF;--END_PROCESSING
    END IF;--FINISH_PROCESS
    IF (NOT FINISH_PROCESS AND NOT END_PROCESSING) THEN
     /**************************************************************************
      * Will-Call + Walk In Processing
      * --
      * (W)illCall(I)nvoice - (W)illCall(P)ickup - (W)alkIn(R)eceipt
      * --
      *************************************************************************/
      IF (v_DocSubTypeSO IN('WI', 'WP', 'WR')) THEN
       /************
        * Shipment
        */
        RAISE NOTICE '%','Create Shipment - ' || v_Record_ID ;
        v_ResultStr:='CreateShipment';

        SELECT * INTO  InOut_ID FROM M_Inout_Create(NULL, v_Record_ID, NULL, 'Y') ; -- Force Delivery

        RAISE NOTICE '%','  Shipment - ' || InOut_ID ;
        IF (InOut_ID='0') THEN
          RAISE EXCEPTION '%', '@InOutCreateFailed@'; --OBTG:-20000--
        ELSE
          SELECT documentno
            INTO v_DocumentNo
          FROM M_INOUT
          WHERE M_INOUT_ID = InOut_ID;
          v_Message:='@InoutDocumentno@ ' || v_DocumentNo || ' @beenCreated@';
        END IF;
        IF (v_DocSubTypeSO IN('WI', 'WR')) THEN
         /************
          * Invoice
          */
          RAISE NOTICE '%','Create Invoice - ' || v_Record_ID ;
          v_ResultStr:='CreateInvoice';
          SELECT * INTO  Invoice_ID FROM C_Invoice_Create(NULL, v_Record_ID) ;
          RAISE NOTICE '%','  Invoice - ' || Invoice_ID ;
          IF (Invoice_ID IS NULL OR Invoice_ID='0') THEN
            RAISE EXCEPTION '%', '@InvoiceCreateFailed@'; --OBTG:-20000--
          ELSE
            SELECT documentno
              INTO v_DocumentNo
            FROM C_INVOICE
            WHERE C_INVOICE_ID = Invoice_ID;
            v_Message:=v_Message||' , '||'@InvoiceDocumentno@ ' || v_DocumentNo || ' @invbeenCreated@';
          END IF;
        END IF;
      END IF;

     /**
      * Final Completeness check
      */
      SELECT COUNT(*) INTO ToDeliver FROM DUAL
      WHERE 0 <> ANY (select QtyOrdered - QtyDelivered from c_orderline where c_order_id = v_Record_ID);
      SELECT COUNT(*) INTO ToInvoice FROM DUAL
      WHERE 0 <> ANY (select QtyOrdered - QtyInvoiced from c_orderline where c_order_id = v_Record_ID);
      RAISE NOTICE '%','To deliver - ' || ToDeliver ;
      RAISE NOTICE '%','ToInvoice - ' || ToInvoice ;
      RAISE NOTICE '%','v_DocSubTypeSO - ' || v_DocSubTypeSO ;
      -- Nothing to Deliver + Invoice for (W)illCall(I)nvoice and (W)alkIn(R)eceipt
      IF (v_DocSubTypeSO IN ('WI', 'WR') AND ToDeliver=0 AND ToInvoice=0) THEN
        UPDATE C_ORDER
        SET DocStatus='CO',
            DocAction='--',
            IsDelivered='Y',
            IsInvoiced='Y',
            Processed='Y',
            Updated=TO_DATE(NOW()),
            UpdatedBy=v_User
        WHERE C_Order_ID=v_Record_ID;
        RAISE NOTICE '%','DocAction - ' || v_DocAction ;
        IF (v_DocAction='VO') THEN
          UPDATE C_ORDER  SET DocStatus='VO'  WHERE C_Order_ID=v_Record_ID;
        END IF;
      END IF;
      -- Nothing to Deliver for (W)illCall(P)ickup (Invoice generated independently)
      IF (v_DocSubTypeSO='WP' AND ToDeliver=0) THEN
        UPDATE C_ORDER
        SET DocStatus='CO',
            DocAction='--',
            IsDelivered='Y',
            Processed='Y',
            Updated=TO_DATE(NOW()),
            UpdatedBy=v_User
        WHERE C_Order_ID=v_Record_ID;
        IF (v_DocAction='VO') THEN
          UPDATE C_ORDER  SET DocStatus='VO'  WHERE C_Order_ID=v_Record_ID;
        END IF;
      END IF;
      -- We are done with standard sales orders
      IF (v_DocSubTypeSO = 'RM' OR v_isreturndoctype = 'Y') THEN

        FOR Cur_Order IN( SELECT ol.qtyordered, ol.c_order_discount_id FROM C_order o,C_orderline ol
            WHERE o.C_Order_ID = v_Record_ID
              AND ol.C_Order_ID = o.C_Order_ID)
        LOOP
          IF (Cur_Order.qtyordered >0 AND Cur_Order.c_order_discount_id IS NULL) THEN 
            RAISE EXCEPTION '%', '@ReturnMaterialOrderType@' ; --OBTG:-20000--
          END IF;
        END LOOP;
      END IF;
      IF (v_DocAction IN('CO', 'CL', 'VO') AND v_DocSubTypeSO IN('SO','RM')) THEN
        UPDATE C_ORDER
        SET DocStatus='CO',
            DocAction='--',
            Processed='Y',
            Updated=TO_DATE(NOW()),
            UpdatedBy=v_User
        WHERE C_Order_ID=v_Record_ID;
      END IF;
      -- Purchase Orders
      IF (v_DocAction IN('CO', 'CL', 'VO') AND v_DocSubTypeSO IS NULL) THEN
        UPDATE C_ORDER
        SET DocStatus='CO',
            DocAction='--',
            Processed='Y',
            Updated=TO_DATE(NOW()),
            UpdatedBy=v_User
        WHERE C_Order_ID=v_Record_ID;
      END IF;
      IF (v_DocAction IN('CO') AND v_DocSubTypeSO IN('OB')) THEN
        UPDATE C_ORDER
        SET DocStatus='UE',
            DocAction='--',
            Processed='Y',
            Updated=TO_DATE(NOW()),
            UpdatedBy=v_User
        WHERE C_Order_ID=v_Record_ID;
      END IF;
      -- Only create cash entry if docAction is Complete
      IF (v_DocAction NOT IN('CO')) THEN
        END_PROCESSING:=TRUE;
      END IF;
    END IF;--FINISH_PROCESS
    IF (NOT FINISH_PROCESS AND NOT END_PROCESSING) THEN
     /**************************************************************************
      * Create default Cash entry
      *************************************************************************/
      DECLARE
        v_PaymentRule VARCHAR(60) ;
        CUR_CB RECORD;
        v_debtPaymentID VARCHAR(32); --OBTG:varchar2--
        v_totalCash NUMERIC;
        v_CB_Curr VARCHAR(32); --OBTG:varchar2--
      BEGIN
       /* ALO
        */
        UPDATE C_DEBT_PAYMENT  SET IsValid='Y'  WHERE C_Order_ID=v_Record_ID;
        SELECT C_ORDER.PAYMENTRULE,
            (CASE 
		WHEN (length(C_ORDER.DOCUMENTNO||' - '||C_BPARTNER.NAME||' - '||C_ORDER.GRANDTOTAL) > 200) 
			THEN substr(C_ORDER.DOCUMENTNO||' - '||C_BPARTNER.NAME||' - '||C_ORDER.GRANDTOTAL,1,197)||'...'
		ELSE 
			C_ORDER.DOCUMENTNO||' - '||C_BPARTNER.NAME||' - '||C_ORDER.GRANDTOTAL
	    END) AS CONCATENATION,
            C_ORDER.GRANDTOTAL,
            C_ORDER.M_WAREHOUSE_ID
          INTO v_PaymentRule,
            v_DocumentNo,
            v_GrandTotal,
            v_M_Warehouse_ID
        FROM C_ORDER, C_BPARTNER
        WHERE C_ORDER.C_BPARTNER_ID=C_BPARTNER.C_BPARTNER_ID
          AND C_ORDER_ID=v_Record_ID;
        SELECT MAX(NAME)
          INTO v_WarehouseName
        FROM M_WAREHOUSE
        WHERE M_WAREHOUSE_ID=v_M_Warehouse_ID;

        --PaymentRule C, WI and WR have already created DP, this won't be inserted in cashline
        --because it will processed with the invoice.
        IF (v_PaymentRule='C') AND (v_DocSubTypeSO NOT IN ('WI', 'WR') OR v_DocSubTypeSO IS NULL) THEN
          IF (v_CashLine_ID IS NULL OR v_CashLine_ID='0') THEN
            -- Create CashLine
            -- Find Defaylt CashBook
            v_ResultStr:='Find C_CashBook Org_ID=' || v_Org_ID;
            BEGIN
              -- First active default Book of Org
              FOR CUR_CB IN
                 (SELECT cb.C_CashBook_ID, c.ISO_Code, cb.NAME, cb.c_currency_id
                  FROM C_CASHBOOK cb, C_CURRENCY c
                  WHERE cb.AD_Org_ID=v_Org_ID
                    AND cb.C_Currency_ID=c.C_Currency_ID
                    AND cb.IsActive='Y'
                  ORDER BY cb.IsDefault DESC
                 )
              LOOP
                IF (v_CashBook_ID IS NULL) THEN
                  v_CashBook_ID:=CUR_CB.C_CashBook_ID;
                  v_ISO_Code:=CUR_CB.ISO_Code;
                  v_CB_Curr:=CUR_CB.C_Currency_ID;
                ELSIF (CUR_CB.NAME=v_WarehouseName) THEN
                  v_CashBook_ID:=CUR_CB.C_CashBook_ID;
                  v_ISO_Code:=CUR_CB.ISO_Code;
                  v_CB_Curr:=CUR_CB.C_Currency_ID;
                END IF;
              END LOOP;
            END;
            IF (v_CashBook_ID IS NULL) THEN
              RAISE EXCEPTION '%', '@CashBookPRSCnotfoundOrg@' || v_Org_Name ; --OBTG:-20000--
            END IF;
            RAISE NOTICE '%','CashBook_ID=' || v_CashBook_ID ;
            -- Find/Create Cash Journal
            v_ResultStr:='Find C_Cash for ' || v_Date;
            DECLARE
              Cur_CashId RECORD;
            BEGIN
              FOR Cur_CashId IN
                 (SELECT C_Cash_ID AS Cash_ID
                  FROM C_CASH
                  WHERE C_CashBook_ID=v_CashBook_ID
                    AND TRUNC(StatementDate)=v_Date
                    AND Processed='N'
                 )
              LOOP
                v_Cash_ID:=Cur_CashId.Cash_ID;
                EXIT;
              END LOOP;
            EXCEPTION
              WHEN DATA_EXCEPTION THEN
                NULL;
            END;
           /**************************************************************************
            * Credit Multiplier
            *************************************************************************/
            DECLARE
              v_DocBaseType C_DOCTYPE.DocBaseType%TYPE;
            BEGIN
              -- Is it a Credit Memo?
              SELECT DocBaseType
                INTO v_DocBaseType
              FROM C_DOCTYPE
              WHERE C_DocType_ID=v_DocType_ID;
              IF (v_DocBaseType IN('ARC', 'API')) THEN
                v_Multiplier:=-1;
              END IF;
            END;

            IF (v_Cash_ID IS NULL) THEN
              v_ResultStr:='Create C_Cash';
              SELECT * INTO  v_Cash_ID FROM Ad_Sequence_Next('C_Cash', v_Org_ID) ;
              INSERT
              INTO C_CASH
                (
                  C_Cash_ID, AD_Client_ID, AD_Org_ID, IsActive,
                  Created, CreatedBy, Updated, UpdatedBy,
                  C_CashBook_ID, NAME, StatementDate, DateAcct,
                  BeginningBalance, EndingBalance, StatementDifference, Processing,
                  Processed, Posted
                )
              VALUES
                (
                  v_Cash_ID, v_Client_ID, v_Org_ID, 'Y',
                  TO_DATE(NOW()), v_UpdatedBy, TO_DATE(NOW()), v_UpdatedBy,
                  v_CashBook_ID, TO_CHAR(v_Date, 'YYYY-MM-DD') || ' ' || v_ISO_Code, v_Date, v_Date,
                  0, 0, 0, 'N',
                  'N', 'N'
                )
              ;
            END IF;
           /*
            Create a debt payment for paymentrule=C
            Note: for WI and WR we have already created an invoice and its DP, we only have to link it
            */
            SELECT COALESCE(SUM(C_Currency_Round(C_Currency_Convert((Amount + WriteOffAmt), C_Currency_ID, v_CB_Curr, v_Date, NULL, v_Client_ID, v_Org_ID), v_c_Currency_ID, NULL)), 0)
              INTO v_totalCash
            FROM C_DEBT_PAYMENT_V dp
            WHERE C_Order_ID=v_Record_ID;

            SELECT * INTO  v_debtPaymentID FROM Ad_Sequence_Next('C_Debt_Payment', v_Record_ID) ;
            INSERT INTO C_DEBT_PAYMENT
               (C_DEBT_PAYMENT_ID, AD_CLIENT_ID, AD_ORG_ID, ISACTIVE,
                CREATED, CREATEDBY, UPDATED, UPDATEDBY,
                ISRECEIPT, C_SETTLEMENT_CANCEL_ID, C_SETTLEMENT_GENERATE_ID, DESCRIPTION,
                C_ORDER_ID, C_BPARTNER_ID, C_CURRENCY_ID, C_CASHLINE_ID,
                C_BANKACCOUNT_ID, C_CASHBOOK_ID, PAYMENTRULE, ISPAID,
                AMOUNT, WRITEOFFAMT, DATEPLANNED, ISMANUAL,
                ISVALID, C_BANKSTATEMENTLINE_ID, CHANGESETTLEMENTCANCEL, CANCEL_PROCESSED,
                GENERATE_PROCESSED, c_project_id,IsAutomaticGenerated, STATUS_INITIAL)
            VALUES
               (v_debtPaymentID, v_Client_ID, v_Org_ID, 'Y',
                TO_DATE(NOW()), v_UpdatedBy, TO_DATE(NOW()), v_UpdatedBy,
                v_isSoTrx, NULL, NULL, '',
                v_Record_ID, v_c_Bpartner_Id, v_c_currency_id, null,
                NULL, v_CashBook_ID, 'C', 'N',
                (v_GrandTotal-v_totalCash), 0, v_Date, 'N',
                'Y', NULL, 'N', 'N',
                'N', v_C_PROJECT_ID,'Y', 'DE');

            RAISE NOTICE '%','  Cash_ID=' || v_Cash_ID ;
            -- Create CashJournal Line in invoice currency
            v_ResultStr:='Create C_CashLine';
            SELECT * INTO  v_CashLine_ID FROM Ad_Sequence_Next('C_CashLine', v_Org_ID) ;

            SELECT COALESCE(MAX(Line), 0) +10
              INTO v_Line
            FROM C_CASHLINE
            WHERE C_Cash_ID=v_Cash_ID;
            --
            INSERT
            INTO C_CASHLINE
              (
                C_CashLine_ID, AD_Client_ID, AD_Org_ID, IsActive,
                Created, CreatedBy, Updated, UpdatedBy,
                C_Cash_ID, C_Debt_Payment_ID, Line, Description,
                Amount, CashType, DiscountAmt, WriteOffAmt,
                IsGenerated
              )
            VALUES
              (
                v_CashLine_ID, v_Client_ID, v_Org_ID, 'Y',
                TO_DATE(NOW()), v_UpdatedBy, TO_DATE(NOW()), v_UpdatedBy,
                v_Cash_ID, v_debtPaymentID, v_Line, v_DocumentNo,
                (v_GrandTotal-v_totalCash) * (CASE WHEN v_isSoTrx='N' THEN -1 ELSE 1 END), 'P', 0, 0,
                'Y'
              )
            ;
            RAISE NOTICE '%','  CashLine_ID=' || v_CashLine_ID ;

          END IF; -- CashLine_ID IS NULL OR CashLine_ID = '0'
        END IF; -- v_PaymentRule = 'C'
      END;
    END IF;--FINISH_PROCESS
    IF (NOT FINISH_PROCESS) THEN
      -- End Processing --------------------------------------------------------
      ---- <<END_PROCESSING>>
      -- Cloase Order
      IF (v_DocAction='CL') THEN
        UPDATE C_ORDER
        SET DocStatus='CL',
            DocAction='--',
            Processed='Y'
        WHERE C_Order_ID=v_Record_ID;
      END IF;
    END IF;--FINISH_PROCESS

    --C_Order_Post - Finish_Process Extension Point
    SELECT count(*) INTO v_count
    FROM DUAL
    where exists (select 1 from ad_ep_procedures where ad_extension_points_id = 'CB68FC0E8A4547D9943C785761977E77');
    IF (v_count=1) THEN
      DECLARE
        v_ep_instance VARCHAR(32); --OBTG:VARCHAR2--
        v_extension_point_id VARCHAR(32) := 'CB68FC0E8A4547D9943C785761977E77'; --OBTG:VARCHAR2--
      BEGIN
        v_ep_instance := get_uuid();
        PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'Record_ID',
          v_record_id, NULL, NULL, NULL, NULL, NULL, NULL);
        PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'DocAction',
          v_DocAction, NULL, NULL, NULL, NULL, NULL, NULL);
        PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'User',
          v_User, NULL, NULL, NULL, NULL, NULL, NULL);
        PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'Message',
          NULL, NULL, NULL, NULL, NULL, NULL, v_Message);
        PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'Result',
          NULL, NULL, v_result, NULL, NULL, NULL, NULL);
        PERFORM AD_EXTENSION_POINT_HANDLER(v_ep_instance, v_extension_point_id);
        SELECT p_number INTO v_Result
        FROM ad_ep_instance_para
        WHERE ad_ep_instance_id = v_ep_instance
          AND parametername LIKE 'Result';
        SELECT p_text INTO v_Message
        FROM ad_ep_instance_para
        WHERE ad_ep_instance_id = v_ep_instance
          AND parametername LIKE 'Message';

        DELETE FROM ad_ep_instance_para
        WHERE ad_ep_instance_id = v_ep_instance;
      END;
    END IF;

    IF (NOT FINISH_PROCESS) THEN
      IF (p_PInstance_ID IS NOT NULL) THEN
        v_ResultStr:='UnLockingOrder';
        UPDATE C_ORDER
        SET Processing='N',
            Updated=TO_DATE(NOW()),
            UpdatedBy=v_User
        WHERE C_Order_ID=v_Record_ID;
        -- COMMIT;
      END IF;
    END IF;--FINISH_PROCESS

    ---- <<FINISH_PROCESS>>
    IF (p_PInstance_ID IS NOT NULL) THEN
      --  Update AD_PInstance
      RAISE NOTICE '%','Updating PInstance - Finished - ' || v_Message ;
      PERFORM AD_UPDATE_PINSTANCE(p_PInstance_ID, NULL, 'N', v_Result, v_Message) ;
    END IF;
    RETURN;
  END; --BODY
EXCEPTION
WHEN OTHERS THEN
  RAISE NOTICE '%',v_ResultStr ;
  v_ResultStr:= '@ERROR=' || SQLERRM;
  IF(p_PInstance_ID IS NOT NULL) THEN
    -- ROLLBACK;
    --Inserted by Carlos Romero 062706
    UPDATE C_ORDER  SET Processing='N'  WHERE C_Order_ID=v_Record_ID;
    RAISE NOTICE '%',v_ResultStr ;
    PERFORM AD_UPDATE_PINSTANCE(p_PInstance_ID, NULL, 'N', 0, v_ResultStr) ;
  ELSE
    RAISE EXCEPTION '%', SQLERRM;
  END IF;
  RETURN;
END ; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION c_order_post1(character varying, character varying, character varying)
  OWNER TO tad;


-- Function: exs_check(character varying, character varying, character varying, numeric, timestamp without time zone, character varying, character varying)

-- DROP FUNCTION exs_check(character varying, character varying, character varying, numeric, timestamp without time zone, character varying, character varying);

CREATE OR REPLACE FUNCTION exs_check(p_ad_org_id character varying, p_ad_client_id character varying, p_m_product_id character varying, p_plannedqty numeric, p_movementdate timestamp without time zone, p_locatorid character varying, p_attributesetinstance_id character varying)
  RETURNS void AS
$BODY$ DECLARE 
v_SumMovQty NUMERIC;
  v_ResultStr VARCHAR(2000):=''; --OBTG:VARCHAR2--
    v_Message VARCHAR(2000):=''; --OBTG:VARCHAR2-
    v_productname VARCHAR(60);
  v_qtyonhand NUMERIC;

  Cur_minoutline RECORD;
  v_stockcount NUMERIC;
  Cur_stock RECORD;
  v_SumMovQtycheck NUMERIC;
 
BEGIN

--IF (p_AttributeSetInstance_ID is not null) then 
select sum(qtyonhand) into v_qtyonhand from m_storage_detail where  ad_org_id=p_ad_org_id and m_product_id= p_m_product_id 
and M_AttributeSetInstance_ID = COALESCE(p_attributesetinstance_id, '0') and M_Locator_ID = p_LocatorId;

	/*else 

select sum(qtyonhand) into v_qtyonhand from m_storage_detail where  ad_org_id=p_ad_org_id and m_product_id= p_m_product_id 
and M_Locator_ID = p_LocatorId;	
end if;*/

	if (v_qtyonhand < p_PLANNEDQTY) then

select name into v_productname from m_product where m_product_id=p_m_product_id;
v_Message := 'Insufficient stock for the Product  : ';

	raise exception '%', v_Message|| v_productname  ;



end if;
v_SumMovQty := 0;

   IF(p_ad_org_id != '1D2962C9D0D74808B9C223B15797BE15' and p_ad_org_id != 'AC82185478A748469AA6B09357CA173C' and 
       p_ad_org_id != 'B47744BA3B364153809DC7280498B597' and p_ad_org_id != 'BD73955127E4442C96CC59D4FCFDE8E4' and
       p_ad_org_id != 'EF311B7833674B61BA06BB270017BE55' and p_ad_org_id != '7FDFFCB2D2284E8D8E0EB3FFCDA073C1'and
       p_ad_org_id != 'C764C6D619B04C539B354296016F9988') THEN


--IF (p_AttributeSetInstance_ID is not null) then 
select sum(MovementQty) into v_SumMovQty from m_transaction where MovementDate between '1900-01-01' and p_MovementDate and 
                                                             ad_org_id=p_ad_org_id and m_product_id= p_m_product_id 
                                                             and M_Locator_ID = p_LocatorId 
                                                             and M_AttributeSetInstance_ID =  COALESCE(p_attributesetinstance_id, '0')  ;
	/*else 

select sum(MovementQty) into v_SumMovQty from m_transaction where MovementDate between '1900-01-01' and p_MovementDate and 
                                                             ad_org_id=p_ad_org_id and m_product_id= p_m_product_id and M_Locator_ID = p_LocatorId ;

end if;*/
                                                     
                                                                  
IF ( (p_PLANNEDQTY > v_SumMovQty) or (v_SumMovQty is null) or (v_SumMovQty < 0) ) THEN

select name into v_productname from m_product where m_product_id=p_m_product_id;
v_Message := 'Insufficient stock for the selected date  for the Product  : ';


				-- raise exception '%', v_Message|| v_productname ;

				

END IF;
END IF; -- p_ad_org_id !=

END ; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION exs_check(character varying, character varying, character varying, numeric, timestamp without time zone, character varying, character varying)
  OWNER TO tad;


-- Function: exma_check(character varying, character varying, character varying, numeric, timestamp without time zone, character varying, character varying)

-- DROP FUNCTION exma_check(character varying, character varying, character varying, numeric, timestamp without time zone, character varying, character varying);

CREATE OR REPLACE FUNCTION exma_check(p_ad_org_id character varying, p_ad_client_id character varying, p_m_product_id character varying, p_plannedqty numeric, p_productionplandate timestamp without time zone, p_locatorid character varying, p_attributesetinstance_id character varying)
  RETURNS void AS
$BODY$ DECLARE 
--v_SumMovQty NUMERIC(10,2);
  v_SumMovQty NUMERIC;
  v_ResultStr VARCHAR(2000):=''; --OBTG:VARCHAR2--
  v_Message VARCHAR(2000):=''; --OBTG:VARCHAR2-
  v_productname VARCHAR(60);
  v_qtyonhand NUMERIC;

BEGIN


--IF (p_attributesetinstance_id is not null) then 

select sum(qtyonhand) into v_qtyonhand from m_storage_detail where  ad_org_id=p_ad_org_id and m_product_id= p_m_product_id 
and M_AttributeSetInstance_ID = COALESCE(p_attributesetinstance_id, '0') and M_Locator_ID = p_locatorid;

 /*else 

select sum(qtyonhand) into v_qtyonhand from m_storage_detail where  ad_org_id=p_ad_org_id and m_product_id= p_m_product_id 
and M_Locator_ID = p_locatorid;	

end if;*/

	if (v_qtyonhand < p_PLANNEDQTY) then

select name into v_productname from m_product where m_product_id=p_m_product_id;
v_Message := 'Insufficient stock for the Product  : ';

	raise exception '%', v_Message|| v_productname  ;


end if;



	

v_SumMovQty := 0;

 -- IF ( p_ad_org_id != 'DC26D5D4C802429F887CAECBEA1F33A2' and p_ad_org_id != '3E19AC84BA4F4208B02FA7B31F7D042F'    ) then 
  
--IF (p_attributesetinstance_id is not null) then 



select sum(MovementQty) into v_SumMovQty from m_transaction where MovementDate between '1900-01-01' and p_Productionplandate and 
                                                                    ad_org_id=p_ad_org_id and m_product_id= p_m_product_id and M_Locator_ID = p_LocatorId 
                                                                    and M_AttributeSetInstance_ID = COALESCE(p_attributesetinstance_id, '0');

/*else


select sum(MovementQty) into v_SumMovQty from m_transaction where MovementDate between '1900-01-01' and p_Productionplandate and 
                                                                    ad_org_id=p_ad_org_id and m_product_id= p_m_product_id and M_Locator_ID = p_LocatorId;

end if;*/

IF ( (p_PLANNEDQTY > v_SumMovQty) or (v_SumMovQty is null) or (v_SumMovQty < 0)) THEN



select name into v_productname from m_product where m_product_id=p_m_product_id;
v_Message := 'Insufficient stock for the selected date  for the Product  : ';
				--raise exception '%', v_Message|| v_productname  ;




END IF;

--END IF; -- p_ad_org_id !=
END ; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION exma_check(character varying, character varying, character varying, numeric, timestamp without time zone, character varying, character varying)
  OWNER TO tad;


-- Function: exma_intstockcheck(character varying, character varying, character varying, numeric, timestamp without time zone, character varying, character varying)

-- DROP FUNCTION exma_intstockcheck(character varying, character varying, character varying, numeric, timestamp without time zone, character varying, character varying);

CREATE OR REPLACE FUNCTION exma_intstockcheck(p_ad_org_id character varying, p_ad_client_id character varying, p_m_product_id character varying, p_plannedqty numeric, p_productionplandate timestamp without time zone, p_locatorid character varying, p_attributesetinstance_id character varying)
  RETURNS void AS
$BODY$ DECLARE 
--v_SumMovQty NUMERIC(10,2);
  v_SumMovQty NUMERIC;
  v_ResultStr VARCHAR(2000):=''; --OBTG:VARCHAR2--
  v_Message VARCHAR(2000):=''; --OBTG:VARCHAR2-
  v_productname VARCHAR(60);
  v_qtyonhand NUMERIC;

BEGIN


  -- IF (p_attributesetinstance_id is not null) then 
select sum(qtyonhand) into v_qtyonhand from m_storage_detail where  ad_org_id=p_ad_org_id and m_product_id= p_m_product_id 
and M_AttributeSetInstance_ID = COALESCE(p_attributesetinstance_id, '0')  and M_Locator_ID = p_locatorid;
	/*else 

select sum(qtyonhand) into v_qtyonhand from m_storage_detail where  ad_org_id=p_ad_org_id and m_product_id= p_m_product_id 
and M_Locator_ID = p_locatorid;	
end if;*/

	if (v_qtyonhand < p_plannedqty) then

select name into v_productname from m_product where m_product_id=p_m_product_id;
v_Message := 'Insufficient stock for the Product  : ';

	raise exception '%', v_Message|| v_productname  ;



end if;
   
v_SumMovQty := 0;

  -- IF ( p_ad_org_id != 'DC26D5D4C802429F887CAECBEA1F33A2' and p_ad_org_id != '3E19AC84BA4F4208B02FA7B31F7D042F' ) then 
  
--IF (p_attributesetinstance_id is not null) then 


select sum(MovementQty) into v_SumMovQty from m_transaction where MovementDate between '1900-01-01' and p_Productionplandate and 
                                                                    ad_org_id=p_ad_org_id and m_product_id= p_m_product_id and M_Locator_ID = p_LocatorId 
                                                                    and M_AttributeSetInstance_ID = COALESCE(p_attributesetinstance_id, '0');

/*else

select sum(MovementQty) into v_SumMovQty from m_transaction where MovementDate between '1900-01-01' and p_Productionplandate and 
                                                                    ad_org_id=p_ad_org_id and m_product_id= p_m_product_id and M_Locator_ID = p_LocatorId;

end if;*/
IF ( (p_PLANNEDQTY > v_SumMovQty) or (v_SumMovQty is null) or (v_SumMovQty < 0)) THEN



select name into v_productname from m_product where m_product_id=p_m_product_id;
v_Message := 'Insufficient stock for the selected date  for the Product  : ';
				-- raise exception '%', v_Message|| v_productname  ;




END IF;
--END IF; -- p_ad_org_id !=
END ; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION exma_intstockcheck(character varying, character varying, character varying, numeric, timestamp without time zone, character varying, character varying)
  OWNER TO tad;


-- Function: cwpf_customworkeffort(character varying, character varying)

-- DROP FUNCTION cwpf_customworkeffort(character varying, character varying);

CREATE OR REPLACE FUNCTION cwpf_customworkeffort(p_pinstance_id character varying, p_productionplan_id character varying)
  RETURNS void AS
$BODY$ DECLARE 
-- Logistice
	  v_ResultStr VARCHAR(2000):=''; --OBTG:VARCHAR2--
	  v_Message VARCHAR(2000):=''; --OBTG:VARCHAR2--
	  -- Parameter
	  --TYPE RECORD IS REFCURSOR;
	    Cur_Parameter RECORD;
	    Cur_Toolset RECORD;
	    Cur_PP RECORD;
	    Cur_livestock RECORD;
	    V_ISAMORTIZATION char(1);
	    V_ISLAYING char(1);

	    --
	    v_diffqty NUMERIC;
	    v_cost NUMERIC;
	    v_Record_ID VARCHAR(32):=NULL; --OBTG:VARCHAR2--
	    v_User_ID VARCHAR(32); --OBTG:VARCHAR2--
	    v_Org_ID VARCHAR(32); --OBTG:VARCHAR2--
	    v_Client_ID VARCHAR(32); --OBTG:VARCHAR2--
	    v_count NUMERIC;
	    v_NextNo1 varchar(32);
	--    v_count2 NUMBER;
	--    v_Production_ID VARCHAR2(32);
	    v_ProductionDate TIMESTAMP;
	--    v_Name NVARCHAR2(60) ;
	    -- p_ppline            NUMBER;
	    -- p_plline          NUMBER;
	--    v_ProductionPlan_ID VARCHAR2(32);
	--    v_ProductionLine_ID VARCHAR2(32);
	--    v_Quantity NUMBER;
	--    v_UOM_ID VARCHAR2(32);
	--    v_PInstance NUMBER;
	--    v_doneQty NUMBER;
	--    v_needQty NUMBER;
	    v_QtyOnHand NUMERIC;
	    p_Processed CHAR;
	    v_ProductQty NUMERIC;
	    v_NextNo VARCHAR(32); --OBTG:VARCHAR2--
	    Quantity NUMERIC:=99999; -- unlimited
	    v_Result NUMERIC:=1;

	    CUR_PL_Post RECORD;
	    Cur_ProductionPlan RECORD;

	    FINISH_PROCESS BOOLEAN:=FALSE;
	    v_is_included NUMERIC:=0;
	    v_available_period NUMERIC:=0;
	    v_is_ready AD_Org.IsReady%TYPE;
	    v_is_tr_allow AD_OrgType.IsTransactionsAllowed%TYPE;
	    v_isacctle AD_OrgType.IsAcctLegalEntity%TYPE;
	    v_org_bule_id AD_Org.AD_Org_ID%TYPE;
	    v_AD_Org_ID VARCHAR(32); --OBTG:VARCHAR2--
	    v_prodline NUMERIC;
	    v_line NUMERIC;
	    v_AD_Pinstance_ID VARCHAR(32); --OBTG:VARCHAR2--
	    v_productname m_product.name%TYPE;
	    V_ISSTANDARD CHAR(1);
	    V_standardcost NUMERIC;
	    Cur_RawMaterial RECORD;
	    v_attributesetinstance_id VARCHAR(32);
v_exma_productionplan_id  VARCHAR(32);

    v_Productionplandate TIMESTAMP;
    Cur_RawMatStockCheck RECORD;
    CUR_liveStockCheck RECORD;
    v_liveStockmovqty NUMERIC;
    v_liveStockclosingqty NUMERIC;
    v_sumOfqtyonhand NUMERIC;
    v_liveStockProdId VARCHAR(32);
    v_liveStockLocId VARCHAR(32);
    CUR_shedWiseliveStockCheck RECORD;
    v_costsum NUMERIC;
    v_countcheck NUMERIC;


	  BEGIN
	    -- Process Parameters
	    
	    IF(p_PInstance_ID IS NOT NULL) THEN
	      --  Update AD_PInstance
	      RAISE NOTICE '%','Updating PInstance - Processing ' || p_PInstance_ID ;
	      v_ResultStr:='PInstanceNotFound';
	      PERFORM AD_UPDATE_PINSTANCE(p_PInstance_ID, NULL, 'Y', NULL, NULL) ;
	      -- Get Parameters
	      v_ResultStr:='ReadingParameters';
	      FOR Cur_Parameter IN
		(SELECT i.Record_ID, i.AD_User_ID, i.AD_Org_ID, i.AD_Client_ID, p.ParameterName,
		  p.P_String, p.P_Number, p.P_Date
		FROM AD_PINSTANCE i
		LEFT JOIN AD_PINSTANCE_PARA p
		  ON i.AD_PInstance_ID=p.AD_PInstance_ID
		WHERE i.AD_PInstance_ID=p_PInstance_ID
		ORDER BY p.SeqNo) LOOP
		v_Record_ID:=Cur_Parameter.Record_ID;
		v_User_ID:=Cur_Parameter.AD_User_ID;
		v_Org_ID:=Cur_Parameter.AD_Org_ID;
		v_Client_ID:=Cur_Parameter.AD_Client_ID;
		
	      END LOOP; -- Get Parameter
	    ELSE
	      RAISE NOTICE '%','--<<EXMA_WorkEffort_Validate>>' ;
	    END IF;
	  BEGIN 
	 
	  --BODY
	 /*   SELECT Processed, MOVEMENTDATE, AD_ORG_ID
	    INTO p_Processed, v_ProductionDate, v_AD_Org_ID
	    FROM EXMA_PRODUCTION
	    WHERE EXMA_Production_ID=v_Record_ID;
	    --Check if is has been already processed
	    IF(p_Processed='Y') THEN
	      v_ResultStr:='Work Effort is already validated';
	      v_Message:='@WorkEffortValidated@';
	      RAISE EXCEPTION '%', v_Message; --OBTG:-20000--
	    END IF;  */
	--OBTG:-20000--
		-- for production runs
		SELECT processed, productionplandate, AD_ORG_ID
	    INTO p_Processed, v_ProductionDate, v_AD_Org_ID
	    FROM EXMA_PRODUCTIONPLAN
	    WHERE EXMA_Productionplan_ID=p_productionplan_id;
	    --Check if is has been already processed
	    IF(p_Processed='Y') THEN
	       v_ResultStr:='Production run is already validated';
	      v_Message:='@CWPF_ProductionRunValidated@';
	      RAISE EXCEPTION '%', v_Message; --OBTG:-20000--
	    END IF; 


		v_ResultStr := 'Amortization details';

		select  PP.EM_CWCT_ISAMORTIZATION, PP.EM_CWCT_ISLAYING INTO V_ISAMORTIZATION, V_ISLAYING
		from EXMA_ProductionPlan PPL
		INNER JOIN EXMA_Production P ON PPL.EXMA_Production_ID = P.EXMA_Production_ID
		INNER JOIN EXMA_WorkRequirement WR ON P.EXMA_WorkRequirement_ID = WR.EXMA_WorkRequirement_ID
		INNER JOIN EXMA_PROCESSPLAN PP ON WR.EXMA_PROCESSPLAN_ID = PP.EXMA_PROCESSPLAN_ID
		WHERE ppl.EXMA_Production_ID = v_record_id
		AND ppl.EXMA_PRODUCTIONPLAN_ID = p_productionplan_id;

	 --checking I/O products
	    v_ResultStr:='Checking I/O Products';
	    
	     SELECT COUNT(*)
	      INTO v_count
	      FROM EXMA_PRODUCTIONLINE where EXMA_Productionplan_ID=p_productionplan_id;
	      IF(v_count=0) THEN
		v_ResultStr := 'There are no products in I/O Products';
		v_Message:='@NeedLocator@';
		RAISE EXCEPTION '%', v_Message; --OBTG:-20000--
	      END IF;

		-- checking live stock 
	      v_ResultStr:='Checking LiveStock';
	      SELECT COUNT(*)
	      INTO v_count
	      FROM CWCT_livestock where EXMA_ProductionPlan_ID=p_productionplan_id;
	      IF(v_count=0) THEN
		v_ResultStr := 'There are no products in livestock';
		v_Message:='@NeedLiveStock@';
		RAISE EXCEPTION '%', v_Message; --OBTG:-20000--
	      END IF;	
		
	    SELECT count(*) INTO v_count
	    FROM dual
	    WHERE EXISTS (
		SELECT 1
		FROM EXMA_productionplan pp
		    JOIN EXMA_productionline pl ON pp.EXMA_productionplan_id = pl.EXMA_productionplan_id
		    JOIN m_product p ON p.m_product_id = pl.m_product_id
		WHERE pp.EXMA_production_id = v_record_id
		  AND p.isgeneric = 'Y');
	    IF (v_count > 0) THEN
	      SELECT max(p.name) INTO v_productname
	      FROM EXMA_productionplan pp
		  JOIN EXMA_productionline pl ON pp.EXMA_productionplan_id = pl.EXMA_productionplan_id
		  JOIN EXMA_product p ON p.m_product_id = pl.m_product_id
	      WHERE pp.exma_production_id = v_record_id
		AND p.isgeneric = 'Y';
	      RAISE EXCEPTION '%', '@CannotUseGenericProduct@ ' || v_productName; --OBTG:-20000--
	    END IF;
	    
	    IF(NOT FINISH_PROCESS) THEN
	      -- Check that there are some parts of the job and that theay are processed
	      
	      -- Check the header belongs to a organization where transactions are posible and ready to use
	      SELECT AD_Org.IsReady, Ad_OrgType.IsTransactionsAllowed
	      INTO v_is_ready, v_is_tr_allow
	      FROM EXMA_PRODUCTION, AD_Org, AD_OrgType
	      WHERE AD_Org.AD_Org_ID=EXMA_PRODUCTION.AD_Org_ID
	      AND AD_Org.AD_OrgType_ID=AD_OrgType.AD_OrgType_ID
	      AND EXMA_PRODUCTION.EXMA_PRODUCTION_ID=v_Record_ID;
	      IF (v_is_ready='N') THEN
		RAISE EXCEPTION '%', '@OrgHeaderNotReady@'; --OBTG:-20000--
	      END IF;
	      IF (v_is_tr_allow='N') THEN
		RAISE EXCEPTION '%', '@OrgHeaderNotTransAllowed@'; --OBTG:-20000--
	      END IF;
	      
	      SELECT AD_ORG_CHK_DOCUMENTS('EXMA_PRODUCTION', 'EXMA_PRODUCTIONPLAN', v_Record_ID, 'EXMA_PRODUCTION_ID', 'EXMA_PRODUCTION_ID') INTO v_is_included FROM dual;
	      IF (v_is_included=-1) THEN
		RAISE EXCEPTION '%', '@LinesAndHeaderDifferentLEorBU@'; --OBTG:-20000--
	      END IF;
	      FOR CUR_PP IN
		(SELECT EXMA_PRODUCTIONPLAN_ID
		 FROM EXMA_PRODUCTIONPLAN
		 WHERE EXMA_PRODUCTION_ID = v_Record_ID) LOOP
		SELECT AD_ORG_CHK_DOCUMENTS('EXMA_PRODUCTIONPLAN', 'EXMA_PRODUCTIONLINE', CUR_PP.EXMA_PRODUCTIONPLAN_ID, 'EXMA_PRODUCTIONPLAN_ID', 'EXMA_PRODUCTIONPLAN_ID') INTO v_is_included FROM dual;
		IF (v_is_included=-1) THEN
		  RAISE EXCEPTION '%', '@LinesAndHeaderDifferentLEorBU@'; --OBTG:-20000--
		END IF;
	      END LOOP;      
	      
	      -- Check the period control is opened (only if it is legal entity with accounting)
	      -- Gets the BU or LE of the document
	      SELECT AD_GET_DOC_LE_BU('EXMA_PRODUCTION', v_Record_ID, 'EXMA_PRODUCTION_ID', 'LE')
	      INTO v_org_bule_id
	      FROM DUAL;
	      
	      SELECT AD_OrgType.IsAcctLegalEntity
	      INTO v_isacctle
	      FROM AD_OrgType, AD_Org
	      WHERE AD_Org.AD_OrgType_ID = AD_OrgType.AD_OrgType_ID
	      AND AD_Org.AD_Org_ID=v_org_bule_id;
	      
	      IF (v_isacctle='Y') THEN
		SELECT C_CHK_OPEN_PERIOD(v_AD_Org_ID, v_ProductionDate, 'MMP', NULL) 
		INTO v_available_period
		FROM DUAL;
			v_available_period:=1;

		IF (v_available_period<>1) THEN
		  RAISE EXCEPTION '%', '@PeriodNotAvailable@'; --OBTG:-20000--
		END IF;
	      END IF;	
	      
	      
	      v_ResultStr:='Checking ProductionRun';
	      SELECT COUNT(*)
	      INTO v_count
	      FROM EXMA_PRODUCTIONPLAN
	      WHERE EXMA_Production_ID=v_Record_ID;
	      IF(v_count=0) THEN
		v_ResultStr := 'There are not Production Runs to validate';
		v_Message:='@NoProductionRun@';
		RAISE EXCEPTION '%', v_Message; --OBTG:-20000--
	      END IF;
	    END IF; --FINISH_PROCESS
	    IF(NOT FINISH_PROCESS) THEN
	      SELECT COUNT(*)
	      INTO v_count
	      FROM EXMA_PRODUCTIONPLAN pp
	      WHERE EXMA_Production_ID=v_Record_ID
	      -- newly added below line
	      AND EXMA_PRODUCTIONPLAN_ID = p_productionplan_id
	      --  AND PROCESSED='N';
	      AND PROCESSED='Y';
	      IF(v_count<>0) THEN
		v_Message:='@ProducionRunNoProcessed@';
		RAISE EXCEPTION '%', v_Message; --OBTG:-20000--
		FINISH_PROCESS:=TRUE;
	      END IF;
	    END IF; --FINISH_PROCESS
	    IF(NOT FINISH_PROCESS) THEN
	      --Check if there's any global use production phase.
	      SELECT COUNT(*)
	      INTO v_count
	      FROM EXMA_PRODUCTIONPLAN pp,
		EXMA_WRPHASE wp
	      WHERE pp.EXMA_WRPHASE_ID=wp.EXMA_WRPHASE_ID
		AND pp.EXMA_PRODUCTION_ID=v_Record_ID
		AND wp.GROUPUSE='Y';
	      IF(v_count<>0) THEN
		v_ResultStr:='Distributing product of global use';
	 PERFORM EXMA_GLOBALUSE_DISTRIBUTE(v_Client_ID, v_AD_Org_ID, v_User_ID, v_Record_ID) ;
	      END IF;
	    END IF; --FINISH_PROCESS
	 /*   IF(NOT FINISH_PROCESS) THEN
	      --Check if all the ProductionLine have a warehouse
	      v_ResultStr:='Checking Locators';
	      SELECT COUNT(*)
	      INTO v_count
	      FROM EXMA_PRODUCTIONLINE l,
		EXMA_PRODUCTIONPLAN p
	      WHERE l.EXMA_ProductionPlan_ID=p.EXMA_ProductionPlan_ID
		AND p.EXMA_Production_ID=v_Record_ID
		AND l.M_Locator_ID IS NULL;
	      IF(v_count<>0) THEN
		v_ResultStr := 'There are produts without Locator';
		v_Message:='@NeedLocator@';
		RAISE EXCEPTION '%', v_Message; --OBTG:-20000--
		FINISH_PROCESS:=TRUE;
	      END IF;
	    END IF; --FINISH_PROCESS  */
	    --Check negative quantities for P+ and P- in Production Line if its a Work Effort

	    
	    IF(NOT FINISH_PROCESS) THEN
				v_Message := NULL;
				v_Count:=0;
				SELECT COUNT(EXMA_ProductionPlan_ID)
		INTO v_Count
		FROM EXMA_ProductionPlan pp
		WHERE pp.EXMA_Production_ID = v_Record_ID
		AND EXISTS
		(SELECT 1 FROM EXMA_ProductionLine
		WHERE EXMA_ProductionPlan_ID = pp.EXMA_ProductionPlan_ID
		AND pp.EXMA_Wrphase_ID IS NOT NULL
		AND MovementQty < 0);
				IF (v_Count <> 0) THEN
					FOR Cur_ProductionPlan IN (
					SELECT PP.Line AS PPLine, PL.LINE AS PLLine
					FROM EXMA_ProductionLine PL,
					EXMA_ProductionPlan PP
					WHERE PL.EXMA_ProductionPlan_ID = PP.EXMA_ProductionPlan_ID
					AND PP.EXMA_Production_ID = v_Record_ID
					AND PL.MovementQty < 0
					AND PP.EXMA_WrPhase_ID IS NOT NULL
					ORDER BY PP.Line, PL.Line
					)
					LOOP
						IF v_Message IS NULL THEN
							v_Message:=Cur_ProductionPlan.PPLine||'-'||Cur_ProductionPlan.PLLine;
						ELSE
							v_Message:=v_Message || ', ' || Cur_ProductionPlan.PPLine||'-'||Cur_ProductionPlan.PLLine;
						END IF;
					END LOOP;
					v_Message:='@NoNegativeMovementQtyInWorkEffortProductLine@'||v_Message;
					RAISE EXCEPTION '%', v_Message; --OBTG:-20000--
		FINISH_PROCESS:=TRUE;
				END IF;
	    END IF;
	    --Check if exist any product in a productionplan with the same locator and productiontype P+ and P-
	    IF(NOT FINISH_PROCESS) THEN
	      SELECT COUNT(*)
	      INTO v_count
	      FROM EXMA_PRODUCTIONLINE pl, EXMA_PRODUCTIONPLAN pp
	      WHERE pl.PRODUCTIONTYPE='+'
		AND pl.EXMA_PRODUCTIONPLAN_ID = pp.EXMA_PRODUCTIONPLAN_ID
		AND pp.EXMA_PRODUCTION_ID = v_Record_ID
		AND EXISTS
		(SELECT 1
		FROM EXMA_PRODUCTIONLINE
		WHERE EXMA_PRODUCTIONPLAN_ID=pl.EXMA_PRODUCTIONPLAN_ID
		  AND M_PRODUCT_ID=pl.M_PRODUCT_ID
		  AND PRODUCTIONTYPE='-'
		)
		;
	      IF(v_count<>0) THEN
		-- ROLLBACK;
		v_ResultStr := 'Same product in a production plan as P+ and P-';
		v_Message:='@P+AndP-InSamePlan@';
		RAISE EXCEPTION '%', v_Message; --OBTG:-20000--
		FINISH_PROCESS:=TRUE;
	      END IF;
	    END IF; --FINISH_PROCESS


	    -----START by Malathi
		v_ResultStr:='ProductAttributeSetValue Updation';

			FOR Cur_RawMaterial IN (
				select ppl.Movementqty ,PPL.m_locator_id, ppl.M_PRODUCT_ID, ppl.AD_ORG_ID,EXMA_PRODUCTIONLINE_id
				from   EXMA_PRODUCTIONLINE ppl 
				WHERE ppl.PRODUCTIONTYPE = '-'
				AND ppl.EXMA_PRODUCTIONPLAN_ID = p_productionplan_id
				) LOOP --L1

					select M_ATTRIBUTESETINSTANCE_ID  INTO v_ATTRIBUTESETINSTANCE_ID
					from m_storage_detail where m_product_id =  Cur_RawMaterial.M_PRODUCT_ID
					and m_locator_id =  Cur_RawMaterial.m_locator_id
					and ad_org_id  = Cur_RawMaterial.AD_ORG_ID
					and qtyonhand >= Cur_RawMaterial.Movementqty ;

					IF ( v_ATTRIBUTESETINSTANCE_ID IS NOT NULL ) THEN --ASET


							--update EXMA_PRODUCTIONLINE set M_ATTRIBUTESETINSTANCE_ID=v_ATTRIBUTESETINSTANCE_ID
							--where EXMA_PRODUCTIONLINE_id = Cur_RawMaterial.EXMA_PRODUCTIONLINE_id;

					ELSE --ASET
							--update EXMA_PRODUCTIONLINE set M_ATTRIBUTESETINSTANCE_ID='0'
							--where EXMA_PRODUCTIONLINE_id = Cur_RawMaterial.EXMA_PRODUCTIONLINE_id;
					END IF; --ASET


				END LOOP; --L1

		--END by Malathi
	    
	    IF (NOT FINISH_PROCESS) THEN
	      SELECT COUNT(*), MAX(pp.line), MAX(PL.LINE)
	      INTO v_Count, v_prodline, v_line
	      FROM EXMA_PRODUCTIONPLAN PP, EXMA_PRODUCTIONLINE PL, M_PRODUCT P
	      WHERE PL.M_PRODUCT_ID=P.M_PRODUCT_ID
		AND P.M_ATTRIBUTESET_ID IS NOT NULL
		AND (P.ATTRSETVALUETYPE IS NULL OR P.ATTRSETVALUETYPE <> 'F')
		AND (SELECT ISONEATTRSETVALREQUIRED FROM M_ATTRIBUTESET WHERE M_ATTRIBUTESET_ID = P.M_ATTRIBUTESET_ID) = 'Y'
		AND COALESCE(PL.M_ATTRIBUTESETINSTANCE_ID, '0') = '0'
		AND PL.EXMA_ProductionPlan_ID=pp.EXMA_ProductionPlan_ID
		AND pp.EXMA_Production_ID=v_Record_ID;
	      IF v_Count<>0 THEN
		RAISE EXCEPTION '%', '@inProductionPlan@'||' '||'@line@'||' '||v_prodline||', '||'@Inline@'||' '||v_line||' '||'@productWithoutAttributeSet@' ; --OBTG:-20000--
		FINISH_PROCESS:=TRUE;
	      END IF;
	    END IF;

	   
	    -- All Production Lines
	    IF(NOT FINISH_PROCESS) THEN

  --Added by jhansi for resolving insufficient stock issue

 --IF ( v_AD_Org_ID != 'DC26D5D4C802429F887CAECBEA1F33A2' and v_AD_Org_ID != '3E19AC84BA4F4208B02FA7B31F7D042F'  ) then 
  

select count(*) into v_countcheck from exma_productionline where exma_productionplan_id = p_productionplan_id and M_AttributeSetInstance_ID is not null;

            IF (v_countcheck > 0) THEN

                --   PERFORM EXMA_ATTRIBUTEALLOCATION( p_productionplan_id,v_User_ID );

            END IF;

       -- END IF;  -- IF ( v_AD_Org_ID !=

       --Ended by jhansi   
	    
	      FOR CUR_PL_Post IN
		(SELECT pl.EXMA_ProductionLine_ID, pl.AD_Client_ID, pl.AD_Org_ID, p.MovementDate, pp.starttime,
		  pl.M_Product_ID, pl.M_AttributeSetInstance_ID, pl.MovementQty, pl.M_Locator_ID,
		  pl.M_Product_UOM_ID, pl.QuantityOrder, pl.C_UOM_ID, pl.LINE, pl.PRODUCTIONTYPE,
		  pr.ISSTOCKED, pr.PRODUCTTYPE
		FROM EXMA_PRODUCTION p, EXMA_PRODUCTIONLINE pl, EXMA_PRODUCTIONPLAN pp, M_PRODUCT pr
		WHERE p.EXMA_Production_ID=pp.EXMA_Production_ID
		  AND pp.EXMA_ProductionPlan_ID=pl.EXMA_ProductionPlan_ID
		  AND pp.EXMA_Production_ID=v_Record_ID
		  And pp.EXMA_ProductionPlan_ID = p_productionplan_id
		  AND pl.M_PRODUCT_ID=pr.M_PRODUCT_ID
		  AND pr.ISSTOCKED='Y'
		ORDER BY pp.Line, pl.Line)
	      LOOP
		-- EXMA_ProductionLine_ID, AD_Client_ID, AD_Org_ID, MovementDate, M_Product_ID, MovementQty, M_Locator_ID
		-- DBMS_OUTPUT.PUT_LINE('ProductionLine=' || CUR_PL_Post.M_ProductionLine_ID);
		-- DBMS_OUTPUT.PUT_LINE('  Qty=' || CUR_PL_Post.MovementQty || ', OnHand=' || M_BOM_Qty_OnHand(CUR_PL_Post.M_Product_ID, NULL, CUR_PL_Post.M_Locator_ID));
		-- Check Stock levels for reductions
		-- Check, if product exists and if it is stocked
		-- Unlimited capacity if no item
		IF(CUR_PL_Post.ProductType<>'I' OR CUR_PL_Post.IsStocked='N') THEN
		  v_QtyOnHand:=Quantity;
		  -- Stocked item
		ELSIF(CUR_PL_Post.IsStocked='Y') THEN
		  -- Get ProductQty
		  SELECT COALESCE(SUM(QtyOnHand), 0)
		  INTO v_ProductQty
		  FROM M_STORAGE_DETAIL s
		  WHERE M_Product_ID=CUR_PL_Post.M_Product_ID
		    AND EXISTS
		    (SELECT * FROM M_LOCATOR l WHERE s.M_Locator_ID=l.M_Locator_ID)
		    ;
		  --DBMS_OUTPUT.PUT_LINE('Qty=' || ProductQty);
		  v_QtyOnHand:=v_ProductQty;
		END IF;
-- Added by jhansi for Negative Stock Control
   select exma_productionplan_id,Productionplandate into v_exma_productionplan_id,v_Productionplandate from exma_productionplan 
   where exma_productionplan.exma_productionplan_id=p_productionplan_id;

--Started stock validation for livestock


FOR CUR_liveStockCheck IN
       (select CWCT_Livestock.CWCT_Livestock_id,CWCT_Livestock.m_product_id  from exma_productionplan
        join CWCT_Livestock
        on CWCT_Livestock.exma_productionplan_id  = exma_productionplan.exma_productionplan_id
        
        where exma_productionplan.exma_productionplan_id = v_exma_productionplan_id)
    LOOP


FOR CUR_shedWiseliveStockCheck IN
       (select CWPM_SdLveStock.CWCT_Livestock_id,CWPM_SdLveStock.M_Locator_ID,CWPM_SdLveStock.m_product_id ,m_product.name from CWPM_SdLveStock
       join m_product
       on m_product.m_product_id = CWPM_SdLveStock.m_product_id
        where CWCT_Livestock_id = CUR_liveStockCheck.CWCT_Livestock_id)
    LOOP

select Movementqty,Cwpm_Closing_Stock into v_liveStockmovqty,v_liveStockclosingqty from CWPM_SdLveStock where CWCT_Livestock_id  = CUR_shedWiseliveStockCheck.CWCT_Livestock_id and M_Locator_ID = CUR_shedWiseliveStockCheck.M_Locator_ID;

select sum(QtyOnHand) into v_sumOfqtyonhand from M_Storage_Detail where m_product_id = CUR_shedWiseliveStockCheck.m_product_id and M_Locator_ID = CUR_shedWiseliveStockCheck.M_Locator_ID;

IF(v_sumOfqtyonhand < v_liveStockmovqty or v_sumOfqtyonhand < v_liveStockclosingqty)THEN


        v_Message:= 'Insufficient Livestock for the product ' || CUR_shedWiseliveStockCheck.name;

        RAISE EXCEPTION '%',v_Message;


END IF;

IF(v_sumOfqtyonhand > v_liveStockmovqty )THEN


        v_Message:= 'Livestock movementqty is less than the available stock for the product ' || CUR_shedWiseliveStockCheck.name;

        RAISE EXCEPTION '%',v_Message;


END IF;



   END LOOP;

END LOOP;
--Ended stock validation for livestock
   
 -- IF ( v_AD_Org_ID != 'DC26D5D4C802429F887CAECBEA1F33A2' and v_AD_Org_ID != '3E19AC84BA4F4208B02FA7B31F7D042F'    ) then 

  
--IF (CUR_PL_Post.M_AttributeSetInstance_ID is null or CUR_PL_Post.PRODUCTIONTYPE = '+' ) THEN  --Added by jhansi for resolving insufficient stock issue


if (CUR_PL_Post.PRODUCTIONTYPE = '-') then 
    PERFORM EXMA_CHECK(CUR_PL_Post.AD_Org_ID,CUR_PL_Post.AD_Client_ID, CUR_PL_Post.M_Product_ID,CUR_PL_Post.MovementQty,v_Productionplandate,CUR_PL_Post.M_Locator_ID,CUR_PL_Post.M_AttributeSetInstance_ID);

end if; 

-- Ended by jhansi

		-- Only insert in M_TRANSACTION if MovementQty <> 0
		IF CUR_PL_Post.MovementQty <> 0 THEN
		  -- Create Transaction Entry        
		   v_ResultStr:='CreateTransaction';
		  SELECT * INTO  v_NextNo FROM Ad_Sequence_Next('M_Transaction', v_Org_ID) ;

			--raise exception 'This is 1st';
		  
		  INSERT
		  INTO M_TRANSACTION
		    (
		      M_Transaction_ID, EM_EXMA_ProductionLine_ID, AD_Client_ID, AD_Org_ID,
		      IsActive, Created, CreatedBy, Updated,
		      UpdatedBy, MovementType, M_Locator_ID, M_Product_ID,
		      M_AttributeSetInstance_ID,
			MovementDate, MovementQty,-- M_Product_UOM_ID,
		     -- QuantityOrder,
			C_UOM_ID
		    )
		    VALUES
		    (
		      v_NextNo, CUR_PL_Post.EXMA_ProductionLine_ID, CUR_PL_Post.AD_Client_ID, CUR_PL_Post.AD_Org_ID,
		      'Y', TO_DATE(NOW()), v_User_ID, TO_DATE(NOW()),
		      v_User_ID, 'P+', CUR_PL_Post.M_Locator_ID, CUR_PL_Post.M_Product_ID,
		     COALESCE(CUR_PL_Post.M_AttributeSetInstance_ID, '0'), -- not distinguishing between assemby/disassembly
		      CUR_PL_Post.starttime,(CASE CUR_PL_Post.PRODUCTIONTYPE WHEN '+' THEN CUR_PL_Post.MovementQty ELSE -CUR_PL_Post.MOVEMENTQTY END), --COALESCE(CUR_PL_Post.M_Product_UOM_ID,''),
		      --(CASE CUR_PL_Post.PRODUCTIONTYPE WHEN '+' THEN CUR_PL_Post.QUANTITYORDER ELSE COALESCE(-CUR_PL_Post.QuantityOrder,'') END), 
		      CUR_PL_Post.C_UOM_ID
		    )
		    ;


		  END IF;

				--  END IF; -- IF (CUR_PL_Post.M_AttributeSetInstance_ID is null or CUR_PL_Post.PRODUCTIONTYPE = '+' )

/*ELSE   --   IF ( v_AD_Org_ID != 'DC26D5D4C802429F887CAECBEA1F33A2' and v_AD_Org_ID != '3E19AC84BA4F4208B02FA7B31F7D042F'  ) then 
 



if (CUR_PL_Post.PRODUCTIONTYPE = '-') then 
    PERFORM EXMA_CHECK(CUR_PL_Post.AD_Org_ID,CUR_PL_Post.AD_Client_ID, CUR_PL_Post.M_Product_ID,CUR_PL_Post.MovementQty,v_Productionplandate,CUR_PL_Post.M_Locator_ID,CUR_PL_Post.M_AttributeSetInstance_ID);

end if; 

-- Ended by jhansi

		-- Only insert in M_TRANSACTION if MovementQty <> 0
		IF CUR_PL_Post.MovementQty <> 0 THEN
		  -- Create Transaction Entry        
		   v_ResultStr:='CreateTransaction';
		  SELECT * INTO  v_NextNo FROM Ad_Sequence_Next('M_Transaction', v_Org_ID) ;

			--raise exception 'This is 1st';
		  
		  INSERT
		  INTO M_TRANSACTION
		    (
		      M_Transaction_ID, EM_EXMA_ProductionLine_ID, AD_Client_ID, AD_Org_ID,
		      IsActive, Created, CreatedBy, Updated,
		      UpdatedBy, MovementType, M_Locator_ID, M_Product_ID,
		      M_AttributeSetInstance_ID,
			MovementDate, MovementQty,-- M_Product_UOM_ID,
		     -- QuantityOrder,
			C_UOM_ID
		    )
		    VALUES
		    (
		      v_NextNo, CUR_PL_Post.EXMA_ProductionLine_ID, CUR_PL_Post.AD_Client_ID, CUR_PL_Post.AD_Org_ID,
		      'Y', TO_DATE(NOW()), v_User_ID, TO_DATE(NOW()),
		      v_User_ID, 'P+', CUR_PL_Post.M_Locator_ID, CUR_PL_Post.M_Product_ID,
		     COALESCE(CUR_PL_Post.M_AttributeSetInstance_ID, '0'), -- not distinguishing between assemby/disassembly
		      CUR_PL_Post.starttime,(CASE CUR_PL_Post.PRODUCTIONTYPE WHEN '+' THEN CUR_PL_Post.MovementQty ELSE -CUR_PL_Post.MOVEMENTQTY END), --COALESCE(CUR_PL_Post.M_Product_UOM_ID,''),
		      --(CASE CUR_PL_Post.PRODUCTIONTYPE WHEN '+' THEN CUR_PL_Post.QUANTITYORDER ELSE COALESCE(-CUR_PL_Post.QuantityOrder,'') END), 
		      CUR_PL_Post.C_UOM_ID
		    )
		    ;


		  END IF;



END IF;  --   IF ( v_AD_Org_ID != 'DC26D5D4C802429F887CAECBEA1F33A2' and v_AD_Org_ID != '3E19AC84BA4F4208B02FA7B31F7D042F'  ) then */

 
    
		/*IF(CUR_PL_Post.IsStocked<>'N') THEN
		  SELECT * INTO  v_Result, v_Message FROM M_Check_Stock(CUR_PL_Post.M_Product_ID, v_Client_ID, v_AD_Org_ID) ;
		 
		  IF (v_Result=0) THEN
		    v_Message:=v_Message || ' @Inline@ ' || CUR_PL_Post.line;
		    RAISE EXCEPTION '%', v_Message; --OBTG:-20000--
		  END IF;
		END IF;*/
	      END LOOP;
	    END IF; --FINISH_PROCESS



	
	    IF (NOT FINISH_PROCESS) THEN
		--Calculate Production Cost
	     /* SELECT count(1) INTO v_count
	      FROM DUAL
	      WHERE EXISTS (SELECT 1 FROM ad_preference
			      WHERE attribute = 'Cost_Eng_Ins_Migrated');
	      IF (v_count = 0) THEN
		--Only calculate cost automatically if legacy cost engine is used.
		SELECT * INTO  v_Message FROM EXMA_Production_Cost(v_Record_ID, v_User_ID);
	      END IF; */

	      IF ( V_ISLAYING = 'N') THEN

		SELECT * INTO  v_Message FROM CWCT_FARMPRDUCTN_LAYINGCOSTCAL(v_Record_ID, p_productionplan_id, v_User_ID); --by malathi

	      ELSE 

		      IF ( V_ISAMORTIZATION = 'Y') THEN

			SELECT * INTO  v_Message FROM cwct_farmamortization_costcal(v_Record_ID, p_productionplan_id, v_User_ID); --by malathi

		      ELSE

			SELECT * INTO  v_Message FROM CWCT_FARMPRODUCTION_COSTCALCUL(v_Record_ID, p_productionplan_id, v_User_ID); --by malathi

		     END IF;

	     END IF;

	     
	    END IF; --FINISH_PROCESS
	    IF(NOT FINISH_PROCESS) THEN
	      -- Update donequantity on workrequirements
	      v_ResultStr:='Updating workrequirement';
	      FOR Cur_ProductionPlan IN
		(SELECT *  FROM EXMA_PRODUCTIONPLAN pp  WHERE pp.EXMA_PRODUCTION_ID=v_Record_ID)
	      LOOP
		UPDATE EXMA_WRPHASE
		  SET DONEQUANTITY=DONEQUANTITY + Cur_ProductionPlan.PRODUCTIONQTY, RUNTIME=Cur_ProductionPlan.RUNTIME,
		  UPDATED=TO_DATE(NOW())
		WHERE EXMA_WRPhase_ID=Cur_ProductionPlan.EXMA_WRPHASE_ID;

		 -- Close Phase if its marked
		IF (Cur_ProductionPlan.CLOSEPHASE='Y') THEN
		  v_AD_Pinstance_ID := GET_UUID();
		  INSERT INTO AD_PINSTANCE 
		  (AD_PINSTANCE_ID, AD_PROCESS_ID, RECORD_ID, ISACTIVE, 
		  AD_USER_ID, AD_CLIENT_ID, AD_ORG_ID, CREATED, CREATEDBY,
		  UPDATED, UPDATEDBY)
		  VALUES
		  (v_AD_Pinstance_ID,'D7715DEFF29D49C88A92F1C4E6E75446',Cur_ProductionPlan.EXMA_WRPHASE_ID,'Y',
		  v_User_ID, v_Client_ID, v_Org_ID, TO_DATE(NOW()), v_User_ID,
		  TO_DATE(NOW()), v_User_ID
		  );
		  PERFORM EXMA_WRPHASE_CLOSE(v_AD_Pinstance_ID,'N');
		END IF;
	      END LOOP;
	      -- Indicate that we are done
	  /*    UPDATE EXMA_PRODUCTION
		SET Processed='Y',
		updated=TO_DATE(NOW()),
		updatedby=v_User_ID
	      WHERE EXMA_Production_ID=v_Record_ID;     */

	-- Updating production run as second time it should not process

	--Added by jhansi to check is the cost calculated

select sum(calccost) into v_costsum from EXMA_PRODUCTIONLINE where EXMA_Productionplan_ID = p_productionplan_id and PRODUCTIONTYPE = '-';


IF (v_costsum = 0 or v_costsum is null) THEN

v_Message := 'Zero COST DEFINED FOR RAW MATERIAL PRODUCTS';

			raise exception '%', v_Message ;


END IF;

	--Ended by jhansi



	
		UPDATE EXMA_PRODUCTIONPlan
		SET Processed='Y',
		updated=TO_DATE(NOW()),
		updatedby=v_User_ID
	      WHERE EXMA_Productionplan_ID=p_productionplan_id;   

	      
	    END IF; --FINISH_PROCESS
	    IF(NOT FINISH_PROCESS) THEN
	      v_ResultStr:='Updating used toolsets';
	      FOR Cur_Toolset IN
		(SELECT EXMA_TOOLSETUSED.*
		 FROM EXMA_TOOLSETUSED, EXMA_PRODUCTIONPLAN
		 WHERE EXMA_TOOLSETUSED.EXMA_PRODUCTIONPLAN_ID = EXMA_PRODUCTIONPLAN.EXMA_PRODUCTIONPLAN_ID
		   AND EXMA_PRODUCTIONPLAN.EXMA_PRODUCTION_ID = v_Record_ID) LOOP
		UPDATE EXMA_TOOLSET
		SET NUMBERUSES = NUMBERUSES + Cur_Toolset.USED
		WHERE EXMA_TOOLSET_ID = Cur_Toolset.EXMA_TOOLSET_ID;
	      END LOOP;
	    END IF;


		
			IF ( V_ISLAYING = 'N') THEN --LAYING --100317 by malathi

				v_ResultStr:='LiveStock cost Insertion In Laying Production Order';
				V_COUNT := 0;
				V_standardcost :=0;
			 
				select count(*) into v_count FROM CWCT_LIVESTOCK ls
				--LEFT JOIN M_PRODUCT_ORG po on ls.M_Product_Id = po.M_Product_Id
				LEFT JOIN EXMA_PRODUCTIONPLAN pp on ls.EXMA_PRODUCTIONPLAN_ID = pp.EXMA_PRODUCTIONPLAN_ID
				--LEFT JOIN AD_ORG o on pp.ad_org_id = o.ad_org_id
				Where ls.EXMA_PRODUCTIONPLAN_ID = p_productionplan_id
				and ls.calculated = 'Y' 
				group BY ls.Line ;

				IF ( V_COUNT = 0 ) THEN

				v_ResultStr := 'NO COST CALCULATED PRODUCTS IN LIVE STOCK';
		
				RAISE EXCEPTION '%',v_ResultStr;

				ELSE 
		
				FOR Cur_livestock IN 

				(select ls.*, pp.starttime, o.c_currency_id, P.NAME, o.NAME AS ORGNAME
				FROM CWPM_SdLveStock ls
				LEFT JOIN M_PRODUCT  P on ls.M_Product_Id = P.M_Product_Id
				LEFT JOIN EXMA_PRODUCTIONPLAN pp on ls.EXMA_PRODUCTIONPLAN_ID = pp.EXMA_PRODUCTIONPLAN_ID
				LEFT JOIN AD_ORG o on pp.ad_org_id = o.ad_org_id
				Where ls.EXMA_PRODUCTIONPLAN_ID = p_productionplan_id
				--and ls.calculated = 'Y' --by Tirumala
				ORDER BY ls.Line)
		
				LOOP

				v_diffqty = Cur_livestock.movementqty - Cur_livestock.cwpm_closing_stock;

				v_ResultStr:='Closing Qty is greater than Opening Qty';
				--IF(v_diffqty >= 0) THEN
				IF(v_diffqty > 0) THEN  --by Malathi 10032017 --ZERO

				SELECT * INTO  v_NextNo1 FROM Ad_Sequence_Next('M_Transaction', Cur_livestock.AD_Org_ID) ;
				--v_cost = Cur_livestock.movementqty * Cur_livestock.CALCCOST; --by malathi
				--raise exception 'This is 2nd';
				INSERT
				INTO M_TRANSACTION
				    (
				      M_Transaction_ID, AD_Client_ID, AD_Org_ID,
				      IsActive, Created, CreatedBy, Updated,
				      UpdatedBy, MovementType, M_Locator_ID, M_Product_ID,
				      M_AttributeSetInstance_ID, MovementDate, MovementQty,
				      C_UOM_ID, transactioncost, c_currency_id, iscostcalculated, isprocessed, costing_status,em_cwpm_sdlvestock,
				      em_cwlg_islivestock, em_cwlg_livestockqty
				    )
				    VALUES
				    (
				      v_NextNo1, Cur_livestock.AD_Client_ID, Cur_livestock.AD_Org_ID,
				      'Y', TO_DATE(NOW()), Cur_livestock.createdby, TO_DATE(NOW()),
				      Cur_livestock.updatedby, 'P+', Cur_livestock.M_Locator_ID, Cur_livestock.M_Product_ID,
				      '0', -- not distinguishing between assemby/disassembly
				      Cur_livestock.starttime,
				      -v_diffqty,
				      Cur_livestock.C_UOM_ID, --'0', --by malathi-10032017
				      Cur_livestock.COST_DIFFERENCE,
				      Cur_livestock.c_currency_id, 'Y', 'Y', 'CC', Cur_livestock.CWPM_SdLveStock_ID,
				      'Y', Cur_livestock.COST_DIFFERENCE --by malathi
				    );

				 --------m_transaction_cost insertion--------------
				SELECT * INTO  v_NextNo FROM Ad_Sequence_Next('M_Transaction_Cost', Cur_livestock.AD_Org_ID) ;
				--v_cost = Cur_livestock.movementqty * Cur_livestock.CALCCOST;

				--raise exception 'This is 3rd';

				insert into m_transaction_cost
				( 
					m_transaction_cost_id,ad_client_id ,ad_org_id, created ,createdby,updated ,updatedby,isactive,
					m_transaction_id, cost, costdate, c_currency_id, m_costadjustmentline_id, isunitcost,dateacct)
				values( 
					v_NextNo, Cur_livestock.AD_Client_ID, Cur_livestock.AD_Org_ID, TO_DATE(NOW()), 
					Cur_livestock.createdby, TO_DATE(NOW()), Cur_livestock.updatedby, 'Y', v_NextNo1,
					--Cur_livestock.CALCCOST,
					--'0',  --by malathi-10032017
					Cur_livestock.COST_DIFFERENCE,
					TO_DATE(NOW()), Cur_livestock.c_currency_id,
					null,'Y',TO_DATE(NOW())
				);




				ELSE --ZERO

				SELECT * INTO  v_NextNo1 FROM Ad_Sequence_Next('M_Transaction', Cur_livestock.AD_Org_ID) ;
				--v_cost = Cur_livestock.movementqty * Cur_livestock.CALCCOST; --by malathi
				--raise exception 'This is 4th';
				INSERT
				INTO M_TRANSACTION
				    (
				      M_Transaction_ID, AD_Client_ID, AD_Org_ID,
				      IsActive, Created, CreatedBy, Updated,
				      UpdatedBy, MovementType, M_Locator_ID, M_Product_ID,
				      M_AttributeSetInstance_ID, MovementDate, MovementQty,
				      C_UOM_ID, transactioncost, c_currency_id, iscostcalculated, isprocessed, costing_status,em_cwpm_sdlvestock,
				      em_cwlg_islivestock, em_cwlg_livestockqty
				    )
				    VALUES
				    (
				      v_NextNo1, Cur_livestock.AD_Client_ID, Cur_livestock.AD_Org_ID,
				      'Y', TO_DATE(NOW()), Cur_livestock.createdby, TO_DATE(NOW()),
				      Cur_livestock.updatedby, 'P+', Cur_livestock.M_Locator_ID, Cur_livestock.M_Product_ID,
				      '0', -- not distinguishing between assemby/disassembly
				      Cur_livestock.starttime,
				      -v_diffqty,
				      Cur_livestock.C_UOM_ID, --'0', --by malathi-10032017
				      -Cur_livestock.COST_DIFFERENCE,
				      Cur_livestock.c_currency_id, 'Y', 'Y', 'CC', Cur_livestock.CWPM_SdLveStock_ID,
				      'Y', Cur_livestock.COST_DIFFERENCE --by malathi
				    );

				 --------m_transaction_cost insertion--------------
				SELECT * INTO  v_NextNo FROM Ad_Sequence_Next('M_Transaction_Cost', Cur_livestock.AD_Org_ID) ;
				--v_cost = Cur_livestock.movementqty * Cur_livestock.CALCCOST;
				--raise exception 'This is 5th';
				insert into m_transaction_cost
				( 
					m_transaction_cost_id,ad_client_id ,ad_org_id, created ,createdby,updated ,updatedby,isactive,
					m_transaction_id, cost, costdate, c_currency_id, m_costadjustmentline_id, isunitcost,dateacct)
				values( 
					v_NextNo, Cur_livestock.AD_Client_ID, Cur_livestock.AD_Org_ID, TO_DATE(NOW()), 
					Cur_livestock.createdby, TO_DATE(NOW()), Cur_livestock.updatedby, 'Y', v_NextNo1,
					--Cur_livestock.CALCCOST,
					--'0',  --by malathi-10032017
					-Cur_livestock.COST_DIFFERENCE,
					TO_DATE(NOW()), Cur_livestock.c_currency_id,
					null,'Y',TO_DATE(NOW())
				);

				 ---RAISE v_ResultStr ;
			
				END IF; --ZERO
				
		END LOOP;

		END IF;

			ELSE --LAYING


				IF ( V_ISAMORTIZATION = 'Y') THEN --ISAMORT


				v_ResultStr:='LiveStock cost Insertion In Farm Production Order with AMortization';
				V_COUNT := 0;
				V_standardcost :=0;
			 
				select count(*) into v_count FROM CWCT_LIVESTOCK ls
				--LEFT JOIN M_PRODUCT_ORG po on ls.M_Product_Id = po.M_Product_Id
				LEFT JOIN EXMA_PRODUCTIONPLAN pp on ls.EXMA_PRODUCTIONPLAN_ID = pp.EXMA_PRODUCTIONPLAN_ID
				--LEFT JOIN AD_ORG o on pp.ad_org_id = o.ad_org_id
				Where ls.EXMA_PRODUCTIONPLAN_ID = p_productionplan_id
				and ls.calculated = 'Y' 
				group BY ls.Line ;

				IF ( V_COUNT = 0 ) THEN

				v_ResultStr := 'NO COST CALCULATED PRODUCTS IN LIVE STOCK';
		
				RAISE EXCEPTION '%',v_ResultStr;

				ELSE 
		
				FOR Cur_livestock IN 

				(select ls.*, pp.starttime, o.c_currency_id, P.NAME, o.NAME AS ORGNAME
				FROM CWPM_SdLveStock ls
				LEFT JOIN M_PRODUCT  P on ls.M_Product_Id = P.M_Product_Id
				LEFT JOIN EXMA_PRODUCTIONPLAN pp on ls.EXMA_PRODUCTIONPLAN_ID = pp.EXMA_PRODUCTIONPLAN_ID
				LEFT JOIN AD_ORG o on pp.ad_org_id = o.ad_org_id
				Where ls.EXMA_PRODUCTIONPLAN_ID = p_productionplan_id
				--and ls.calculated = 'Y' --by Tirumala
				ORDER BY ls.Line)
		
				LOOP

				v_diffqty = Cur_livestock.movementqty - Cur_livestock.cwpm_closing_stock;

				v_ResultStr:='Closing Qty is greater than Opening Qty';
				--IF(v_diffqty >= 0) THEN
				IF(v_diffqty > 0) THEN  --by Malathi 10032017 --ZERO

				SELECT * INTO  v_NextNo1 FROM Ad_Sequence_Next('M_Transaction', Cur_livestock.AD_Org_ID) ;
				--v_cost = Cur_livestock.movementqty * Cur_livestock.CALCCOST; --by malathi
				--raise exception 'This is 6th';
				INSERT
				INTO M_TRANSACTION
				    (
				      M_Transaction_ID, AD_Client_ID, AD_Org_ID,
				      IsActive, Created, CreatedBy, Updated,
				      UpdatedBy, MovementType, M_Locator_ID, M_Product_ID,
				      M_AttributeSetInstance_ID, MovementDate, MovementQty,
				      C_UOM_ID, transactioncost, c_currency_id, iscostcalculated, isprocessed, costing_status,em_cwpm_sdlvestock,
				      em_cwlg_islivestock, em_cwlg_livestockqty
				    )
				    VALUES
				    (
				      v_NextNo1, Cur_livestock.AD_Client_ID, Cur_livestock.AD_Org_ID,
				      'Y', TO_DATE(NOW()), Cur_livestock.createdby, TO_DATE(NOW()),
				      Cur_livestock.updatedby, 'P+', Cur_livestock.M_Locator_ID, Cur_livestock.M_Product_ID,
				      '0', -- not distinguishing between assemby/disassembly
				      Cur_livestock.starttime,
				      -v_diffqty,
				      Cur_livestock.C_UOM_ID, --'0', --by malathi-10032017
				      Cur_livestock.COST_DIFFERENCE,
				      Cur_livestock.c_currency_id, 'Y', 'Y', 'CC', Cur_livestock.CWPM_SdLveStock_ID,
				      'Y', Cur_livestock.COST_DIFFERENCE --by malathi
				    );

				 --------m_transaction_cost insertion--------------
				SELECT * INTO  v_NextNo FROM Ad_Sequence_Next('M_Transaction_Cost', Cur_livestock.AD_Org_ID) ;
				--v_cost = Cur_livestock.movementqty * Cur_livestock.CALCCOST;

				--raise exception 'This is 7th';
				insert into m_transaction_cost
				( 
					m_transaction_cost_id,ad_client_id ,ad_org_id, created ,createdby,updated ,updatedby,isactive,
					m_transaction_id, cost, costdate, c_currency_id, m_costadjustmentline_id, isunitcost,dateacct)
				values( 
					v_NextNo, Cur_livestock.AD_Client_ID, Cur_livestock.AD_Org_ID, TO_DATE(NOW()), 
					Cur_livestock.createdby, TO_DATE(NOW()), Cur_livestock.updatedby, 'Y', v_NextNo1,
					--Cur_livestock.CALCCOST,
					--'0',  --by malathi-10032017
					Cur_livestock.COST_DIFFERENCE,
					TO_DATE(NOW()), Cur_livestock.c_currency_id,
					null,'Y',TO_DATE(NOW())
				);

				ELSE --ZERO

				SELECT * INTO  v_NextNo1 FROM Ad_Sequence_Next('M_Transaction', Cur_livestock.AD_Org_ID) ;
				--v_cost = Cur_livestock.movementqty * Cur_livestock.CALCCOST; --by malathi
				--raise exception 'This is 8th';
				INSERT
				INTO M_TRANSACTION
				    (
				      M_Transaction_ID, AD_Client_ID, AD_Org_ID,
				      IsActive, Created, CreatedBy, Updated,
				      UpdatedBy, MovementType, M_Locator_ID, M_Product_ID,
				      M_AttributeSetInstance_ID, MovementDate, MovementQty,
				      C_UOM_ID, transactioncost, c_currency_id, iscostcalculated, isprocessed, costing_status,em_cwpm_sdlvestock,
				      em_cwlg_islivestock, em_cwlg_livestockqty
				    )
				    VALUES
				    (
				      v_NextNo1, Cur_livestock.AD_Client_ID, Cur_livestock.AD_Org_ID,
				      'Y', TO_DATE(NOW()), Cur_livestock.createdby, TO_DATE(NOW()),
				      Cur_livestock.updatedby, 'P+', Cur_livestock.M_Locator_ID, Cur_livestock.M_Product_ID,
				      '0', -- not distinguishing between assemby/disassembly
				      Cur_livestock.starttime,
				      -v_diffqty,
				      Cur_livestock.C_UOM_ID, --'0', --by malathi-10032017
				      -Cur_livestock.COST_DIFFERENCE,
				      Cur_livestock.c_currency_id, 'Y', 'Y', 'CC', Cur_livestock.CWPM_SdLveStock_ID,
				      'Y', Cur_livestock.COST_DIFFERENCE --by malathi
				    );

				 --------m_transaction_cost insertion--------------
				SELECT * INTO  v_NextNo FROM Ad_Sequence_Next('M_Transaction_Cost', Cur_livestock.AD_Org_ID) ;
				--v_cost = Cur_livestock.movementqty * Cur_livestock.CALCCOST;
				--raise exception 'This is 9th';
				insert into m_transaction_cost
				( 
					m_transaction_cost_id,ad_client_id ,ad_org_id, created ,createdby,updated ,updatedby,isactive,
					m_transaction_id, cost, costdate, c_currency_id, m_costadjustmentline_id, isunitcost,dateacct)
				values( 
					v_NextNo, Cur_livestock.AD_Client_ID, Cur_livestock.AD_Org_ID, TO_DATE(NOW()), 
					Cur_livestock.createdby, TO_DATE(NOW()), Cur_livestock.updatedby, 'Y', v_NextNo1,
					--Cur_livestock.CALCCOST,
					--'0',  --by malathi-10032017
					-Cur_livestock.COST_DIFFERENCE,
					TO_DATE(NOW()), Cur_livestock.c_currency_id,
					null,'Y',TO_DATE(NOW())
				);

				 ---RAISE v_ResultStr ;
			
				END IF; --ZERO

			END LOOP;

			END IF;
				ELSE --ISAMORT


				v_ResultStr:='LiveStock cost Insertion In Farm Production Order without AMortization';
				V_COUNT := 0;
				V_standardcost :=0;
			 
				select count(*) into v_count FROM CWCT_LIVESTOCK ls
				--LEFT JOIN M_PRODUCT_ORG po on ls.M_Product_Id = po.M_Product_Id
				LEFT JOIN EXMA_PRODUCTIONPLAN pp on ls.EXMA_PRODUCTIONPLAN_ID = pp.EXMA_PRODUCTIONPLAN_ID
				--LEFT JOIN AD_ORG o on pp.ad_org_id = o.ad_org_id
				Where ls.EXMA_PRODUCTIONPLAN_ID = p_productionplan_id
				and ls.calculated = 'Y' 
				group BY ls.Line ;

				IF ( V_COUNT = 0 ) THEN

				v_ResultStr := 'NO COST CALCULATED PRODUCTS IN LIVE STOCK';
		
				RAISE EXCEPTION '%',v_ResultStr;

				ELSE 
		
				FOR Cur_livestock IN 

				(select ls.*, pp.starttime, o.c_currency_id, P.NAME, o.NAME AS ORGNAME
				FROM CWPM_SdLveStock ls
				LEFT JOIN M_PRODUCT  P on ls.M_Product_Id = P.M_Product_Id
				LEFT JOIN EXMA_PRODUCTIONPLAN pp on ls.EXMA_PRODUCTIONPLAN_ID = pp.EXMA_PRODUCTIONPLAN_ID
				LEFT JOIN AD_ORG o on pp.ad_org_id = o.ad_org_id
				Where ls.EXMA_PRODUCTIONPLAN_ID = p_productionplan_id
				--and ls.calculated = 'Y' --by Tirumala
				ORDER BY ls.Line)
		
				LOOP

				v_diffqty = Cur_livestock.movementqty - Cur_livestock.cwpm_closing_stock;

				v_ResultStr:='Closing Qty is greater than Opening Qty';
				--IF(v_diffqty >= 0) THEN
				IF(v_diffqty > 0) THEN  --by Malathi 10032017 --ZERO

				SELECT * INTO  v_NextNo1 FROM Ad_Sequence_Next('M_Transaction', Cur_livestock.AD_Org_ID) ;
				--v_cost = Cur_livestock.movementqty * Cur_livestock.CALCCOST; --by malathi
					--raise exception 'This is 10th';
				INSERT
				INTO M_TRANSACTION
				    (
				      M_Transaction_ID, AD_Client_ID, AD_Org_ID,
				      IsActive, Created, CreatedBy, Updated,
				      UpdatedBy, MovementType, M_Locator_ID, M_Product_ID,
				      M_AttributeSetInstance_ID, MovementDate, MovementQty,
				      C_UOM_ID, transactioncost, c_currency_id, iscostcalculated, isprocessed, costing_status,em_cwpm_sdlvestock,
				      em_cwlg_islivestock, em_cwlg_livestockqty
				    )
				    VALUES
				    (
				      v_NextNo1, Cur_livestock.AD_Client_ID, Cur_livestock.AD_Org_ID,
				      'Y', TO_DATE(NOW()), Cur_livestock.createdby, TO_DATE(NOW()),
				      Cur_livestock.updatedby, 'P+', Cur_livestock.M_Locator_ID, Cur_livestock.M_Product_ID,
				      '0', -- not distinguishing between assemby/disassembly
				      Cur_livestock.starttime,
				      -v_diffqty,
				      Cur_livestock.C_UOM_ID, --'0', --by malathi-10032017
				      Cur_livestock.COST_DIFFERENCE,
				      Cur_livestock.c_currency_id, 'Y', 'Y', 'CC', Cur_livestock.CWPM_SdLveStock_ID,
				      'Y', Cur_livestock.COST_DIFFERENCE --by malathi
				    );

				 --------m_transaction_cost insertion--------------
				SELECT * INTO  v_NextNo FROM Ad_Sequence_Next('M_Transaction_Cost', Cur_livestock.AD_Org_ID) ;
				--v_cost = Cur_livestock.movementqty * Cur_livestock.CALCCOST;
				--raise exception 'This is 11th';
				insert into m_transaction_cost
				( 
					m_transaction_cost_id,ad_client_id ,ad_org_id, created ,createdby,updated ,updatedby,isactive,
					m_transaction_id, cost, costdate, c_currency_id, m_costadjustmentline_id, isunitcost,dateacct)
				values( 
					v_NextNo, Cur_livestock.AD_Client_ID, Cur_livestock.AD_Org_ID, TO_DATE(NOW()), 
					Cur_livestock.createdby, TO_DATE(NOW()), Cur_livestock.updatedby, 'Y', v_NextNo1,
					--Cur_livestock.CALCCOST,
					--'0',  --by malathi-10032017
					Cur_livestock.COST_DIFFERENCE,
					TO_DATE(NOW()), Cur_livestock.c_currency_id,
					null,'Y',TO_DATE(NOW())
				);

				ELSE --ZERO

				SELECT * INTO  v_NextNo1 FROM Ad_Sequence_Next('M_Transaction', Cur_livestock.AD_Org_ID) ;
				--v_cost = Cur_livestock.movementqty * Cur_livestock.CALCCOST; --by malathi
				--raise exception 'This is 12th';
				INSERT
				INTO M_TRANSACTION
				    (
				      M_Transaction_ID, AD_Client_ID, AD_Org_ID,
				      IsActive, Created, CreatedBy, Updated,
				      UpdatedBy, MovementType, M_Locator_ID, M_Product_ID,
				      M_AttributeSetInstance_ID, MovementDate, MovementQty,
				      C_UOM_ID, transactioncost, c_currency_id, iscostcalculated, isprocessed, costing_status,em_cwpm_sdlvestock,
				      em_cwlg_islivestock, em_cwlg_livestockqty
				    )
				    VALUES
				    (
				      v_NextNo1, Cur_livestock.AD_Client_ID, Cur_livestock.AD_Org_ID,
				      'Y', TO_DATE(NOW()), Cur_livestock.createdby, TO_DATE(NOW()),
				      Cur_livestock.updatedby, 'P+', Cur_livestock.M_Locator_ID, Cur_livestock.M_Product_ID,
				      '0', -- not distinguishing between assemby/disassembly
				      Cur_livestock.starttime,
				      -v_diffqty,
				      Cur_livestock.C_UOM_ID, --'0', --by malathi-10032017
				      -Cur_livestock.COST_DIFFERENCE,
				      Cur_livestock.c_currency_id, 'Y', 'Y', 'CC', Cur_livestock.CWPM_SdLveStock_ID,
				      'Y', Cur_livestock.COST_DIFFERENCE --by malathi
				    );

				 --------m_transaction_cost insertion--------------
				SELECT * INTO  v_NextNo FROM Ad_Sequence_Next('M_Transaction_Cost', Cur_livestock.AD_Org_ID) ;
				--v_cost = Cur_livestock.movementqty * Cur_livestock.CALCCOST;
				insert into m_transaction_cost
				( 
					m_transaction_cost_id,ad_client_id ,ad_org_id, created ,createdby,updated ,updatedby,isactive,
					m_transaction_id, cost, costdate, c_currency_id, m_costadjustmentline_id, isunitcost,dateacct)
				values( 
					v_NextNo, Cur_livestock.AD_Client_ID, Cur_livestock.AD_Org_ID, TO_DATE(NOW()), 
					Cur_livestock.createdby, TO_DATE(NOW()), Cur_livestock.updatedby, 'Y', v_NextNo1,
					--Cur_livestock.CALCCOST,
					--'0',  --by malathi-10032017
					-Cur_livestock.COST_DIFFERENCE,
					TO_DATE(NOW()), Cur_livestock.c_currency_id,
					null,'Y',TO_DATE(NOW())
				);

				 ---RAISE v_ResultStr ;
			
				END IF; --ZERO

			END LOOP;

			END IF;
				END IF; ---ISAMORT

			END IF; --LAYING --100317 by malathi

	 
		
	   

	    --EXMA_Workeffort_Validate - Finish Process Extension Point
		SELECT count(*) INTO v_count
		FROM DUAL
		where exists (select 1 from ad_ep_procedures where ad_extension_points_id = 'FF80818132FDD74F0132FDEFDF200024');
		IF (v_count=1) THEN
		  DECLARE
		    v_ep_instance VARCHAR(32); --OBTG:VARCHAR2--
		    v_extension_point_id VARCHAR(32) := 'FF80818132FDD74F0132FDEFDF200024'; --OBTG:VARCHAR2--
		  BEGIN
		    v_ep_instance := get_uuid();
		    PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'Record_ID',
		      v_Record_ID, NULL, NULL, NULL, NULL, NULL, NULL);
		    PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'User',
		      v_User_ID, NULL, NULL, NULL, NULL, NULL, NULL);
		    PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'Message',
		      NULL, NULL, NULL, NULL, NULL, NULL, v_Message);
		    PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'Result',
		    NULL, NULL, v_Result, NULL, NULL, NULL, NULL);
		    PERFORM AD_EXTENSION_POINT_HANDLER(v_ep_instance, v_extension_point_id);
		    SELECT p_number INTO v_Result
		    FROM ad_ep_instance_para
		    WHERE ad_ep_instance_id = v_ep_instance
		    AND parametername LIKE 'Result';	    
		    SELECT p_text INTO v_Message
		    FROM ad_ep_instance_para
		    WHERE ad_ep_instance_id = v_ep_instance
		    AND parametername LIKE 'Message';
			  
		    DELETE FROM ad_ep_instance_para
		    WHERE ad_ep_instance_id = v_ep_instance;
		  END;
		END IF;
	    ---- <<FINISH_PROCESS>>
	    --v_Message := v_Message || '@Created@: ' || v_NoRecords;
	      --  Update AD_PInstance
	      RAISE NOTICE '%','Updating PInstance - Finished' || v_Message ;
	      PERFORM AD_UPDATE_PINSTANCE(p_PInstance_ID, NULL, 'N', v_Result, v_Message) ;
	    RETURN;
	  END; --BODY
	 /* EXCEPTION
	WHEN OTHERS THEN
	  RAISE EXCEPTION '%','DATA_EXCEPTION' || v_ResultStr ;
	  v_ResultStr:= 'cwpf_customworkeffort==@ERROR=' || SQLERRM;
	  RAISE EXCEPTION '%','DATA_EXCEPTION' || v_ResultStr ;
	  -- ROLLBACK;
	  PERFORM AD_UPDATE_PINSTANCE(p_PInstance_ID, NULL, 'N', 0, v_ResultStr) ;
	  RETURN;  */
END ; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION cwpf_customworkeffort(character varying, character varying)
  OWNER TO tad;



-- Function: cwct_intgrtn_productionrun_we(character varying, character varying)

-- DROP FUNCTION cwct_intgrtn_productionrun_we(character varying, character varying);

CREATE OR REPLACE FUNCTION cwct_intgrtn_productionrun_we(p_pinstance_id character varying, p_productionplan_id character varying)
  RETURNS void AS
$BODY$ DECLARE 
/*************************************************************************
* The contents of this file are subject to the Exceloid Soft systems Pvt.Ltd
* Version  1.0.0  
* for calculating the Integration Work Effort Validation 
* The Original Code is Exceloid Openbravo ERP.
* The Initial Developer of the Original Code is Malathi Vaka 23-08-2016.

************************************************************************/
-- Logistice
  v_ResultStr VARCHAR(2000):=''; --OBTG:VARCHAR2--
  v_Message VARCHAR(2000):=''; --OBTG:VARCHAR2--
  -- Parameter
  --TYPE RECORD IS REFCURSOR;
    Cur_Parameter RECORD;
    Cur_Toolset RECORD;
    Cur_PP RECORD;
    Cur_livestock RECORD;
    V_ISAMORTIZATION char(1);
    V_ISLAYING char(1);

    --
    v_diffqty NUMERIC;
    v_cost NUMERIC;
    v_Record_ID VARCHAR(32):=NULL; --OBTG:VARCHAR2--
    v_User_ID VARCHAR(32); --OBTG:VARCHAR2--
    v_Org_ID VARCHAR(32); --OBTG:VARCHAR2--
    v_Client_ID VARCHAR(32); --OBTG:VARCHAR2--
    v_count NUMERIC;
    v_NextNo1 varchar(32);
--    v_count2 NUMBER;
--    v_Production_ID VARCHAR2(32);
    v_ProductionDate TIMESTAMP;
--    v_Name NVARCHAR2(60) ;
    -- p_ppline            NUMBER;
    -- p_plline          NUMBER;
--    v_ProductionPlan_ID VARCHAR2(32);
--    v_ProductionLine_ID VARCHAR2(32);
--    v_Quantity NUMBER;
--    v_UOM_ID VARCHAR2(32);
--    v_PInstance NUMBER;
--    v_doneQty NUMBER;
--    v_needQty NUMBER;
    v_QtyOnHand NUMERIC;
    p_Processed CHAR;
    v_ProductQty NUMERIC;
    v_NextNo VARCHAR(32); --OBTG:VARCHAR2--
    Quantity NUMERIC:=99999; -- unlimited
    v_Result NUMERIC:=1;

    CUR_PL_Post RECORD;
    Cur_ProductionPlan RECORD;

    FINISH_PROCESS BOOLEAN:=FALSE;
    v_is_included NUMERIC:=0;
    v_available_period NUMERIC:=0;
    v_is_ready AD_Org.IsReady%TYPE;
    v_is_tr_allow AD_OrgType.IsTransactionsAllowed%TYPE;
    v_isacctle AD_OrgType.IsAcctLegalEntity%TYPE;
    v_org_bule_id AD_Org.AD_Org_ID%TYPE;
    v_AD_Org_ID VARCHAR(32); --OBTG:VARCHAR2--
    v_prodline NUMERIC;
    v_line NUMERIC;
    v_AD_Pinstance_ID VARCHAR(32); --OBTG:VARCHAR2--
    v_productname m_product.name%TYPE;
    V_ISSTANDARD CHAR(1);
    V_standardcost NUMERIC;
    Cur_RawMaterial RECORD;
    v_attributesetinstance_id VARCHAR(32);

    v_exma_productionplan_id  VARCHAR(32);

    v_Productionplandate TIMESTAMP;
    Cur_RawMatStockCheck RECORD;
    CUR_liveStockCheck RECORD;
    v_liveStockmovqty NUMERIC;
    v_liveStockclosingqty NUMERIC;
    v_sumOfqtyonhand NUMERIC;
    v_liveStockProdId VARCHAR(32);
    v_liveStockLocId VARCHAR(32);
    CUR_shedWiseliveStockCheck RECORD;
    v_countcheck NUMERIC;
  BEGIN
    -- Process Parameters
    
    IF(p_PInstance_ID IS NOT NULL) THEN
      --  Update AD_PInstance
      RAISE NOTICE '%','Updating PInstance - Processing ' || p_PInstance_ID ;
      v_ResultStr:='PInstanceNotFound';
      PERFORM AD_UPDATE_PINSTANCE(p_PInstance_ID, NULL, 'Y', NULL, NULL) ;
      -- Get Parameters
      v_ResultStr:='ReadingParameters';
      FOR Cur_Parameter IN
        (SELECT i.Record_ID, i.AD_User_ID, i.AD_Org_ID, i.AD_Client_ID, p.ParameterName,
          p.P_String, p.P_Number, p.P_Date
        FROM AD_PINSTANCE i
        LEFT JOIN AD_PINSTANCE_PARA p
          ON i.AD_PInstance_ID=p.AD_PInstance_ID
        WHERE i.AD_PInstance_ID=p_PInstance_ID
        ORDER BY p.SeqNo) LOOP
        v_Record_ID:=Cur_Parameter.Record_ID;
        v_User_ID:=Cur_Parameter.AD_User_ID;
        v_Org_ID:=Cur_Parameter.AD_Org_ID;
        v_Client_ID:=Cur_Parameter.AD_Client_ID;
        
      END LOOP; -- Get Parameter
    ELSE
      RAISE NOTICE '%','--<<EXMA_WorkEffort_Validate>>' ;
    END IF;
  BEGIN 
 
  --BODY
 /*   SELECT Processed, MOVEMENTDATE, AD_ORG_ID
    INTO p_Processed, v_ProductionDate, v_AD_Org_ID
    FROM EXMA_PRODUCTION
    WHERE EXMA_Production_ID=v_Record_ID;
    --Check if is has been already processed
    IF(p_Processed='Y') THEN
      v_ResultStr:='Work Effort is already validated';
      v_Message:='@WorkEffortValidated@';
      RAISE EXCEPTION '%', v_Message; --OBTG:-20000--
    END IF;  */
--OBTG:-20000--
	-- for production runs
	SELECT processed, productionplandate, AD_ORG_ID
    INTO p_Processed, v_ProductionDate, v_AD_Org_ID
    FROM EXMA_PRODUCTIONPLAN
    WHERE EXMA_Productionplan_ID=p_productionplan_id;
    --Check if is has been already processed
    IF(p_Processed='Y') THEN
       v_ResultStr:='Production run is already validated';
      v_Message:='@CWPF_ProductionRunValidated@';
      RAISE EXCEPTION '%', v_Message; --OBTG:-20000--
    END IF; 
 

 --checking I/O products
    v_ResultStr:='Checking I/O Products';
    
     SELECT COUNT(*)
      INTO v_count
      FROM EXMA_PRODUCTIONLINE where EXMA_Productionplan_ID=p_productionplan_id;
      IF(v_count=0) THEN
        v_ResultStr := 'There are no products in I/O Products';
        v_Message:='@NeedLocator@';
        RAISE EXCEPTION '%', v_Message; --OBTG:-20000--
      END IF;

	-- checking live stock 
      v_ResultStr:='Checking LiveStock';
      SELECT COUNT(*)
      INTO v_count
      FROM CWCT_livestock where EXMA_ProductionPlan_ID=p_productionplan_id;
      IF(v_count=0) THEN
        v_ResultStr := 'There are no products in livestock';
        v_Message:='@NeedLiveStock@';
        RAISE EXCEPTION '%', v_Message; --OBTG:-20000--
      END IF;	
    
    SELECT count(*) INTO v_count
    FROM dual
    WHERE EXISTS (
        SELECT 1
        FROM EXMA_productionplan pp
            JOIN EXMA_productionline pl ON pp.EXMA_productionplan_id = pl.EXMA_productionplan_id
            JOIN m_product p ON p.m_product_id = pl.m_product_id
        WHERE pp.EXMA_production_id = v_record_id
          AND p.isgeneric = 'Y');
    IF (v_count > 0) THEN
      SELECT max(p.name) INTO v_productname
      FROM EXMA_productionplan pp
          JOIN EXMA_productionline pl ON pp.EXMA_productionplan_id = pl.EXMA_productionplan_id
          JOIN EXMA_product p ON p.m_product_id = pl.m_product_id
      WHERE pp.exma_production_id = v_record_id
        AND p.isgeneric = 'Y';
      RAISE EXCEPTION '%', '@CannotUseGenericProduct@ ' || v_productName; --OBTG:-20000--
    END IF;
    
    IF(NOT FINISH_PROCESS) THEN
      -- Check that there are some parts of the job and that theay are processed
      
      -- Check the header belongs to a organization where transactions are posible and ready to use
      SELECT AD_Org.IsReady, Ad_OrgType.IsTransactionsAllowed
      INTO v_is_ready, v_is_tr_allow
      FROM EXMA_PRODUCTION, AD_Org, AD_OrgType
      WHERE AD_Org.AD_Org_ID=EXMA_PRODUCTION.AD_Org_ID
      AND AD_Org.AD_OrgType_ID=AD_OrgType.AD_OrgType_ID
      AND EXMA_PRODUCTION.EXMA_PRODUCTION_ID=v_Record_ID;
      IF (v_is_ready='N') THEN
        RAISE EXCEPTION '%', '@OrgHeaderNotReady@'; --OBTG:-20000--
      END IF;
      IF (v_is_tr_allow='N') THEN
        RAISE EXCEPTION '%', '@OrgHeaderNotTransAllowed@'; --OBTG:-20000--
      END IF;
      
      SELECT AD_ORG_CHK_DOCUMENTS('EXMA_PRODUCTION', 'EXMA_PRODUCTIONPLAN', v_Record_ID, 'EXMA_PRODUCTION_ID', 'EXMA_PRODUCTION_ID') INTO v_is_included FROM dual;
      IF (v_is_included=-1) THEN
        RAISE EXCEPTION '%', '@LinesAndHeaderDifferentLEorBU@'; --OBTG:-20000--
      END IF;
      FOR CUR_PP IN
        (SELECT EXMA_PRODUCTIONPLAN_ID
         FROM EXMA_PRODUCTIONPLAN
         WHERE EXMA_PRODUCTION_ID = v_Record_ID) LOOP
        SELECT AD_ORG_CHK_DOCUMENTS('EXMA_PRODUCTIONPLAN', 'EXMA_PRODUCTIONLINE', CUR_PP.EXMA_PRODUCTIONPLAN_ID, 'EXMA_PRODUCTIONPLAN_ID', 'EXMA_PRODUCTIONPLAN_ID') INTO v_is_included FROM dual;
        IF (v_is_included=-1) THEN
          RAISE EXCEPTION '%', '@LinesAndHeaderDifferentLEorBU@'; --OBTG:-20000--
        END IF;
      END LOOP;      
      
      -- Check the period control is opened (only if it is legal entity with accounting)
      -- Gets the BU or LE of the document
      SELECT AD_GET_DOC_LE_BU('EXMA_PRODUCTION', v_Record_ID, 'EXMA_PRODUCTION_ID', 'LE')
      INTO v_org_bule_id
      FROM DUAL;
      
      SELECT AD_OrgType.IsAcctLegalEntity
      INTO v_isacctle
      FROM AD_OrgType, AD_Org
      WHERE AD_Org.AD_OrgType_ID = AD_OrgType.AD_OrgType_ID
      AND AD_Org.AD_Org_ID=v_org_bule_id;
      
      IF (v_isacctle='Y') THEN
        SELECT C_CHK_OPEN_PERIOD(v_AD_Org_ID, v_ProductionDate, 'MMP', NULL) 
        INTO v_available_period
        FROM DUAL;
        
        IF (v_available_period<>1) THEN
          RAISE EXCEPTION '%', '@PeriodNotAvailable@'; --OBTG:-20000--
        END IF;
      END IF;	
      
      
      v_ResultStr:='Checking ProductionRun';
      SELECT COUNT(*)
      INTO v_count
      FROM EXMA_PRODUCTIONPLAN
      WHERE EXMA_Production_ID=v_Record_ID;
      IF(v_count=0) THEN
        v_ResultStr := 'There are not Production Runs to validate';
        v_Message:='@NoProductionRun@';
        RAISE EXCEPTION '%', v_Message; --OBTG:-20000--
      END IF;
    END IF; --FINISH_PROCESS
    IF(NOT FINISH_PROCESS) THEN
      SELECT COUNT(*)
      INTO v_count
      FROM EXMA_PRODUCTIONPLAN pp
      WHERE EXMA_Production_ID=v_Record_ID
      -- newly added below line
      AND EXMA_PRODUCTIONPLAN_ID = p_productionplan_id
      --  AND PROCESSED='N';
      AND PROCESSED='Y';
      IF(v_count<>0) THEN
        v_Message:='@ProducionRunNoProcessed@';
        RAISE EXCEPTION '%', v_Message; --OBTG:-20000--
        FINISH_PROCESS:=TRUE;
      END IF;
    END IF; --FINISH_PROCESS
    IF(NOT FINISH_PROCESS) THEN
      --Check if there's any global use production phase.
      SELECT COUNT(*)
      INTO v_count
      FROM EXMA_PRODUCTIONPLAN pp,
        EXMA_WRPHASE wp
      WHERE pp.EXMA_WRPHASE_ID=wp.EXMA_WRPHASE_ID
        AND pp.EXMA_PRODUCTION_ID=v_Record_ID
        AND wp.GROUPUSE='Y';
      IF(v_count<>0) THEN
        v_ResultStr:='Distributing product of global use';
        PERFORM EXMA_GLOBALUSE_DISTRIBUTE(v_Client_ID, v_AD_Org_ID, v_User_ID, v_Record_ID) ;
      END IF;
    END IF; --FINISH_PROCESS
 /*   IF(NOT FINISH_PROCESS) THEN
      --Check if all the ProductionLine have a warehouse
      v_ResultStr:='Checking Locators';
      SELECT COUNT(*)
      INTO v_count
      FROM EXMA_PRODUCTIONLINE l,
        EXMA_PRODUCTIONPLAN p
      WHERE l.EXMA_ProductionPlan_ID=p.EXMA_ProductionPlan_ID
        AND p.EXMA_Production_ID=v_Record_ID
        AND l.M_Locator_ID IS NULL;
      IF(v_count<>0) THEN
        v_ResultStr := 'There are produts without Locator';
        v_Message:='@NeedLocator@';
        RAISE EXCEPTION '%', v_Message; --OBTG:-20000--
        FINISH_PROCESS:=TRUE;
      END IF;
    END IF; --FINISH_PROCESS  */
    --Check negative quantities for P+ and P- in Production Line if its a Work Effort
    IF(NOT FINISH_PROCESS) THEN
			v_Message := NULL;
			v_Count:=0;
			SELECT COUNT(EXMA_ProductionPlan_ID)
        INTO v_Count
        FROM EXMA_ProductionPlan pp
        WHERE pp.EXMA_Production_ID = v_Record_ID
        AND EXISTS
        (SELECT 1 FROM EXMA_ProductionLine
        WHERE EXMA_ProductionPlan_ID = pp.EXMA_ProductionPlan_ID
        AND pp.EXMA_Wrphase_ID IS NOT NULL
        AND MovementQty < 0);
			IF (v_Count <> 0) THEN
				FOR Cur_ProductionPlan IN (
				SELECT PP.Line AS PPLine, PL.LINE AS PLLine
				FROM EXMA_ProductionLine PL,
				EXMA_ProductionPlan PP
				WHERE PL.EXMA_ProductionPlan_ID = PP.EXMA_ProductionPlan_ID
				AND PP.EXMA_Production_ID = v_Record_ID
				AND PL.MovementQty < 0
				AND PP.EXMA_WrPhase_ID IS NOT NULL
				ORDER BY PP.Line, PL.Line
				)
				LOOP
					IF v_Message IS NULL THEN
						v_Message:=Cur_ProductionPlan.PPLine||'-'||Cur_ProductionPlan.PLLine;
					ELSE
						v_Message:=v_Message || ', ' || Cur_ProductionPlan.PPLine||'-'||Cur_ProductionPlan.PLLine;
					END IF;
				END LOOP;
				v_Message:='@NoNegativeMovementQtyInWorkEffortProductLine@'||v_Message;
				RAISE EXCEPTION '%', v_Message; --OBTG:-20000--
        FINISH_PROCESS:=TRUE;
			END IF;
    END IF;
    --Check if exist any product in a productionplan with the same locator and productiontype P+ and P-
    IF(NOT FINISH_PROCESS) THEN
      SELECT COUNT(*)
      INTO v_count
      FROM EXMA_PRODUCTIONLINE pl, EXMA_PRODUCTIONPLAN pp
      WHERE pl.PRODUCTIONTYPE='+'
        AND pl.EXMA_PRODUCTIONPLAN_ID = pp.EXMA_PRODUCTIONPLAN_ID
        AND pp.EXMA_PRODUCTION_ID = v_Record_ID
        AND EXISTS
        (SELECT 1
        FROM EXMA_PRODUCTIONLINE
        WHERE EXMA_PRODUCTIONPLAN_ID=pl.EXMA_PRODUCTIONPLAN_ID
          AND M_PRODUCT_ID=pl.M_PRODUCT_ID
          AND PRODUCTIONTYPE='-'
        )
        ;
      IF(v_count<>0) THEN
        -- ROLLBACK;
        v_ResultStr := 'Same product in a production plan as P+ and P-';
        v_Message:='@P+AndP-InSamePlan@';
        RAISE EXCEPTION '%', v_Message; --OBTG:-20000--
        FINISH_PROCESS:=TRUE;
      END IF;
    END IF; --FINISH_PROCESS


    -----START by Malathi
	v_ResultStr:='ProductAttributeSetValue Updation';

		FOR Cur_RawMaterial IN (
			select PPL.m_locator_id, ppl.M_PRODUCT_ID, ppl.AD_ORG_ID,EXMA_PRODUCTIONLINE_id
			from   EXMA_PRODUCTIONLINE ppl 
			WHERE ppl.PRODUCTIONTYPE = '-'
			AND ppl.EXMA_PRODUCTIONPLAN_ID = p_productionplan_id
			) LOOP --L1

				select M_ATTRIBUTESETINSTANCE_ID  INTO v_ATTRIBUTESETINSTANCE_ID
				from m_storage_detail where m_product_id =  Cur_RawMaterial.M_PRODUCT_ID
				and m_locator_id =  Cur_RawMaterial.m_locator_id
				and ad_org_id  = Cur_RawMaterial.AD_ORG_ID
				and qtyonhand <> 0;

				IF ( v_ATTRIBUTESETINSTANCE_ID IS NOT NULL ) THEN --ASET


						--update EXMA_PRODUCTIONLINE set M_ATTRIBUTESETINSTANCE_ID=v_ATTRIBUTESETINSTANCE_ID
						--where EXMA_PRODUCTIONLINE_id = Cur_RawMaterial.EXMA_PRODUCTIONLINE_id;

				ELSE --ASET
						update EXMA_PRODUCTIONLINE set M_ATTRIBUTESETINSTANCE_ID='0'
						where EXMA_PRODUCTIONLINE_id = Cur_RawMaterial.EXMA_PRODUCTIONLINE_id;
				END IF; --ASET


			END LOOP; --L1

	--END by Malathi
    
    IF (NOT FINISH_PROCESS) THEN
      SELECT COUNT(*), MAX(pp.line), MAX(PL.LINE)
      INTO v_Count, v_prodline, v_line
      FROM EXMA_PRODUCTIONPLAN PP, EXMA_PRODUCTIONLINE PL, M_PRODUCT P
      WHERE PL.M_PRODUCT_ID=P.M_PRODUCT_ID
        AND P.M_ATTRIBUTESET_ID IS NOT NULL
        AND (P.ATTRSETVALUETYPE IS NULL OR P.ATTRSETVALUETYPE <> 'F')
        AND (SELECT ISONEATTRSETVALREQUIRED FROM M_ATTRIBUTESET WHERE M_ATTRIBUTESET_ID = P.M_ATTRIBUTESET_ID) = 'Y'
        AND COALESCE(PL.M_ATTRIBUTESETINSTANCE_ID, '0') = '0'
        AND PL.EXMA_ProductionPlan_ID=pp.EXMA_ProductionPlan_ID
        AND pp.EXMA_Production_ID=v_Record_ID;
      IF v_Count<>0 THEN
        RAISE EXCEPTION '%', '@inProductionPlan@'||' '||'@line@'||' '||v_prodline||', '||'@Inline@'||' '||v_line||' '||'@productWithoutAttributeSet@' ; --OBTG:-20000--
        FINISH_PROCESS:=TRUE;
      END IF;
    END IF;
    -- All Production Lines
    IF(NOT FINISH_PROCESS) THEN

    --Added by jhansi for resolving insufficient stock issue
 
select count(*) into v_countcheck from exma_productionline where exma_productionplan_id = p_productionplan_id and M_AttributeSetInstance_ID is not null;

            IF (v_countcheck > 0) THEN

                 --  PERFORM EXMA_ATTRIBUTEALLOCATION( p_productionplan_id,v_User_ID );

            END IF;
      
       --Ended by jhansi   
       
      FOR CUR_PL_Post IN
        (SELECT pl.EXMA_ProductionLine_ID, pl.AD_Client_ID, pl.AD_Org_ID, p.MovementDate, pp.starttime,
          pl.M_Product_ID, pl.M_AttributeSetInstance_ID, pl.MovementQty, pl.M_Locator_ID,
          pl.M_Product_UOM_ID, pl.QuantityOrder, pl.C_UOM_ID, pl.LINE, pl.PRODUCTIONTYPE,
          pr.ISSTOCKED, pr.PRODUCTTYPE
        FROM EXMA_PRODUCTION p, EXMA_PRODUCTIONLINE pl, EXMA_PRODUCTIONPLAN pp, M_PRODUCT pr
        WHERE p.EXMA_Production_ID=pp.EXMA_Production_ID
          AND pp.EXMA_ProductionPlan_ID=pl.EXMA_ProductionPlan_ID
          AND pp.EXMA_Production_ID=v_Record_ID
          And pp.EXMA_ProductionPlan_ID = p_productionplan_id
          AND pl.M_PRODUCT_ID=pr.M_PRODUCT_ID
          AND pr.ISSTOCKED='Y'
        ORDER BY pp.Line, pl.Line)
      LOOP
        -- EXMA_ProductionLine_ID, AD_Client_ID, AD_Org_ID, MovementDate, M_Product_ID, MovementQty, M_Locator_ID
        -- DBMS_OUTPUT.PUT_LINE('ProductionLine=' || CUR_PL_Post.M_ProductionLine_ID);
        -- DBMS_OUTPUT.PUT_LINE('  Qty=' || CUR_PL_Post.MovementQty || ', OnHand=' || M_BOM_Qty_OnHand(CUR_PL_Post.M_Product_ID, NULL, CUR_PL_Post.M_Locator_ID));
        -- Check Stock levels for reductions
        -- Check, if product exists and if it is stocked
        -- Unlimited capacity if no item
        IF(CUR_PL_Post.ProductType<>'I' OR CUR_PL_Post.IsStocked='N') THEN
          v_QtyOnHand:=Quantity;
          -- Stocked item
        ELSIF(CUR_PL_Post.IsStocked='Y') THEN
          -- Get ProductQty
          SELECT COALESCE(SUM(QtyOnHand), 0)
          INTO v_ProductQty
          FROM M_STORAGE_DETAIL s
          WHERE M_Product_ID=CUR_PL_Post.M_Product_ID
            AND EXISTS
            (SELECT * FROM M_LOCATOR l WHERE s.M_Locator_ID=l.M_Locator_ID)
            ;
          --DBMS_OUTPUT.PUT_LINE('Qty=' || ProductQty);
          v_QtyOnHand:=v_ProductQty;
        END IF;

-- Added by jhansi for Negative Stock Control
   select exma_productionplan_id,Productionplandate into v_exma_productionplan_id,v_Productionplandate from exma_productionplan 
   where exma_productionplan.exma_productionplan_id=p_productionplan_id;

--Started stock validation for livestock


FOR CUR_liveStockCheck IN
       (select CWCT_Livestock.CWCT_Livestock_id,CWCT_Livestock.m_product_id  from exma_productionplan
        join CWCT_Livestock
        on CWCT_Livestock.exma_productionplan_id  = exma_productionplan.exma_productionplan_id
        
        where exma_productionplan.exma_productionplan_id = v_exma_productionplan_id)
    LOOP


FOR CUR_shedWiseliveStockCheck IN
       (select CWPM_SdLveStock.CWCT_Livestock_id,CWPM_SdLveStock.M_Locator_ID,CWPM_SdLveStock.m_product_id ,m_product.name from CWPM_SdLveStock
       join m_product
       on m_product.m_product_id = CWPM_SdLveStock.m_product_id
        where CWCT_Livestock_id = CUR_liveStockCheck.CWCT_Livestock_id)
    LOOP

select Movementqty,Cwpm_Closing_Stock into v_liveStockmovqty,v_liveStockclosingqty from CWPM_SdLveStock where CWCT_Livestock_id  = CUR_shedWiseliveStockCheck.CWCT_Livestock_id and M_Locator_ID = CUR_shedWiseliveStockCheck.M_Locator_ID;

select sum(QtyOnHand) into v_sumOfqtyonhand from M_Storage_Detail where m_product_id = CUR_shedWiseliveStockCheck.m_product_id and M_Locator_ID = CUR_shedWiseliveStockCheck.M_Locator_ID;

IF(v_sumOfqtyonhand < v_liveStockmovqty or v_sumOfqtyonhand < v_liveStockclosingqty)THEN


        v_Message:= 'Insufficient Livestock for the product ' || CUR_shedWiseliveStockCheck.name;

        RAISE EXCEPTION '%',v_Message;


END IF;

IF(v_sumOfqtyonhand > v_liveStockmovqty )THEN


        v_Message:= 'Livestock movementqty is less than the available stock for the product ' || CUR_shedWiseliveStockCheck.name;

        RAISE EXCEPTION '%',v_Message;


END IF;


   END LOOP;

END LOOP;
--Ended stock validation for livestock
   

--IF (CUR_PL_Post.M_AttributeSetInstance_ID is null or CUR_PL_Post.PRODUCTIONTYPE = '+' ) THEN  --Added by jhansi for resolving insufficient stock issue

if (CUR_PL_Post.PRODUCTIONTYPE = '-') then 
    PERFORM EXMA_INTSTOCKCHECK(CUR_PL_Post.AD_Org_ID,CUR_PL_Post.AD_Client_ID, CUR_PL_Post.M_Product_ID,CUR_PL_Post.MovementQty,v_Productionplandate,CUR_PL_Post.M_Locator_ID,CUR_PL_Post.M_AttributeSetInstance_ID);

end if; 

-- Ended by jhansi



        -- Only insert in M_TRANSACTION if MovementQty <> 0
        IF CUR_PL_Post.MovementQty <> 0 THEN
          -- Create Transaction Entry        
           v_ResultStr:='CreateTransaction';
          SELECT * INTO  v_NextNo FROM Ad_Sequence_Next('M_Transaction', v_Org_ID) ;
          INSERT
          INTO M_TRANSACTION
            (
              M_Transaction_ID, EM_EXMA_ProductionLine_ID, AD_Client_ID, AD_Org_ID,
              IsActive, Created, CreatedBy, Updated,
              UpdatedBy, MovementType, M_Locator_ID, M_Product_ID,
              M_AttributeSetInstance_ID,
		MovementDate, MovementQty,-- M_Product_UOM_ID,
             -- QuantityOrder,
		C_UOM_ID
            )
            VALUES
            (
              v_NextNo, CUR_PL_Post.EXMA_ProductionLine_ID, CUR_PL_Post.AD_Client_ID, CUR_PL_Post.AD_Org_ID,
              'Y', TO_DATE(NOW()), v_User_ID, TO_DATE(NOW()),
              v_User_ID, 'P+', CUR_PL_Post.M_Locator_ID, CUR_PL_Post.M_Product_ID,
             COALESCE(CUR_PL_Post.M_AttributeSetInstance_ID, '0'), -- not distinguishing between assemby/disassembly
              CUR_PL_Post.starttime,(CASE CUR_PL_Post.PRODUCTIONTYPE WHEN '+' THEN CUR_PL_Post.MovementQty ELSE -CUR_PL_Post.MOVEMENTQTY END), --COALESCE(CUR_PL_Post.M_Product_UOM_ID,''),
              --(CASE CUR_PL_Post.PRODUCTIONTYPE WHEN '+' THEN CUR_PL_Post.QUANTITYORDER ELSE COALESCE(-CUR_PL_Post.QuantityOrder,'') END), 
              CUR_PL_Post.C_UOM_ID
            )
            ;

            END IF; 
        --  END IF; -- IF (CUR_PL_Post.M_AttributeSetInstance_ID is null or CUR_PL_Post.PRODUCTIONTYPE = '+' )
       /* IF(CUR_PL_Post.IsStocked<>'N') THEN
          SELECT * INTO  v_Result, v_Message FROM M_Check_Stock(CUR_PL_Post.M_Product_ID, v_Client_ID, v_AD_Org_ID) ;
          IF (v_Result=0) THEN
            v_Message:=v_Message || ' @Inline@ ' || CUR_PL_Post.line;
            RAISE EXCEPTION '%', v_Message; --OBTG:-20000--
          END IF;
        END IF;*/
      END LOOP;
    END IF; --FINISH_PROCESS




	
    IF (NOT FINISH_PROCESS) THEN

		SELECT * INTO  v_Message FROM CWCT_INTGRATNPRODUCTN_COSTCAL(v_Record_ID, p_productionplan_id, v_User_ID); --by malathi
     
    END IF; --FINISH_PROCESS
    IF(NOT FINISH_PROCESS) THEN
      -- Update donequantity on workrequirements
      v_ResultStr:='Updating workrequirement';
      FOR Cur_ProductionPlan IN
        (SELECT *  FROM EXMA_PRODUCTIONPLAN pp  WHERE pp.EXMA_PRODUCTION_ID=v_Record_ID)
      LOOP
        UPDATE EXMA_WRPHASE
          SET DONEQUANTITY=DONEQUANTITY + Cur_ProductionPlan.PRODUCTIONQTY, RUNTIME=Cur_ProductionPlan.RUNTIME,
          UPDATED=TO_DATE(NOW())
        WHERE EXMA_WRPhase_ID=Cur_ProductionPlan.EXMA_WRPHASE_ID;

         -- Close Phase if its marked
	IF (Cur_ProductionPlan.CLOSEPHASE='Y') THEN
	  v_AD_Pinstance_ID := GET_UUID();
	  INSERT INTO AD_PINSTANCE 
	  (AD_PINSTANCE_ID, AD_PROCESS_ID, RECORD_ID, ISACTIVE, 
	  AD_USER_ID, AD_CLIENT_ID, AD_ORG_ID, CREATED, CREATEDBY,
	  UPDATED, UPDATEDBY)
	  VALUES
	  (v_AD_Pinstance_ID,'D7715DEFF29D49C88A92F1C4E6E75446',Cur_ProductionPlan.EXMA_WRPHASE_ID,'Y',
	  v_User_ID, v_Client_ID, v_Org_ID, TO_DATE(NOW()), v_User_ID,
	  TO_DATE(NOW()), v_User_ID
	  );
	  PERFORM EXMA_WRPHASE_CLOSE(v_AD_Pinstance_ID,'N');
	END IF;
      END LOOP;
      -- Indicate that we are done
  /*    UPDATE EXMA_PRODUCTION
        SET Processed='Y',
        updated=TO_DATE(NOW()),
        updatedby=v_User_ID
      WHERE EXMA_Production_ID=v_Record_ID;     */

-- Updating production run as second time it should not process
	UPDATE EXMA_PRODUCTIONPlan
        SET Processed='Y',
        updated=TO_DATE(NOW()),
        updatedby=v_User_ID
      WHERE EXMA_Productionplan_ID=p_productionplan_id;   

      
    END IF; --FINISH_PROCESS
    IF(NOT FINISH_PROCESS) THEN
      v_ResultStr:='Updating used toolsets';
      FOR Cur_Toolset IN
        (SELECT EXMA_TOOLSETUSED.*
         FROM EXMA_TOOLSETUSED, EXMA_PRODUCTIONPLAN
         WHERE EXMA_TOOLSETUSED.EXMA_PRODUCTIONPLAN_ID = EXMA_PRODUCTIONPLAN.EXMA_PRODUCTIONPLAN_ID
           AND EXMA_PRODUCTIONPLAN.EXMA_PRODUCTION_ID = v_Record_ID) LOOP
        UPDATE EXMA_TOOLSET
        SET NUMBERUSES = NUMBERUSES + Cur_Toolset.USED
        WHERE EXMA_TOOLSET_ID = Cur_Toolset.EXMA_TOOLSET_ID;
      END LOOP;
    END IF;

	v_ResultStr:='LiveStock cost Insertion';
	V_COUNT := 0;
	V_standardcost :=0;
 
	select count(*) into v_count FROM CWCT_LIVESTOCK ls
	--LEFT JOIN M_PRODUCT_ORG po on ls.M_Product_Id = po.M_Product_Id
	LEFT JOIN EXMA_PRODUCTIONPLAN pp on ls.EXMA_PRODUCTIONPLAN_ID = pp.EXMA_PRODUCTIONPLAN_ID
	--LEFT JOIN AD_ORG o on pp.ad_org_id = o.ad_org_id
	Where ls.EXMA_PRODUCTIONPLAN_ID = p_productionplan_id
	and ls.calculated = 'Y' 
        group BY ls.Line ;

        IF ( V_COUNT = 0 ) THEN

	v_ResultStr := 'NO COST CALCULATED PRODUCTS IN LIVE STOCK';
	
        RAISE EXCEPTION '%',v_ResultStr;

	ELSE 
	
	FOR Cur_livestock IN 

	(select ls.*, pp.starttime, o.c_currency_id, P.NAME, o.NAME AS ORGNAME
	FROM CWPM_SdLveStock ls
	LEFT JOIN M_PRODUCT  P on ls.M_Product_Id = P.M_Product_Id
	LEFT JOIN EXMA_PRODUCTIONPLAN pp on ls.EXMA_PRODUCTIONPLAN_ID = pp.EXMA_PRODUCTIONPLAN_ID
	LEFT JOIN AD_ORG o on pp.ad_org_id = o.ad_org_id
	Where ls.EXMA_PRODUCTIONPLAN_ID = p_productionplan_id
	--and ls.calculated = 'Y' --by Tirumala
        ORDER BY ls.Line)
	
	LOOP

	v_diffqty = Cur_livestock.movementqty - Cur_livestock.cwpm_closing_stock;

	v_ResultStr:='Closing Qty is greater than Opening Qty';
	--IF(v_diffqty >= 0) THEN
	IF(v_diffqty > 0) THEN  --by Malathi 09032017

	SELECT * INTO  v_NextNo1 FROM Ad_Sequence_Next('M_Transaction', Cur_livestock.AD_Org_ID) ;
	--v_cost = Cur_livestock.movementqty * Cur_livestock.CALCCOST; --by malathi
 	INSERT
	INTO M_TRANSACTION
            (
              M_Transaction_ID, AD_Client_ID, AD_Org_ID,
              IsActive, Created, CreatedBy, Updated,
              UpdatedBy, MovementType, M_Locator_ID, M_Product_ID,
              M_AttributeSetInstance_ID, MovementDate, MovementQty,
              C_UOM_ID, transactioncost, c_currency_id, iscostcalculated, isprocessed, costing_status,em_cwpm_sdlvestock,
	      em_cwlg_islivestock, em_cwlg_livestockqty
            )
            VALUES
            (
              v_NextNo1, Cur_livestock.AD_Client_ID, Cur_livestock.AD_Org_ID,
              'Y', TO_DATE(NOW()), Cur_livestock.createdby, TO_DATE(NOW()),
              Cur_livestock.updatedby, 'P+', Cur_livestock.M_Locator_ID, Cur_livestock.M_Product_ID,
              '0', -- not distinguishing between assemby/disassembly
              Cur_livestock.starttime,
	      -v_diffqty,
              Cur_livestock.C_UOM_ID, --'0', --by malathi-09032017
	      Cur_livestock.COST_DIFFERENCE,
              Cur_livestock.c_currency_id, 'Y', 'Y', 'CC', Cur_livestock.CWPM_SdLveStock_ID,
	      'Y', Cur_livestock.COST_DIFFERENCE --by malathi
            );
	 --------m_transaction_cost insertion--------------
	SELECT * INTO  v_NextNo FROM Ad_Sequence_Next('M_Transaction_Cost', Cur_livestock.AD_Org_ID) ;
	--v_cost = Cur_livestock.movementqty * Cur_livestock.CALCCOST;
	insert into m_transaction_cost
	( 
		m_transaction_cost_id,ad_client_id ,ad_org_id, created ,createdby,updated ,updatedby,isactive,
		m_transaction_id, cost, costdate, c_currency_id, m_costadjustmentline_id, isunitcost,dateacct)
	values( 
		v_NextNo, Cur_livestock.AD_Client_ID, Cur_livestock.AD_Org_ID, TO_DATE(NOW()), 
		Cur_livestock.createdby, TO_DATE(NOW()), Cur_livestock.updatedby, 'Y', v_NextNo1,
		--Cur_livestock.CALCCOST,
		--'0',  --by malathi-09032017
	        Cur_livestock.COST_DIFFERENCE,TO_DATE(NOW()), Cur_livestock.c_currency_id,
		null,'Y',TO_DATE(NOW())
	);

	/*v_ResultStr:='Estimation cost not updated in Live Stock';
	IF(Cur_livestock.CALCCOST IS NOT NULL) THEN
	
			SELECT PO.em_cwct_isstandard, PO.em_cwct_standardcost INTO V_ISSTANDARD, V_standardcost 
			FROM M_PRODUCT_ORG PO
			WHERE PO.M_PRODUCT_ID = Cur_LiveStock.M_PRODUCT_ID
			AND PO.AD_ORG_ID = Cur_LiveStock.AD_ORG_ID;
 
	
	
		v_ResultStr := 'Costing Insertion';
		 IF(V_ISSTANDARD = 'Y') THEN

			SELECT * INTO  v_NextNo FROM Ad_Sequence_Next('M_Costing', Cur_livestock.AD_ORG_ID);
			INSERT INTO M_COSTING (M_COSTING_ID, CREATED, CREATEDBY, UPDATED, UPDATEDBY, AD_CLIENT_ID,
				    AD_ORG_ID, M_PRODUCT_ID, DATETO, DATEFROM, ISMANUAL,
				    QTY,
				    PRICE,  CUMQTY,
				    COST, EM_CWCT_TOTALCOST, ISPERMANENT, ISPRODUCTION, COSTTYPE)
			     VALUES (v_NextNo, TO_DATE(NOW()), Cur_livestock.createdby, TO_DATE(NOW()),  Cur_livestock.updatedby, 
				    Cur_livestock.AD_Client_ID, Cur_livestock.AD_Org_ID,  Cur_livestock.M_PRODUCT_ID,
				    TO_DATE('31-12-9999','DD-MM-YYYY'),  Cur_livestock.starttime, 'N', Cur_livestock.cwpm_closing_stock,
				    COALESCE(V_standardcost,0), Cur_livestock.cwpm_closing_stock,
				    (CASE (Cur_livestock.MOVEMENTQTY) WHEN 0 THEN 0 ELSE COALESCE(V_standardcost,0) END),
				    COALESCE(Cur_livestock.CALCCOST,0),  
				    'N', 'Y', 'STA');

		 ELSE 

			SELECT * INTO  v_NextNo FROM Ad_Sequence_Next('M_Costing', Cur_livestock.AD_ORG_ID);
			INSERT INTO M_COSTING (M_COSTING_ID, CREATED, CREATEDBY, UPDATED, UPDATEDBY, AD_CLIENT_ID,
				    AD_ORG_ID, M_PRODUCT_ID, DATETO, DATEFROM, ISMANUAL,
				    QTY,
				    PRICE,  CUMQTY,
				    COST,  EM_CWCT_TOTALCOST, ISPERMANENT, ISPRODUCTION, COSTTYPE)
			     VALUES (v_NextNo, TO_DATE(NOW()), Cur_livestock.createdby, TO_DATE(NOW()),  Cur_livestock.updatedby, 
				    Cur_livestock.AD_Client_ID, Cur_livestock.AD_Org_ID,  Cur_livestock.M_PRODUCT_ID,
				    TO_DATE('31-12-9999','DD-MM-YYYY'),  Cur_livestock.starttime, 'N', Cur_livestock.cwpm_closing_stock,
				    ROUND((Cur_livestock.CALCCOST/Cur_livestock.MOVEMENTQTY),3), Cur_livestock.cwpm_closing_stock,
				    (CASE (Cur_livestock.MOVEMENTQTY) WHEN 0 THEN 0 ELSE ROUND((Cur_livestock.CALCCOST/Cur_livestock.MOVEMENTQTY),3) END),
				    COALESCE(Cur_livestock.CALCCOST,0),
				    'N', 'Y', 'AVA');

		 END IF;     
           

	ELSE 
	
	 RAISE EXCEPTION '%',v_ResultStr ;
	
	END IF;*/

	ELSE 

		SELECT * INTO  v_NextNo1 FROM Ad_Sequence_Next('M_Transaction', Cur_livestock.AD_Org_ID) ;
	--v_cost = Cur_livestock.movementqty * Cur_livestock.CALCCOST; --by malathi
 	INSERT
	INTO M_TRANSACTION
            (
              M_Transaction_ID, AD_Client_ID, AD_Org_ID,
              IsActive, Created, CreatedBy, Updated,
              UpdatedBy, MovementType, M_Locator_ID, M_Product_ID,
              M_AttributeSetInstance_ID, MovementDate, MovementQty,
              C_UOM_ID, transactioncost, c_currency_id, iscostcalculated, isprocessed, costing_status,em_cwpm_sdlvestock,
	      em_cwlg_islivestock, em_cwlg_livestockqty
            )
            VALUES
            (
              v_NextNo1, Cur_livestock.AD_Client_ID, Cur_livestock.AD_Org_ID,
              'Y', TO_DATE(NOW()), Cur_livestock.createdby, TO_DATE(NOW()),
              Cur_livestock.updatedby, 'P+', Cur_livestock.M_Locator_ID, Cur_livestock.M_Product_ID,
              '0', -- not distinguishing between assemby/disassembly
              Cur_livestock.starttime,
	      -v_diffqty,
              Cur_livestock.C_UOM_ID, --'0', --by malathi-09032017
	      -Cur_livestock.COST_DIFFERENCE,
              Cur_livestock.c_currency_id, 'Y', 'Y', 'CC', Cur_livestock.CWPM_SdLveStock_ID,
	      'Y', Cur_livestock.COST_DIFFERENCE --by malathi
            );
	 --------m_transaction_cost insertion--------------
	SELECT * INTO  v_NextNo FROM Ad_Sequence_Next('M_Transaction_Cost', Cur_livestock.AD_Org_ID) ;
	--v_cost = Cur_livestock.movementqty * Cur_livestock.CALCCOST;
	insert into m_transaction_cost
	( 
		m_transaction_cost_id,ad_client_id ,ad_org_id, created ,createdby,updated ,updatedby,isactive,
		m_transaction_id, cost, costdate, c_currency_id, m_costadjustmentline_id, isunitcost,dateacct)
	values( 
		v_NextNo, Cur_livestock.AD_Client_ID, Cur_livestock.AD_Org_ID, TO_DATE(NOW()), 
		Cur_livestock.createdby, TO_DATE(NOW()), Cur_livestock.updatedby, 'Y', v_NextNo1,
		--Cur_livestock.CALCCOST,
		--'0',  --by malathi-09032017
	        -Cur_livestock.COST_DIFFERENCE,TO_DATE(NOW()), Cur_livestock.c_currency_id,
		null,'Y',TO_DATE(NOW())
	);

	 --RAISE v_ResultStr ;
		
	END IF;

	END LOOP;

	END IF; 
	

/*	FOR Cur_livestock1 IN 

	(select ls.*, pp.*, o.c_currency_id, po.em_cwct_isstandard, 
	po.em_cwct_standardcost as standardcost FROM CWCT_LIVESTOCK ls
	LEFT JOIN M_PRODUCT_ORG po on ls.M_Product_Id = po.M_Product_Id
	LEFT JOIN EXMA_PRODUCTIONPLAN pp on ls.EXMA_PRODUCTIONPLAN_ID = pp.EXMA_PRODUCTIONPLAN_ID
	LEFT JOIN AD_ORG o on pp.ad_org_id = o.ad_org_id
	Where ls.EXMA_PRODUCTIONPLAN_ID = p_productionplan_id
        ORDER BY ls.Line)
	
	LOOP

	v_ResultStr:='No Estimation cost updated in Live Stock';
	IF(Cur_livestock1.CALCCOST IS NOT NULL) THEN
	
	v_cost = Cur_livestock1.movementqty * Cur_livestock1.CALCCOST;
	
	SELECT * INTO  v_NextNo FROM Ad_Sequence_Next('M_Transaction', Cur_livestock1.AD_Org_ID) ;
	INSERT
	INTO M_TRANSACTION
            (
              M_Transaction_ID, AD_Client_ID, AD_Org_ID,
              IsActive, Created, CreatedBy, Updated,
              UpdatedBy, MovementType, M_Locator_ID, M_Product_ID,
              M_AttributeSetInstance_ID, MovementDate, MovementQty,
               C_UOM_ID, transactioncost, c_currency_id, iscostcalculated, isprocessed, costing_status
            )
            VALUES
            (
              v_NextNo, Cur_livestock1.AD_Client_ID, Cur_livestock1.AD_Org_ID,
              'Y', TO_DATE(NOW()), Cur_livestock1.createdby, TO_DATE(NOW()),
              Cur_livestock1.updatedby, 'P+', Cur_livestock1.M_Locator_ID, Cur_livestock1.M_Product_ID,
              '0', -- not distinguishing between assemby/disassembly
              Cur_livestock1.starttime,
	      Cur_livestock1.em_cwpf_closing_stock,
              Cur_livestock1.C_UOM_ID, v_cost, Cur_livestock1.c_currency_id, 'Y', 'Y', 'CC'
            );	

	v_count:=0;
	SELECT count(*) INTO v_count from cwct_livestock ls
	LEFT JOIN M_PRODUCT_ORG po on ls.M_Product_Id = po.M_Product_Id
	WHERE ls.EXMA_PRODUCTIONPLAN_ID = p_productionplan_id
	AND po.em_cwct_isstandard = 'N';

	v_ResultStr:= ' No Startdard Cost for Male Product';
	IF(v_count = 2) THEN
	 RAISE EXCEPTION '%',|| v_ResultStr;
	END IF;
	
	
		v_ResultStr := 'Costing Insertion';
		 IF(Cur_livestock1.em_cwct_isstandard = 'Y') THEN

			SELECT * INTO  v_NextNo FROM Ad_Sequence_Next('M_Costing', Cur_livestock1.AD_ORG_ID);
			INSERT INTO M_COSTING (M_COSTING_ID, CREATED, CREATEDBY, UPDATED, UPDATEDBY, AD_CLIENT_ID,
				    AD_ORG_ID, M_PRODUCT_ID, DATETO, DATEFROM, ISMANUAL,
				    QTY,
				    PRICE,  CUMQTY,
				    COST, ISPERMANENT, ISPRODUCTION, COSTTYPE)
			     VALUES (v_NextNo, TO_DATE(NOW()), Cur_livestock1.createdby, TO_DATE(NOW()),  Cur_livestock1.updatedby, 
				    Cur_livestock1.AD_Client_ID, Cur_livestock1.AD_Org_ID,  Cur_livestock1.M_PRODUCT_ID,
				    TO_DATE('31-12-9999','DD-MM-YYYY'),  Cur_livestock1.starttime, 'N', Cur_livestock1.em_cwpf_closing_stock,
				    COALESCE(Cur_livestock1.standardcost,0), Cur_livestock1.em_cwpf_closing_stock,
				    (CASE (Cur_livestock1.MOVEMENTQTY) WHEN 0 THEN 0 ELSE COALESCE(Cur_livestock1.standardcost,0) END),
				    'N', 'Y', 'STA');

		 ELSE 

			SELECT * INTO  v_NextNo FROM Ad_Sequence_Next('M_Costing', Cur_livestock1.AD_ORG_ID);
			INSERT INTO M_COSTING (M_COSTING_ID, CREATED, CREATEDBY, UPDATED, UPDATEDBY, AD_CLIENT_ID,
				    AD_ORG_ID, M_PRODUCT_ID, DATETO, DATEFROM, ISMANUAL,
				    QTY,
				    PRICE,  CUMQTY,
				    COST, ISPERMANENT, ISPRODUCTION, COSTTYPE)
			     VALUES (v_NextNo, TO_DATE(NOW()), Cur_livestock1.createdby, TO_DATE(NOW()),  Cur_livestock1.updatedby, 
				    Cur_livestock1.AD_Client_ID, Cur_livestock1.AD_Org_ID,  Cur_livestock1.M_PRODUCT_ID,
				    TO_DATE('31-12-9999','DD-MM-YYYY'),  Cur_livestock1.starttime, 'N', Cur_livestock1.em_cwpf_closing_stock,
				    ROUND(Cur_livestock1.CALCCOST,4), Cur_livestock1.cwpm_closing_stock,
				    (CASE (Cur_livestock1.MOVEMENTQTY) WHEN 0 THEN 0 ELSE ROUND(Cur_livestock1.CALCCOST,4) END),
				    'N', 'Y', 'AVA');

		 END IF;       
           

	ELSE 
	
	 RAISE EXCEPTION '%',|| v_ResultStr ;
	
	END IF;

	END LOOP;	*/
     
   

    --EXMA_Workeffort_Validate - Finish Process Extension Point
	SELECT count(*) INTO v_count
	FROM DUAL
	where exists (select 1 from ad_ep_procedures where ad_extension_points_id = 'FF80818132FDD74F0132FDEFDF200024');
	IF (v_count=1) THEN
	  DECLARE
	    v_ep_instance VARCHAR(32); --OBTG:VARCHAR2--
	    v_extension_point_id VARCHAR(32) := 'FF80818132FDD74F0132FDEFDF200024'; --OBTG:VARCHAR2--
	  BEGIN
	    v_ep_instance := get_uuid();
	    PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'Record_ID',
	      v_Record_ID, NULL, NULL, NULL, NULL, NULL, NULL);
	    PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'User',
	      v_User_ID, NULL, NULL, NULL, NULL, NULL, NULL);
	    PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'Message',
	      NULL, NULL, NULL, NULL, NULL, NULL, v_Message);
	    PERFORM AD_EP_INSTANCE_PARA_INSERT(v_ep_instance, v_extension_point_id, 'Result',
	    NULL, NULL, v_Result, NULL, NULL, NULL, NULL);
	    PERFORM AD_EXTENSION_POINT_HANDLER(v_ep_instance, v_extension_point_id);
	    SELECT p_number INTO v_Result
	    FROM ad_ep_instance_para
	    WHERE ad_ep_instance_id = v_ep_instance
	    AND parametername LIKE 'Result';	    
	    SELECT p_text INTO v_Message
	    FROM ad_ep_instance_para
	    WHERE ad_ep_instance_id = v_ep_instance
	    AND parametername LIKE 'Message';
		  
	    DELETE FROM ad_ep_instance_para
	    WHERE ad_ep_instance_id = v_ep_instance;
	  END;
	END IF;
    ---- <<FINISH_PROCESS>>
    --v_Message := v_Message || '@Created@: ' || v_NoRecords;
      --  Update AD_PInstance
      RAISE NOTICE '%','Updating PInstance - Finished' || v_Message ;
      PERFORM AD_UPDATE_PINSTANCE(p_PInstance_ID, NULL, 'N', v_Result, v_Message) ;
    RETURN;
  END; --BODY
 /* EXCEPTION
WHEN OTHERS THEN
  RAISE EXCEPTION '%','DATA_EXCEPTION' || v_ResultStr ;
  v_ResultStr:= 'cwpf_customworkeffort==@ERROR=' || SQLERRM;
  RAISE EXCEPTION '%','DATA_EXCEPTION' || v_ResultStr ;
  -- ROLLBACK;
  PERFORM AD_UPDATE_PINSTANCE(p_PInstance_ID, NULL, 'N', 0, v_ResultStr) ;
  RETURN;  */
END ; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION cwct_intgrtn_productionrun_we(character varying, character varying)
  OWNER TO tad;


-- Function: cwpm_age()

-- DROP FUNCTION cwpm_age();

CREATE OR REPLACE FUNCTION cwpm_age()
  RETURNS trigger AS
$BODY$ DECLARE 

v_production VARCHAR(32);
v_workrequirement VARCHAR(32);
v_doctype VARCHAR(32);
v_farm varchar(1);
v_integration varchar(1);
v_lg varchar(1);
v_flock varchar(32);
v_startdate TIMESTAMP;
v_age varchar(22);
v_batch VARCHAR(32);
v_pflock VARCHAR(32);
v_summary VARCHAR(1);
v_intstartdate TIMESTAMP;
v_planttype VARCHAR(60);


BEGIN

  select exma_workrequirement_id into v_workrequirement from exma_production where exma_production_id = NEW.exma_production_id;
  
  select c_doctype_id, em_cwpm_flock_no, em_exin_batchmaster, Startdate into v_doctype, v_flock, v_batch, v_intstartdate from exma_workrequirement where exma_workrequirement_id =  v_workrequirement;
	
 -- select em_cwlg_isfarm, em_cwlg_isintegration, EM_Cwlg_Islayergrower into v_farm,v_integration,v_lg  from c_doctype where c_doctype_id = v_doctype; 

--commented and dded by jhansi for layer commercial

  select em_cwlg_isfarm, em_cwlg_isintegration, EM_Cwlg_Islayergrower, EM_Cwpm_Planttype into v_farm,v_integration,v_lg,v_planttype  from c_doctype where c_doctype_id = v_doctype; 

--Ended

  select EM_Cwpf_Issummary,EM_Cwpf_Parent_Flock into v_summary, v_pflock from exsf_flockmaster where exsf_flockmaster_id = v_flock;

  

--IF(v_summary = 'Y') THEN

	--v_flock = v_flock;

--ELSE

	--v_flock = v_pflock;

--END IF;
 
 
IF TG_OP = 'INSERT' THEN



  IF v_farm = 'Y' THEN

    select start_date into v_startdate from cwpf_flock_age where exsf_flockmaster_id = v_flock;

    v_age = NEW.starttime::date - v_startdate::date;

    NEW.em_cwct_age_week = floor(to_number(v_age)/7 );

    NEW.EM_Cwpm_Agedays =  (floor(to_number(v_age)) % 7) ;


  END IF;

--Added by jhansi for layer commercial
IF (v_planttype is not null ) THEN
IF v_planttype = 'LC' THEN

    select start_date into v_startdate from cwpf_flock_age where exsf_flockmaster_id = v_flock;

    v_age = NEW.starttime::date - v_startdate::date;

    
    NEW.em_cwct_age_week = floor(to_number(v_age)/7 );

    NEW.EM_Cwpm_Agedays =  (floor(to_number(v_age)) % 7) ;


  END IF;

  END IF;


--Ended

  IF v_integration = 'Y' THEN

  
    --select start_date into v_startdate from exin_batchmaster where exin_batchmaster_id = v_batch;

    --select placement_date into v_startdate from exin_chk_plc where batch_num = v_flock;
    select start_date into v_startdate from cwpf_flock_age where exsf_flockmaster_id = v_flock;
    v_age = NEW.starttime::date - v_intstartdate::date;
    
    NEW.em_cwct_age_week = 0;
    NEW.EM_Cwpm_Agedays = to_number(v_age);

  END IF;
  
  IF v_lg = 'Y' THEN

    select start_date into v_startdate from cwpf_flock_age where exsf_flockmaster_id = v_flock;

    v_age = NEW.starttime::date - v_startdate::date;

    
    NEW.em_cwct_age_week = floor(to_number(v_age)/7 );

    NEW.EM_Cwpm_Agedays =  (floor(to_number(v_age)) % 7)  ;


  END IF;



 
END IF;

return NEW;
IF TG_OP = 'DELETE' THEN RETURN OLD; ELSE RETURN NEW; END IF; 

END 

; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION cwpm_age()
  OWNER TO tad;


-- Function: cwpm_shedage()

-- DROP FUNCTION cwpm_shedage();

CREATE OR REPLACE FUNCTION cwpm_shedage()
  RETURNS trigger AS
$BODY$ DECLARE 

v_ismale varchar(1);
v_entrydate TIMESTAMP;
v_startdate TIMESTAMP;
v_age varchar(20);
v_summary varchar(1);
v_flock varchar(32);


BEGIN

--select EM_Cwpf_Issummary,EM_Cwpf_Parent_Flock into v_summary, v_flock from exsf_flockmaster where exsf_flockmaster_id = NEW.exsf_flockmaster_id;
select EM_Cwpf_Issummary,exsf_flockmaster_id into v_summary, v_flock from exsf_flockmaster where exsf_flockmaster_id = NEW.exsf_flockmaster_id;

--IF(v_summary = 'Y') THEN

	--v_flock = NEW.exsf_flockmaster_id;

--END IF;




select start_date into v_startdate from cwpf_flock_age where exsf_flockmaster_id = v_flock;

IF NEW.entry_date IS NULL THEN

RAISE EXCEPTION 'Please enter entry date';


ELSE


IF v_startdate IS NULL THEN 

NEW.age = 0;
NEW.AGE_Days = 0;

ELSE


IF TG_OP = 'INSERT' THEN

v_entrydate = NEW.entry_date;

--RAISE to_number(v_test); 

v_age =  v_entrydate - v_startdate ;


--RAISE v_age ;


NEW.age = floor(to_number(v_age)/7 );
NEW.AGE_Days =  (floor(to_number(v_age)) % 7);



END IF; 
IF TG_OP ='UPDATE' THEN

v_entrydate = NEW.entry_date;

--RAISE to_number(v_test); 
v_age =  v_entrydate - v_startdate ;


--RAISE v_age ;


NEW.age = floor(to_number(v_age)/7 );
NEW.AGE_Days =  (floor(to_number(v_age)) % 7);



END IF;

END IF; 
END IF; 
return NEW;
IF TG_OP = 'DELETE' THEN RETURN OLD; ELSE RETURN NEW; END IF; 

END 

; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION cwpm_shedage()
  OWNER TO tad;



-- Function: cwpm_cls_shedage()

-- DROP FUNCTION cwpm_cls_shedage();

CREATE OR REPLACE FUNCTION cwpm_cls_shedage()
  RETURNS trigger AS
$BODY$ DECLARE 
v_ismale varchar(1);
v_entrydate TIMESTAMP;
v_startdate TIMESTAMP;
v_age varchar(20);
v_summary varchar(1);
v_flock varchar(32);

BEGIN



--select EM_Cwpf_Issummary,EM_Cwpf_Parent_Flock into v_summary, v_flock from exsf_flockmaster where exsf_flockmaster_id = NEW.flock_number;
select EM_Cwpf_Issummary,exsf_flockmaster_id into v_summary, v_flock from exsf_flockmaster where exsf_flockmaster_id = NEW.flock_number;

--IF(v_summary = 'Y') THEN

	--v_flock = new.flock_number;

--END IF;

select start_date into v_startdate from cwpf_flock_age where exsf_flockmaster_id = v_flock;

IF NEW.entry_date IS NULL THEN

RAISE EXCEPTION 'Please enter entry date';


ELSE


IF v_startdate IS NULL THEN 

NEW.age = 0;

ELSE


IF TG_OP = 'INSERT' THEN

v_entrydate = NEW.entry_date;

--RAISE to_number(v_test); 
v_age =  v_entrydate - v_startdate ;


--RAISE v_age ;


NEW.age = floor(to_number(v_age)/7);



END IF; 

END IF; 
END IF; 
return NEW;
IF TG_OP = 'DELETE' THEN RETURN OLD; ELSE RETURN NEW; END IF; 

END 

; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION cwpm_cls_shedage()
  OWNER TO tad;



-- Function: exin_shedage()

-- DROP FUNCTION exin_shedage();

CREATE OR REPLACE FUNCTION exin_shedage()
  RETURNS trigger AS
$BODY$ DECLARE 
v_ismale varchar(1);
v_entrydate TIMESTAMP;
v_startdate TIMESTAMP;
v_age varchar(20);
v_startdatemerging TIMESTAMP;
BEGIN


--select placement_date into v_startdate from exin_chk_plc where batch_num = NEW.batch_num;

 --added by jhansi

--select placement_date into v_startdatemerging from exin_chk_plc where Pbatch = NEW.batch_num;

--ended by jhansi

select start_date into v_startdate from cwpf_flock_age where exsf_flockmaster_id = NEW.batch_num;



IF NEW.entry_date IS NULL THEN

RAISE EXCEPTION 'Please enter entry date';


ELSE


--IF (v_startdate IS NULL and v_startdatemerging IS NULL) THEN --added by jhansi
IF (v_startdate IS NULL ) THEN

NEW.age = 0;

ELSE



IF TG_OP = 'INSERT' THEN

v_entrydate = NEW.entry_date;

--RAISE to_number(v_test); 
--v_age =  v_entrydate - v_startdate ; --commented by jhansi

--added by jhansi
IF(v_startdate IS NOT NULL) THEN
v_age = (v_entrydate - v_startdate);
--ELSE
--v_age = (v_entrydate - v_startdatemerging);
END IF;
--ended by jhansi


--RAISE v_age ;


NEW.age = to_number(v_age);



END IF; 




IF TG_OP = 'UPDATE' THEN


v_entrydate = NEW.entry_date;


--RAISE to_number(v_test); 
--v_age =  v_entrydate - v_startdate ; --commented by jhansi

--added by jhansi
IF(v_startdate IS NOT NULL) THEN
v_age = (v_entrydate - v_startdate);
--ELSE
--v_age = (v_entrydate - v_startdatemerging);
END IF;

--ended by jhansi

--RAISE v_age ;


NEW.age = to_number(v_age);



END IF; 



END IF; 
END IF; 
return NEW;
IF TG_OP = 'DELETE' THEN RETURN OLD; ELSE RETURN NEW; END IF; 

END 

; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION exin_shedage()
  OWNER TO tad;


-- Function: cwct_production_costcalcul(character varying, character varying)

-- DROP FUNCTION cwct_production_costcalcul(character varying, character varying);

CREATE OR REPLACE FUNCTION cwct_production_costcalcul(IN p_production_id character varying, IN p_user_id character varying, OUT v_message character varying)
  RETURNS character varying AS
$BODY$ DECLARE 
/*************************************************************************
* The contents of this file are subject to the Exceloid Soft systems Pvt.Ltd
* Version  1.0.0  
* for calculating the Production Cost 
* The Original Code is Exceloid Openbravo ERP.
* The Initial Developer of the Original Code is Malathi Vaka 04-03-2016.

************************************************************************/
  V_RESULTSTR				varchar(2000):='';
  v_count                               NUMERIC;
  v_count2                              NUMERIC;
  v_count3                              VARCHAR(32); 
  v_Client_ID  	                        VARCHAR(32); 
  v_Org_ID                              VARCHAR(32);  
  v_ProductionDate TIMESTAMP WITHOUT TIME ZONE;
  v_CostingDate                         TIMESTAMP;
  v_ProductionNo                        EXMA_Production.DocumentNo%TYPE;
  v_ProductionCost                      NUMERIC;
  v_ProductionTime                      NUMERIC;
  v_CompCostSum                         NUMERIC;
  v_CompCost                            NUMERIC;
  v_CostOld                             NUMERIC;
  v_Cost                                NUMERIC;
  v_Cost1			 NUMERIC;
  v_Qty                                 NUMERIC;
  v_ProducedUd_1		 NUMERIC;
  v_ProducedUd                          NUMERIC;
  v_ProducedKg                          NUMERIC;
  v_ProductionCost_Tmp                  NUMERIC;
  v_ProductionCost_Tmp1		 NUMERIC;
  RM_ESTIMATEDCOST		        NUMERIC;
  RM_ACTUALCOST			        NUMERIC;
  RM_PLANNEDCOST		 NUMERIC;
  v_NextNo                              VARCHAR(32); 
  v_Costing_ID                          VARCHAR(32);
  v_DateTo                              TIMESTAMP;
  v_productname				VARCHAR(60);
  v_productcatgry			VARCHAR(60);
  Cur_ProductionPlan 			RECORD;
  Cur_ProductionLine 			RECORD;
  Cur_RawMaterial 			RECORD;
  Cur_IndirectCost 			RECORD;
  Cur_IndirectCostPorc 			RECORD;
  Cur_CostConfiguration 		RECORD;
  Cur_WIP 				RECORD;
  v_ProductionCost1  		        NUMERIC;
  v_ProductionCost2  		        NUMERIC;
  v_workreq				VARCHAR(32);
  v_salescost 			        NUMERIC;
  v_margin_cost 		  NUMERIC;
  v_margin 			  NUMERIC;
  v_launchdate	TIMESTAMP WITHOUT TIME ZONE;
  v_pricelist 				VARCHAR(32);
  v_salesorder				VARCHAR(32);
  V_COSTSIMULATION 			CHAR(1);
  V_ISMANUALCOAT			CHAR(1);
  FINISH_PROCESS                        BOOLEAN := FALSE;
  V_PRODUCTIONPLAN_ID			VARCHAR(32);
  V_EXMA_CostCenter_ID			VARCHAR(32);
  V_INDIRECTACTUAL_COST 	 NUMERIC;
  V_INDIRECTESTIMATED_COST	 NUMERIC;
  V_MOVEMENTQTY  		 NUMERIC;
  V_PRODUCT_ID 				VARCHAR(32);
  V_ACTUALCOST			 NUMERIC;
  p_Processed				CHAR(1);
  V_ESTIMATEDCOST		 NUMERIC;
  Cur_IndirectCostManual		RECORD;
  v_manual  				CHAR(1);

v_pline_id varchar(32);
v_Client_ID1 varchar(32);
v_Org_ID1 varchar(32);
v_createdby varchar(32);
v_updatedby varchar(32);
v_product_id1 varchar(32);
v_uom_id varchar(32);
v_attributesetinstance_id varchar(32);
v_movementqty1 NUMERIC;
v_locator_id varchar(32);
v_reservation_stock_id varchar(32);
v_reservation_id varchar(32);
v_salesorderline_id varchar(32);
V_WORKREQUIREMENT_ID varchar(32);
v_McostingCount NUMERIC;
v_avgCost NUMERIC;
v_avgPosCost NUMERIC;
v_avgNegCost NUMERIC;
v_cumQty NUMERIC;
v_newCumQty NUMERIC;
v_oldQtyCost NUMERIC;
v_presentqtycost NUMERIC;
v_finalavgcost NUMERIC;
v_costcount NUMERIC:=0;

v_IsPackagingMateria CHAR(1);
  v_isstandard char(1);
    v_StandardCost NUMERIC;



  BEGIN
  BEGIN --BODY

    v_ResultStr:='Work Effort Validation';
    SELECT Processed  INTO p_Processed 
    FROM EXMA_PRODUCTION 
    WHERE EXMA_Production_ID=p_Production_ID;
    --Check if is has been already processed
    IF(p_Processed='Y') THEN
      v_ResultStr:='Work Effort is already validated';
      v_Message:='@WorkEffortValidated@';
      RAISE EXCEPTION '%', v_Message; --OBTG:-20000--
    END IF;


     
    
    v_ResultStr := 'Cost Simulation';
    v_count := 0;

    SELECT EM_CWPF_COST_SIMULATION,EXMA_PRODUCTIONPLAN_ID INTO V_COSTSIMULATION, V_PRODUCTIONPLAN_ID 
                                  FROM EXMA_PRODUCTIONPLAN 
				  LEFT JOIN EXMA_PRODUCTION ON EXMA_PRODUCTIONPLAN.EXMA_PRODUCTION_ID = EXMA_PRODUCTION.EXMA_PRODUCTION_ID
                                  WHERE EXMA_PRODUCTIONPLAN.EXMA_PRODUCTION_ID = p_Production_ID;

                                  
		    IF (v_count > 0) THEN
			      -- Costing engine migrated
			      SELECT MAX(pr.ad_client_id), MAX(pr.ad_org_id), MAX(pr.movementdate), MAX(trxprocessdate), COUNT (*), MAX(pr.DOCUMENTNO)
			      INTO v_Client_ID, v_Org_ID, v_ProductionDate, v_CostingDate, v_count, v_ProductionNo
			      FROM EXMA_PRODUCTION pr, EXMA_PRODUCTIONLINE pl
				LEFT JOIN M_TRANSACTION t ON t.EM_EXMA_productionline_id = pl.EXMA_productionline_id
				, EXMA_PRODUCTIONPLAN pp
			      WHERE pr.EXMA_production_id = p_Production_ID
				AND pr.EXMA_production_id = pp.EXMA_production_id
				AND pp.EXMA_productionplan_id = pl.EXMA_productionplan_id;
			      v_costingdate := COALESCE(v_costingdate, v_productiondate);
		    ELSE
			      -- Costing engine not migrated
			      SELECT MAX(pr.ad_client_id), MAX(pr.ad_org_id), MAX(movementdate), MAX(movementdate), COUNT (*), MAX(pr.DOCUMENTNO)
			      INTO v_Client_ID, v_Org_ID, v_ProductionDate, v_CostingDate, v_count, v_ProductionNo
			      FROM EXMA_PRODUCTION pr, EXMA_PRODUCTIONLINE pl, EXMA_PRODUCTIONPLAN pp
			      WHERE pr.EXMA_production_id = p_Production_ID
				AND pr.EXMA_production_id = pp.EXMA_production_id
				AND pp.EXMA_productionplan_id = pl.EXMA_productionplan_id
				AND pl.calculated = 'N';
		    END IF;


    V_COUNT := 0;
    
    IF (V_COSTSIMULATION = 'Y') THEN  --IFCSIMU

    SELECT COUNT(*) INTO V_COUNT FROM EXMA_PL_IC plic
		WHERE plic.EXMA_ProductionPlan_ID IN ( SELECT EXMA_PRODUCTIONPLAN_ID FROM EXMA_PRODUCTIONPLAN
		WHERE EXMA_PRODUCTION_ID =  p_Production_ID)
		AND plic.em_cwct_ismanualcost = 'Y';

    /*IF ( V_COUNT > 0) THEN

    			v_Message := 'CAN NOT DO COST SIMULATION AFTER INDIRECT COST MANUL UPDATION.';

			raise exception '%', v_Message;

			
   END IF;*/


    FOR Cur_ProductionPlan IN (SELECT pp.EXMA_ProductionPlan_ID, pp.exma_costcenter_version_id,
						                SUM(CASE pl.productiontype WHEN '+' THEN (mp.weight * pl.movementqty)
						                    ELSE 0 END) AS ProducedKG,
						                SUM(CASE pl.productiontype WHEN '+' THEN ROUND(pl.EM_Cwpm_Actualqty,3) 
						                    ELSE 0 END) AS ProducedUd,
						                SUM(CASE pl.productiontype WHEN '+' THEN ROUND(pl.movementqty,3) 
						                    ELSE 0 END) AS ProducedUd_1,
						            --     SUM(CASE pl.productiontype WHEN '+' THEN COALESCE(wrpp.ComponentCost,1) ELSE 0 END) AS CompCostSum,
						                 ccv.costuom, ccv.COST, pp.EXMA_CostCenterUse, pp.EXMA_WRPHASE_ID, pp.LINE
						          FROM EXMA_PRODUCTIONPLAN pp INNER JOIN EXMA_PRODUCTIONLINE pl ON pp.EXMA_productionplan_id = pl.EXMA_productionplan_id
						                                                                 AND pp.EXMA_production_id = p_Production_ID
						                                   INNER JOIN M_PRODUCT mp ON pl.m_product_id = mp.m_product_id
						                                   LEFT JOIN EXMA_COSTCENTER_VERSION ccv ON ccv.EXMA_COSTCENTER_VERSION_ID = pp.exma_costcenter_version_id
						                                   LEFT JOIN EXMA_WRPHASE wrp ON wrp.exma_wrphase_id = pp.exma_wrphase_id
						                                   LEFT JOIN EXMA_WRPHASEPRODUCT wrpp ON wrp.exma_wrphase_id = wrpp.exma_wrphase_id
						           AND wrpp.m_product_id = pl.m_product_id
						          WHERE NOT EXISTS (SELECT 1
						                           FROM EXMA_PRODUCTIONLINE pl1, EXMA_PRODUCTIONPLAN pp2, EXMA_PRODUCTIONLINE pl2
						                           WHERE pl1.EXMA_productionplan_id = pp2.EXMA_productionplan_id
						                             AND pl1.m_product_id = pl2.m_product_id
						                             AND pl2.productiontype='-'
						                             AND pl1.productiontype='+'
						                             AND pp2.EXMA_production_id = p_Production_ID
						                             AND pl2.EXMA_productionplan_ID = pp.EXMA_ProductionPlan_ID
						                             AND pl1.calculated = 'N')
						            AND pp.EXMA_COSTCENTER_VERSION_ID IS NOT NULL
						            AND pl.movementqty <> 0
						         GROUP BY pp.EXMA_ProductionPlan_ID, pp.exma_costcenter_version_id, ccv.costuom,
						                   ccv.COST, pp.EXMA_CostCenterUse, pp.EXMA_WRPHASE_ID, pp.LINE
						                   ) LOOP --L1
						                   
        v_ResultStr := 'Common variables';
        v_Productioncost := 0;
        v_ProducedKg := Cur_ProductionPlan.ProducedKG;
        v_ProducedUd := Cur_ProductionPlan.ProducedUd; ---sum of p+(Actual_produced) products
        v_ProducedUd_1 := Cur_ProductionPlan.ProducedUd_1; ---sum of p+(Planned_produced) products
        --Firstly calculate common costs of the production plan.
       -- v_ProductionTime := Cur_ProductionPlan.EXMA_CostCenterUse;
        --v_CompCostSum := Cur_ProductionPlan.CompCostSum;

			v_ResultStr := 'Raw Material cost';
			v_ProductionCost_Tmp := 0;
			v_ProductionCost_Tmp1 := 0; 
			RM_ACTUALCOST :=0 ;
			RM_PLANNEDCOST := 0;
			V_COUNT := 0;
			v_ProductionCost:= 0;
			v_ProductionCost1 := 0;

	FOR Cur_RawMaterial IN (
			select ROUND(PPL.EM_Cwpm_Actualqty,3) AS PLANNEDQTY,ROUND(ppl.MOVEMENTQTY,3)  as ACTUALQTY,p.name as name, ppl.EXMA_PRODUCTIONLINE_ID, ppl.M_PRODUCT_ID,  
			ppl.AD_ORG_ID
			from   EXMA_PRODUCTIONLINE ppl 
			LEFT JOIN M_Product p ON  ppl.M_PRODUCT_ID = P.M_PRODUCT_ID
			LEFT JOIN M_Product_Category PC ON P.M_Product_Category_ID = PC.M_Product_Category_ID
			WHERE ppl.PRODUCTIONTYPE = '-'
			AND ppl.EXMA_PRODUCTIONPLAN_ID = Cur_ProductionPlan.EXMA_PRODUCTIONPLAN_ID) LOOP --L2


			SELECT count(*) into v_count  FROM M_COSTING c 
			WHERE (c.COSTTYPE = (CASE WHEN (SELECT COUNT(1) FROM M_PRODUCT WHERE M_PRODUCT_ID = Cur_RawMaterial.M_PRODUCT_ID AND PRODUCTTYPE = 'I' 
			AND ISSTOCKED = 'Y') > 0 THEN 'AVA' END))
			AND C.M_PRODUCT_ID = Cur_RawMaterial.M_PRODUCT_ID 
			AND C.AD_ORG_ID = Cur_RawMaterial.AD_ORG_ID
			group by c.updated 
			order by c.updated desc limit 1;


			IF ( V_COUNT = 0 ) THEN

			select count(*) into v_costcount from m_transaction where iscostcalculated = 'N' and m_product_id = Cur_RawMaterial.M_PRODUCT_ID;
			--raise exception '% a', v_costcount;
			   IF(v_costcount > 0) THEN
				v_Message := 'NO COST DEFINED FOR RAW MATERIAL PRODUCT';
				raise exception '%', v_Message|| Cur_RawMaterial.pname ;
			    END IF;


			ELSE


			SELECT (c.COST * Cur_RawMaterial.PLANNEDQTY), (c.COST * Cur_RawMaterial.ACTUALQTY) INTO RM_PLANNEDCOST,
			 RM_ACTUALCOST  FROM M_COSTING c 
			WHERE (c.COSTTYPE = (CASE WHEN (SELECT COUNT(1) FROM M_PRODUCT 
			WHERE M_PRODUCT_ID = Cur_RawMaterial.M_PRODUCT_ID AND PRODUCTTYPE = 'I' 
			AND ISSTOCKED = 'Y') > 0 THEN 'AVA' END))
			AND C.M_PRODUCT_ID = Cur_RawMaterial.M_PRODUCT_ID 
			AND C.AD_ORG_ID = Cur_RawMaterial.AD_ORG_ID
			order by c.updated desc limit 1;

			--IF (RM_PLANNEDCOST = 0 OR RM_ACTUALCOST = 0 ) THEN 
			

		select COALESCE(sum(MovementQty),0) into v_cumQty from m_transaction where m_product_id = Cur_RawMaterial.m_product_id 
		and ad_org_id = Cur_RawMaterial.ad_org_id and iscostcalculated = 'Y';


		select COALESCE(sum(Cost),0) into v_avgPosCost from m_transaction_cost where m_transaction_id 
		in(select m_transaction_id from m_transaction
		where m_transaction.m_product_id = Cur_RawMaterial.m_product_id 
		and ad_org_id = Cur_RawMaterial.ad_org_id and iscostcalculated = 'Y' and MovementQty > 0);

		
		select COALESCE(sum(Cost),0) into v_avgNegCost from m_transaction_cost where m_transaction_id 
		in(select m_transaction_id from m_transaction
		where m_transaction.m_product_id = Cur_RawMaterial.m_product_id 
		and ad_org_id = Cur_RawMaterial.ad_org_id and iscostcalculated = 'Y' and MovementQty < 0);


		--raise exception '%, % ', v_avgCost, v_cumQty;
		RM_ACTUALCOST = COALESCE(v_avgPosCost,0) - COALESCE(v_avgNegCost,0);
		RM_ACTUALCOST = COALESCE(RM_ACTUALCOST/v_cumQty,0);

		RM_PLANNEDCOST = COALESCE(Cur_RawMaterial.PLANNEDQTY,0) * COALESCE(RM_ACTUALCOST,0);

		RM_ACTUALCOST = COALESCE(Cur_RawMaterial.ACTUALQTY,0) * COALESCE(RM_ACTUALCOST,0);

		--raise exception '%, % ', v_avgCost, v_cumQty;
		IF (RM_ACTUALCOST = 0 ) THEN
			
			select count(*) into v_costcount from m_transaction where iscostcalculated = 'N' and m_product_id = Cur_RawMaterial.M_PRODUCT_ID;
			--raise exception '% b', v_costcount;

			   IF(v_costcount > 0) THEN
				v_Message := 'NO COST DEFINED FOR RAW MATERIAL PRODUCT';
				raise exception '%', v_Message|| Cur_RawMaterial.pname ;
			    END IF;

			ELSE

				
				  v_ProductionCost_Tmp := v_ProductionCost_Tmp + COALESCE(round(RM_ACTUALCOST,2),0);
				  v_ProductionCost_Tmp1 := v_ProductionCost_Tmp1 + COALESCE(round(RM_PLANNEDCOST,2),0);
	  PERFORM CWPM_LOG_INSERTION(v_Client_ID, v_Org_ID,V_PRODUCTIONPLAN_ID,'RM_PLANNEDCOST',RM_PLANNEDCOST ,'description','cwct_production_costcalcul');
	  PERFORM CWPM_LOG_INSERTION(v_Client_ID, v_Org_ID,V_PRODUCTIONPLAN_ID,'RM_ACTUALCOST',RM_ACTUALCOST ,'description','cwct_production_costcalcul');

				  UPDATE EXMA_PRODUCTIONLINE
				  SET calccost = COALESCE(round(RM_PLANNEDCOST,2), 0), EM_Cwct_Actualcost = COALESCE(round(RM_ACTUALCOST,2), 0), EM_Cwpf_Cost_Uom = 'TC'
				  WHERE EXMA_PRODUCTIONLINE_ID = Cur_RawMaterial.EXMA_PRODUCTIONLINE_ID;

			END IF;
 
			END IF;  

			
	END LOOP; --L2


	v_ProductionCost := v_ProductionCost + COALESCE(v_ProductionCost_Tmp,0);  --sum of all p-(ACTUAL_COST)
	v_ProductionCost1 := v_ProductionCost1 + COALESCE(v_ProductionCost_Tmp1,0);  --sum of all p-(ESTIMATED_COST)

 
			----Indirect Cost Calculation based on CostConfiguration
			v_ResultStr := 'INDIRECT COST';
			SELECT EM_CWPF_EXMA_CostCenter_ID INTO V_EXMA_CostCenter_ID FROM EXMA_WorkRequirement
			LEFT JOIN EXMA_Production ON EXMA_WorkRequirement.EXMA_WorkRequirement_ID = EXMA_Production.EXMA_WorkRequirement_ID 
			LEFT JOIN EXMA_ProductionPlan ON EXMA_Production.EXMA_Production_ID = EXMA_ProductionPlan.EXMA_Production_ID
			WHERE EXMA_ProductionPlan.EXMA_Production_ID = p_Production_ID; --'A1F07E35D07C4886944AE97D7C499815'


			v_ProductionCost_Tmp := 0; 
			v_ProductionCost_Tmp1 := 0;
			V_MOVEMENTQTY := 0;
			V_ESTIMATEDCOST := 0;
			V_COUNT := 0;


			SELECT COUNT(*) INTO V_COUNT
						      FROM CWCT_COSTCONFIG
						      LEFT JOIN EXMA_Indirect_Cost_Value ON  CWCT_COSTCONFIG.EXMA_Indirect_Cost_ID = EXMA_Indirect_Cost_Value.EXMA_Indirect_Cost_ID 
						      WHERE CWCT_COSTCONFIG.EXMA_CostCenter_ID = V_EXMA_CostCenter_ID -- '331F8123439645A7B8D5A948D7E85DEC' --
						      AND EXMA_Indirect_Cost_Value.DATEFROM < TO_DATE(v_ProductionDate)
						      AND EXMA_Indirect_Cost_Value.DATETO > TO_DATE(v_ProductionDate);

			IF ( V_COUNT <> 0) THEN  --COUNT
			
			FOR Cur_CostConfiguration IN (SELECT CWCT_COSTCONFIG.EXMA_Indirect_Cost_ID,plannedqty, exempted, M_Product_Category_ID,  
						      EXMA_Indirect_Cost_Value.COST, EXMA_Indirect_Cost_Value.Cost_Uom  
						      FROM CWCT_COSTCONFIG
						      LEFT JOIN EXMA_Indirect_Cost_Value ON  CWCT_COSTCONFIG.EXMA_Indirect_Cost_ID = EXMA_Indirect_Cost_Value.EXMA_Indirect_Cost_ID 
						      WHERE CWCT_COSTCONFIG.EXMA_CostCenter_ID = V_EXMA_CostCenter_ID -- '331F8123439645A7B8D5A948D7E85DEC' --
						      AND EXMA_Indirect_Cost_Value.DATEFROM < TO_DATE(v_ProductionDate)
						      AND EXMA_Indirect_Cost_Value.DATETO > TO_DATE(v_ProductionDate)
						      ) LOOP  --Indirect --L3

			
			IF (Cur_CostConfiguration.plannedqty = 'Y') THEN  -------plannedqty 'Y' 
	 	  PERFORM CWPM_LOG_INSERTION(v_Client_ID, v_Org_ID,V_PRODUCTIONPLAN_ID,'coalesce(ROUND(Cur_CostConfiguration.COST * v_ProducedUd_1,2),0)',coalesce(ROUND(Cur_CostConfiguration.COST * v_ProducedUd_1,2),0) ,'description','cwct_production_costcalcul');
	 	  PERFORM CWPM_LOG_INSERTION(v_Client_ID, v_Org_ID,V_PRODUCTIONPLAN_ID,'coalesce(ROUND(Cur_CostConfiguration.COST * v_ProducedUd,2),0)',coalesce(ROUND(Cur_CostConfiguration.COST * v_ProducedUd,2),0),'description','cwct_production_costcalcul');

				UPDATE EXMA_PL_IC
				SET CALCCOST = coalesce(ROUND(Cur_CostConfiguration.COST * v_ProducedUd_1,2),0), 
				    em_cwct_actualcost = coalesce(ROUND(Cur_CostConfiguration.COST * v_ProducedUd,2),0)
				WHERE EXMA_Indirect_Cost_ID = Cur_CostConfiguration.EXMA_Indirect_Cost_ID
				and EXMA_PRODUCTIONPLAN_ID = Cur_ProductionPlan.EXMA_PRODUCTIONPLAN_ID;



				ELSE
					IF ( Cur_CostConfiguration.exempted = 'N' ) THEN   ----exempted 'N'

					        select ROUND(sum(ppl.EM_Cwpm_Actualqty),3), ROUND(sum(ppl.MOVEMENTQTY),3) 
						INTO V_ESTIMATEDCOST, V_MOVEMENTQTY 
						from   EXMA_PRODUCTIONLINE ppl 
						LEFT JOIN M_Product p ON  ppl.M_PRODUCT_ID = P.M_PRODUCT_ID
						WHERE ppl.PRODUCTIONTYPE = '-'
						AND ppl.EXMA_PRODUCTIONPLAN_ID = Cur_ProductionPlan.EXMA_PRODUCTIONPLAN_ID
						AND P.M_Product_Category_ID = Cur_CostConfiguration.M_Product_Category_ID; --) LOOP --L4
						--RAISE Cur_CostConfiguration.COST;
	
					 v_ProductionCost_Tmp := v_ProductionCost_Tmp + COALESCE(V_MOVEMENTQTY,0);
					 v_ProductionCost_Tmp1 := v_ProductionCost_Tmp1 + COALESCE(V_ESTIMATEDCOST,0);

  PERFORM CWPM_LOG_INSERTION(v_Client_ID, v_Org_ID,V_PRODUCTIONPLAN_ID,'coalesce(ROUND(Cur_CostConfiguration.COST * v_ProductionCost_Tmp1,2),0)',coalesce(ROUND(Cur_CostConfiguration.COST * v_ProductionCost_Tmp1,2),0) ,'description','cwct_production_costcalcul');
  PERFORM CWPM_LOG_INSERTION(v_Client_ID, v_Org_ID,V_PRODUCTIONPLAN_ID,'coalesce(ROUND(Cur_CostConfiguration.COST * v_ProductionCost_Tmp,2),0)',coalesce(ROUND(Cur_CostConfiguration.COST * v_ProductionCost_Tmp,2),0) ,'description','cwct_production_costcalcul');
		 
					UPDATE EXMA_PL_IC
					SET CALCCOST = coalesce(ROUND(Cur_CostConfiguration.COST * v_ProductionCost_Tmp1,2),0), 
					    em_cwct_actualcost = coalesce(ROUND(Cur_CostConfiguration.COST * v_ProductionCost_Tmp,2),0)
					WHERE EXMA_Indirect_Cost_ID = Cur_CostConfiguration.EXMA_Indirect_Cost_ID
					and EXMA_PRODUCTIONPLAN_ID = Cur_ProductionPlan.EXMA_PRODUCTIONPLAN_ID;

					END IF; ----exempted 'N'

			END IF;-------plannedqty 'Y'

  		END LOOP;  --Indirect --L3

  		ELSE  --COUNT

  		v_Message:= 'COST IS NOT CONFIGURED IN COST CONFIGURATION WINDOW';

		RAISE EXCEPTION '%',v_Message;

		END IF; --COUNT


 	----COST CALCULATION OF P+(PRODUCED) PRODUCT


	v_ProductionCost_Tmp := 0;
	v_Cost:= 0;
	v_Cost1 := 0;				
	V_COUNT := 0;
        V_INDIRECTESTIMATED_COST := 0;
        V_INDIRECTACTUAL_COST := 0;


        
        FOR Cur_ProductionLine IN (SELECT pl.*, p.VALUE, COUNT(*) AS V_COUNT
                                   FROM EXMA_PRODUCTIONLINE pl, M_PRODUCT p
                                   WHERE EXMA_ProductionPlan_ID = Cur_ProductionPlan.EXMA_ProductionPlan_ID
                                     AND pl.M_Product_ID = p.M_Product_ID
                                     AND pl.CALCULATED = 'N'
                                     AND productiontype = '+'
                                     AND pl.MOVEMENTQTY <> 0
                                     group by pl.exma_productionline_id, p.VALUE
                                    ) LOOP  --L4

                                    
					IF (Cur_ProductionLine.V_COUNT = 0 ) THEN  --C1

					v_Message := 'P+ PRODUCT NOT CONFIGURED IN PROCESS PLAN';

					RAISE EXCEPTION '%',v_Message;

					ELSE
					SELECT coalesce(SUM(CALCCOST),0), coalesce(SUM(em_cwct_actualcost),0) INTO V_INDIRECTESTIMATED_COST, V_INDIRECTACTUAL_COST FROM EXMA_PL_IC
					WHERE EXMA_PRODUCTIONPLAN_ID = Cur_ProductionPlan.EXMA_PRODUCTIONPLAN_ID;

					v_Cost:= v_Cost + COALESCE(v_ProductionCost,0)  --RAW MATERIAL ACTUAL_COST
							  +COALESCE(V_INDIRECTACTUAL_COST,0) ; -- Indirect COST
							  
					v_Cost1:= v_Cost1 + COALESCE(v_ProductionCost1,0)  --RAW MATERIAL ESTIMATED_COST
							  +COALESCE(V_INDIRECTESTIMATED_COST,0) ; -- Indirect COST
  PERFORM CWPM_LOG_INSERTION(v_Client_ID, v_Org_ID,V_PRODUCTIONPLAN_ID,'v_Cost1',v_Cost1 ,'description','cwct_production_costcalcul');
  PERFORM CWPM_LOG_INSERTION(v_Client_ID, v_Org_ID,V_PRODUCTIONPLAN_ID,'v_Cost',v_Cost ,'description','cwct_production_costcalcul');

					    UPDATE EXMA_PRODUCTIONLINE
					    SET CALCCOST = ROUND(v_Cost1,2),  --ROUND(v_Cost1/Cur_ProductionLine.EM_Cwpm_Actualqty,3), 
					    EM_CWCT_ACTUALCOST= ROUND(v_Cost,2), ---ROUND(v_Cost/Cur_ProductionLine.MOVEMENTQTY,3), 
					    EM_Cwpf_Cost_Uom = 'TC' 
					    WHERE EXMA_PRODUCTIONLINE_ID = Cur_ProductionLine.EXMA_ProductionLine_ID;

				END IF; --C1
				END LOOP; --L4		 

	END LOOP; --L1

	v_Message := 'Simulation Processed Successfully.';

	RAISE NOTICE '%',v_Message;

    UPDATE EXMA_PRODUCTIONPLAN SET EM_CWPF_COST_SIMULATION = 'N'   
    WHERE EXMA_PRODUCTIONPLAN_ID  = V_PRODUCTIONPLAN_ID;

   

    ELSE   ---WITHOUT CSIMULATION 

    /*FOR Cur_IndirectCostManual IN (SELECT plic.em_cwct_ismanualcost  as v_ismanualcost FROM EXMA_PL_IC plic
		WHERE plic.EXMA_ProductionPlan_ID = V_PRODUCTIONPLAN_ID)		
	LOOP
		
		IF(Cur_IndirectCostManual.v_ismanualcost = 'Y') THEN
			v_manual := 'Y';
		END IF;
	END LOOP;


    IF (v_manual = 'Y') THEN  -- IS MANUAL ='Y'
    v_ResultStr := 'Update productionline calculated';
    UPDATE EXMA_PRODUCTIONLINE
    SET CALCULATED='Y'
    WHERE EXMA_PRODUCTIONPLAN_ID IN (SELECT EXMA_PRODUCTIONPLAN_ID
                                  FROM EXMA_PRODUCTIONPLAN
                                  WHERE EXMA_PRODUCTION_ID = p_Production_ID)
      AND MOVEMENTQTY = 0
      AND PRODUCTIONTYPE = '+';

    UPDATE EXMA_PRODUCTIONLINE
    SET CALCULATED='Y'
    WHERE EXMA_PRODUCTIONPLAN_ID IN (SELECT EXMA_PRODUCTIONPLAN_ID
                                  FROM EXMA_PRODUCTIONPLAN
                                  WHERE EXMA_PRODUCTION_ID = p_Production_ID
                                    AND EXMA_COSTCENTER_VERSION_ID IS NULL);

    UPDATE EXMA_PRODUCTIONLINE
    SET CALCULATED='Y'
    WHERE PRODUCTIONTYPE = '-'
      AND EXMA_PRODUCTIONPLAN_ID IN (SELECT EXMA_PRODUCTIONPLAN_ID
                                  FROM EXMA_PRODUCTIONPLAN
                                  WHERE EXMA_PRODUCTION_ID = p_Production_ID)
      AND NOT EXISTS (SELECT 1 FROM EXMA_PRODUCTIONLINE pl, EXMA_PRODUCTIONPLAN pp
                      WHERE pl.EXMA_PRODUCTIONPLAN_ID = pp.EXMA_PRODUCTIONPLAN_ID
                        AND pp.EXMA_PRODUCTION_ID = p_Production_ID
                        AND pl.PRODUCTIONTYPE = '+'
                        AND pl.CALCULATED = 'N'
                        AND pl.M_PRODUCT_ID = EXMA_PRODUCTIONLINE.M_PRODUCT_ID);


		v_count := 0; 

                        		    IF (v_count > 0) THEN
			      -- Costing engine migrated
			      SELECT MAX(pr.ad_client_id), MAX(pr.ad_org_id), MAX(pr.movementdate), MAX(trxprocessdate), COUNT (*), MAX(pr.DOCUMENTNO)
			      INTO v_Client_ID, v_Org_ID, v_ProductionDate, v_CostingDate, v_count, v_ProductionNo
			      FROM EXMA_PRODUCTION pr, EXMA_PRODUCTIONLINE pl
				LEFT JOIN M_TRANSACTION t ON t.EM_EXMA_productionline_id = pl.EXMA_productionline_id
				, EXMA_PRODUCTIONPLAN pp
			      WHERE pr.EXMA_production_id = p_Production_ID
				AND pr.EXMA_production_id = pp.EXMA_production_id
				AND pp.EXMA_productionplan_id = pl.EXMA_productionplan_id;
			      v_costingdate := COALESCE(v_costingdate, v_productiondate);
		    ELSE
			      -- Costing engine not migrated
			      SELECT MAX(pr.ad_client_id), MAX(pr.ad_org_id), MAX(movementdate), MAX(movementdate), COUNT (*), MAX(pr.DOCUMENTNO)
			      INTO v_Client_ID, v_Org_ID, v_ProductionDate, v_CostingDate, v_count, v_ProductionNo
			      FROM EXMA_PRODUCTION pr, EXMA_PRODUCTIONLINE pl, EXMA_PRODUCTIONPLAN pp
			      WHERE pr.EXMA_production_id = p_Production_ID
				AND pr.EXMA_production_id = pp.EXMA_production_id
				AND pp.EXMA_productionplan_id = pl.EXMA_productionplan_id
				AND pl.calculated = 'N';
		    END IF;

    FOR Cur_ProductionPlan IN (SELECT pp.EXMA_ProductionPlan_ID, pp.exma_costcenter_version_id,
						                SUM(CASE pl.productiontype WHEN '+' THEN (mp.weight * pl.movementqty)
						                    ELSE 0 END) AS ProducedKG,
						                SUM(CASE pl.productiontype WHEN '+' THEN ROUND(pl.EM_Cwpm_Actualqty,3) --pl.movementqty
						                    ELSE 0 END) AS ProducedUd,
						                SUM(CASE pl.productiontype WHEN '+' THEN ROUND(pl.movementqty,3) 
						                    ELSE 0 END) AS ProducedUd_1,
						            --     SUM(CASE pl.productiontype WHEN '+' THEN COALESCE(wrpp.ComponentCost,1) ELSE 0 END) AS CompCostSum,
						                 ccv.costuom, ccv.COST, pp.EXMA_CostCenterUse, pp.EXMA_WRPHASE_ID, pp.LINE
						          FROM EXMA_PRODUCTIONPLAN pp INNER JOIN EXMA_PRODUCTIONLINE pl ON pp.EXMA_productionplan_id = pl.EXMA_productionplan_id
						                                                                 AND pp.EXMA_production_id = p_Production_ID
						                                   INNER JOIN M_PRODUCT mp ON pl.m_product_id = mp.m_product_id
						                                   LEFT JOIN EXMA_COSTCENTER_VERSION ccv ON ccv.EXMA_COSTCENTER_VERSION_ID = pp.exma_costcenter_version_id
						                                   LEFT JOIN EXMA_WRPHASE wrp ON wrp.exma_wrphase_id = pp.exma_wrphase_id
						                                   LEFT JOIN EXMA_WRPHASEPRODUCT wrpp ON wrp.exma_wrphase_id = wrpp.exma_wrphase_id
						           AND wrpp.m_product_id = pl.m_product_id
						          WHERE NOT EXISTS (SELECT 1
						                           FROM EXMA_PRODUCTIONLINE pl1, EXMA_PRODUCTIONPLAN pp2, EXMA_PRODUCTIONLINE pl2
						                           WHERE pl1.EXMA_productionplan_id = pp2.EXMA_productionplan_id
						                             AND pl1.m_product_id = pl2.m_product_id
						                             AND pl2.productiontype='-'
						                             AND pl1.productiontype='+'
						                             AND pp2.EXMA_production_id = p_Production_ID
						                             AND pl2.EXMA_productionplan_ID = pp.EXMA_ProductionPlan_ID
						                             AND pl1.calculated = 'N')
						            AND pp.EXMA_COSTCENTER_VERSION_ID IS NOT NULL
						            AND pl.movementqty <> 0
						         GROUP BY pp.EXMA_ProductionPlan_ID, pp.exma_costcenter_version_id, ccv.costuom,
						                   ccv.COST, pp.EXMA_CostCenterUse, pp.EXMA_WRPHASE_ID, pp.LINE
						                   ) LOOP --LL1
						                   
        v_ResultStr := 'Common variables';
        v_Productioncost := 0;
        v_ProducedKg := Cur_ProductionPlan.ProducedKG;
        v_ProducedUd := Cur_ProductionPlan.ProducedUd; ---sum of p+(Actual_produced) products
        v_ProducedUd_1 := Cur_ProductionPlan.ProducedUd_1; ---sum of p+(Planned_produced) products
        --Firstly calculate common costs of the production plan.
       -- v_ProductionTime := Cur_ProductionPlan.EXMA_CostCenterUse;
        --v_CompCostSum := Cur_ProductionPlan.CompCostSum;


			v_ResultStr := 'Raw Material cost';
			v_ProductionCost_Tmp := 0; 
			v_ProductionCost_Tmp1 := 0; 
			RM_ACTUALCOST :=0 ;
			RM_PLANNEDCOST := 0;
			V_COUNT := 0;
			v_ProductionCost:= 0;
			v_ProductionCost1 := 0;


	FOR Cur_RawMaterial IN (
			select ROUND(PPL.EM_Cwpm_Actualqty,3) AS PLANNEDQTY, ROUND(ppl.MOVEMENTQTY,3)  as ACTUALQTY, ppl.EXMA_PRODUCTIONLINE_ID, ppl.M_PRODUCT_ID,  
			ppl.AD_ORG_ID
			from   EXMA_PRODUCTIONLINE ppl 
			WHERE ppl.PRODUCTIONTYPE = '-'
			AND ppl.EXMA_PRODUCTIONPLAN_ID = Cur_ProductionPlan.EXMA_PRODUCTIONPLAN_ID) LOOP --L2


			SELECT count(*) into v_count  FROM M_COSTING c 
			WHERE (c.COSTTYPE = (CASE WHEN (SELECT COUNT(1) FROM M_PRODUCT WHERE M_PRODUCT_ID = Cur_RawMaterial.M_PRODUCT_ID AND PRODUCTTYPE = 'I' 
			AND ISSTOCKED = 'Y') > 0 THEN 'AVA' END))
			AND C.M_PRODUCT_ID = Cur_RawMaterial.M_PRODUCT_ID 
			AND C.AD_ORG_ID = Cur_RawMaterial.AD_ORG_ID
			group by c.updated 
			order by c.updated desc limit 1;


			IF ( V_COUNT = 0 ) THEN

			v_Message := 'NO COST DEFINED FOR RAW MATERIAL PRODUCT';

			raise exception '%', v_Message;


			ELSE


			SELECT (c.COST * Cur_RawMaterial.PLANNEDQTY), (c.COST * Cur_RawMaterial.ACTUALQTY) INTO RM_PLANNEDCOST, RM_ACTUALCOST  FROM M_COSTING c 
			WHERE (c.COSTTYPE = (CASE WHEN (SELECT COUNT(1) FROM M_PRODUCT WHERE M_PRODUCT_ID = Cur_RawMaterial.M_PRODUCT_ID AND PRODUCTTYPE = 'I' 
			AND ISSTOCKED = 'Y') > 0 THEN 'AVA' END))
			AND C.M_PRODUCT_ID = Cur_RawMaterial.M_PRODUCT_ID 
			AND C.AD_ORG_ID = Cur_RawMaterial.AD_ORG_ID
			order by c.updated desc limit 1;

			IF (RM_PLANNEDCOST = 0 OR RM_ACTUALCOST = 0 ) THEN 

			v_Message := 'Zero COST DEFINED FOR RAW MATERIAL PRODUCT';

			raise exception '%', v_Message;

			ELSE

				
				  v_ProductionCost_Tmp := v_ProductionCost_Tmp + COALESCE(round(RM_ACTUALCOST,2),0);
				  v_ProductionCost_Tmp1 := v_ProductionCost_Tmp1 + COALESCE(round(RM_PLANNEDCOST,2),0);

				  UPDATE EXMA_PRODUCTIONLINE
				  SET calccost = COALESCE(round(RM_PLANNEDCOST,2), 0), EM_Cwct_Actualcost = COALESCE(round(RM_ACTUALCOST,2), 0), EM_Cwpf_Cost_Uom = 'TC'
				  WHERE EXMA_PRODUCTIONLINE_ID = Cur_RawMaterial.EXMA_PRODUCTIONLINE_ID;

			END IF;
 
			END IF;  

			
	END LOOP; --L2



	v_ProductionCost := v_ProductionCost + COALESCE(v_ProductionCost_Tmp,0);  --sum of all p-(ACTUAL_COST)
	v_ProductionCost1 := v_ProductionCost1 + COALESCE(v_ProductionCost_Tmp1,0);  --sum of all p-(ESTIMATED_COST)

	


----COST CALCULATION OF P+(PRODUCED) PRODUCT


	v_ProductionCost_Tmp := 0;
	v_Cost:= 0;
	v_Cost1:= 0;					
	V_COUNT := 0;
        FOR Cur_ProductionLine IN (SELECT pl.*, p.VALUE, count(*)  AS V_COUNT
                                   FROM EXMA_PRODUCTIONLINE pl, M_PRODUCT p
                                   WHERE EXMA_ProductionPlan_ID = Cur_ProductionPlan.EXMA_ProductionPlan_ID
                                     AND pl.M_Product_ID = p.M_Product_ID
                                     AND pl.CALCULATED = 'N'
                                     AND productiontype = '+'
                                     AND pl.MOVEMENTQTY <> 0
                                     group by pl.exma_productionline_id, p.VALUE
                                    ) LOOP  --LL4


					IF (Cur_ProductionLine.V_COUNT = 0 ) THEN  --C1

					v_Message := 'P+ PRODUCT NOT CONFIGURED IN PROCESS PLAN';

					RAISE EXCEPTION '%',v_Message;

					ELSE 

					SELECT coalesce(SUM(CALCCOST),0), coalesce(SUM(em_cwct_actualcost),0) INTO V_INDIRECTESTIMATED_COST, V_INDIRECTACTUAL_COST FROM EXMA_PL_IC
					WHERE EXMA_PRODUCTIONPLAN_ID = Cur_ProductionPlan.EXMA_PRODUCTIONPLAN_ID;

					v_Cost:= v_Cost + COALESCE(v_ProductionCost,0)  --RAW MATERIAL ACTUAL_COST
							  +COALESCE(V_INDIRECTACTUAL_COST,0) ; -- Indirect COST
							  
					v_Cost1:= v_Cost1 + COALESCE(v_ProductionCost,0)  --RAW MATERIAL ESTIMATED_COST
							  +COALESCE(V_INDIRECTESTIMATED_COST,0) ; -- Indirect COST


					    UPDATE EXMA_PRODUCTIONLINE
					    SET CALCCOST = ROUND(v_Cost1/(ROUND(Cur_ProductionLine.EM_Cwpm_Actualqty,3)),2), 
					    EM_CWCT_ACTUALCOST= ROUND(v_Cost/ROUND(Cur_ProductionLine.MOVEMENTQTY,3),2), EM_Cwpf_Cost_Uom = 'UC' 
					    WHERE EXMA_PRODUCTIONLINE_ID = Cur_ProductionLine.EXMA_ProductionLine_ID;

		SELECT * INTO  v_NextNo FROM Ad_Sequence_Next('M_Costing', Cur_ProductionLine.AD_ORG_ID);

		v_ResultStr := 'insert cost';


  INSERT INTO M_COSTING (M_COSTING_ID, CREATED, CREATEDBY, UPDATED, UPDATEDBY, AD_CLIENT_ID,
				            AD_ORG_ID, M_PRODUCT_ID, DATETO, DATEFROM, ISMANUAL,
				            EM_EXMA_PRODUCTIONLINE_ID, QTY,
				            PRICE,  CUMQTY,
				            COST, ISPERMANENT, ISPRODUCTION, COSTTYPE)
				     VALUES (v_NextNo,TO_DATE(NOW()), p_User_ID, TO_DATE(NOW()), p_User_ID, Cur_ProductionLine.AD_CLIENT_ID,
				            Cur_ProductionLine.AD_ORG_ID, Cur_ProductionLine.M_PRODUCT_ID, TO_DATE('31-12-9999','DD-MM-YYYY'), v_CostingDate, 'N',
				            Cur_ProductionLine.EXMA_PRODUCTIONLINE_ID, ROUND(Cur_ProductionLine.MOVEMENTQTY,3),
				            ROUND(v_Cost/(ROUND(Cur_ProductionLine.MOVEMENTQTY,3)),2), COALESCE(v_Qty,0) + ROUND(Cur_ProductionLine.MOVEMENTQTY,3),
				            (CASE ROUND(Cur_ProductionLine.MOVEMENTQTY,3) WHEN 0 THEN 0 ELSE ROUND(v_Cost/(ROUND(Cur_ProductionLine.MOVEMENTQTY,3)),2) END), 'N', 'Y', 'AVA');

		v_salescost := ROUND(v_Cost/Cur_ProductionLine.MOVEMENTQTY,2);

		END IF; --C1
        END LOOP; --LL4

      END LOOP; --LL1
 

  ELSE -----ISMANUL ='N' AND VALIDATE WE WITHOUT SIMULATION */




   /*  v_ResultStr := 'Update productionline calculated';

    UPDATE EXMA_PRODUCTIONLINE
    SET CALCULATED='Y'
    WHERE EXMA_PRODUCTIONPLAN_ID IN (SELECT EXMA_PRODUCTIONPLAN_ID
                                  FROM EXMA_PRODUCTIONPLAN
                                  WHERE EXMA_PRODUCTION_ID = p_Production_ID)
      AND MOVEMENTQTY = 0
      AND PRODUCTIONTYPE = '+';

    UPDATE EXMA_PRODUCTIONLINE
    SET CALCULATED='Y'
    WHERE EXMA_PRODUCTIONPLAN_ID IN (SELECT EXMA_PRODUCTIONPLAN_ID
                                  FROM EXMA_PRODUCTIONPLAN
                                  WHERE EXMA_PRODUCTION_ID = p_Production_ID
                                    AND EXMA_COSTCENTER_VERSION_ID IS NULL);

    UPDATE EXMA_PRODUCTIONLINE
    SET CALCULATED='Y'
    WHERE PRODUCTIONTYPE = '-'
      AND EXMA_PRODUCTIONPLAN_ID IN (SELECT EXMA_PRODUCTIONPLAN_ID
                                  FROM EXMA_PRODUCTIONPLAN
                                  WHERE EXMA_PRODUCTION_ID = p_Production_ID)
      AND NOT EXISTS (SELECT 1 FROM EXMA_PRODUCTIONLINE pl, EXMA_PRODUCTIONPLAN pp
                      WHERE pl.EXMA_PRODUCTIONPLAN_ID = pp.EXMA_PRODUCTIONPLAN_ID
                        AND pp.EXMA_PRODUCTION_ID = p_Production_ID
                        AND pl.PRODUCTIONTYPE = '+'
                        AND pl.CALCULATED = 'N'
                        AND pl.M_PRODUCT_ID = EXMA_PRODUCTIONLINE.M_PRODUCT_ID); */
    v_count := 0;
    
    IF (v_count > 0) THEN
			      -- Costing engine migrated
			      SELECT MAX(pr.ad_client_id), MAX(pr.ad_org_id), MAX(pr.movementdate), MAX(trxprocessdate), COUNT (*), MAX(pr.DOCUMENTNO)
			      INTO v_Client_ID, v_Org_ID, v_ProductionDate, v_CostingDate, v_count, v_ProductionNo
			      FROM EXMA_PRODUCTION pr, EXMA_PRODUCTIONLINE pl
				LEFT JOIN M_TRANSACTION t ON t.EM_EXMA_productionline_id = pl.EXMA_productionline_id
				, EXMA_PRODUCTIONPLAN pp
			      WHERE pr.EXMA_production_id = p_Production_ID
				AND pr.EXMA_production_id = pp.EXMA_production_id
				AND pp.EXMA_productionplan_id = pl.EXMA_productionplan_id;
			      v_costingdate := COALESCE(v_costingdate, v_productiondate);
		    ELSE
			      -- Costing engine not migrated
			      SELECT MAX(pr.ad_client_id), MAX(pr.ad_org_id), MAX(movementdate), MAX(movementdate), COUNT (*), MAX(pr.DOCUMENTNO)
			      INTO v_Client_ID, v_Org_ID, v_ProductionDate, v_CostingDate, v_count, v_ProductionNo
			      FROM EXMA_PRODUCTION pr, EXMA_PRODUCTIONLINE pl, EXMA_PRODUCTIONPLAN pp
			      WHERE pr.EXMA_production_id = p_Production_ID
				AND pr.EXMA_production_id = pp.EXMA_production_id
				AND pp.EXMA_productionplan_id = pl.EXMA_productionplan_id
				AND pl.calculated = 'N';
		    END IF;

    FOR Cur_ProductionPlan IN (SELECT pp.EXMA_ProductionPlan_ID, pp.exma_costcenter_version_id,
						                SUM(CASE pl.productiontype WHEN '+' THEN (mp.weight * pl.movementqty)
						                    ELSE 0 END) AS ProducedKG,
						                SUM(CASE pl.productiontype WHEN '+' THEN ROUND(pl.EM_Cwpm_Actualqty,3) --pl.movementqty
						                    ELSE 0 END) AS ProducedUd,
						                SUM(CASE pl.productiontype WHEN '+' THEN ROUND(pl.movementqty,3) 
						                    ELSE 0 END) AS ProducedUd_1,
						            --     SUM(CASE pl.productiontype WHEN '+' THEN COALESCE(wrpp.ComponentCost,1) ELSE 0 END) AS CompCostSum,
						                 ccv.costuom, ccv.COST, pp.EXMA_CostCenterUse, pp.EXMA_WRPHASE_ID, pp.LINE,pp.Productionplandate
						          FROM EXMA_PRODUCTIONPLAN pp INNER JOIN EXMA_PRODUCTIONLINE pl ON pp.EXMA_productionplan_id = pl.EXMA_productionplan_id
						                                                                 AND pp.EXMA_production_id = p_Production_ID
						                                   INNER JOIN M_PRODUCT mp ON pl.m_product_id = mp.m_product_id
						                                   LEFT JOIN EXMA_COSTCENTER_VERSION ccv ON ccv.EXMA_COSTCENTER_VERSION_ID = pp.exma_costcenter_version_id
						                                   LEFT JOIN EXMA_WRPHASE wrp ON wrp.exma_wrphase_id = pp.exma_wrphase_id
						                                   LEFT JOIN EXMA_WRPHASEPRODUCT wrpp ON wrp.exma_wrphase_id = wrpp.exma_wrphase_id
						           AND wrpp.m_product_id = pl.m_product_id
						          
						            AND pp.EXMA_COSTCENTER_VERSION_ID IS NOT NULL
						            AND pl.movementqty <> 0
						         GROUP BY pp.EXMA_ProductionPlan_ID, pp.exma_costcenter_version_id, ccv.costuom,
						                   ccv.COST, pp.EXMA_CostCenterUse, pp.EXMA_WRPHASE_ID, pp.LINE
						                   ) LOOP --LL1


						                   --raise exception '% here',v_count; 
        v_ResultStr := 'Common variables';
        v_Productioncost := 0;
        v_ProducedKg := Cur_ProductionPlan.ProducedKG;
        v_ProducedUd := Cur_ProductionPlan.ProducedUd; ---sum of p+(Actual_produced) products
        v_ProducedUd_1 := Cur_ProductionPlan.ProducedUd_1; ---sum of p+(Planned_produced) products
          --Firstly calculate common costs of the production plan.
       -- v_ProductionTime := Cur_ProductionPlan.EXMA_CostCenterUse;
        --v_CompCostSum := Cur_ProductionPlan.CompCostSum;

        --Check that the products in production run exist in the correspondent work requirement.
        --This is not mandatory but might result in problems later.
		IF (Cur_ProductionPlan.EXMA_WRPHASE_ID IS NOT NULL) THEN
		SELECT COUNT(*) INTO v_Count2
		FROM EXMA_PRODUCTIONLINE
		WHERE EXMA_PRODUCTIONPLAN_ID = Cur_ProductionPlan.EXMA_ProductionPlan_ID
		  AND NOT EXISTS (SELECT 1 FROM EXMA_WRPHASEPRODUCT
		                  WHERE M_PRODUCT_ID = EXMA_PRODUCTIONLINE.M_PRODUCT_ID
		                    AND EXMA_WRPHASE_ID = Cur_ProductionPlan.EXMA_WRPHASE_ID);
		  IF (v_Count2 <> 0) THEN
		    --v_Message := '@inProductionPlan@' || v_ProductionNo || ' - ' || Cur_ProductionPlan.LINE || '@productsNotInWRPhase@';
		  END IF;
		END IF;


			v_ResultStr := 'Raw Material cost';
			v_ProductionCost_Tmp := 0; 
			v_ProductionCost_Tmp1 := 0; 
			RM_ACTUALCOST :=0 ;
			RM_PLANNEDCOST := 0;
			V_COUNT := 0;
			v_ProductionCost:= 0;
			v_ProductionCost1 := 0;

	FOR Cur_RawMaterial IN (
			select ROUND(PPL.EM_Cwpm_Actualqty,3) AS PLANNEDQTY, ROUND(ppl.MOVEMENTQTY,3)  as ACTUALQTY, ppl.EXMA_PRODUCTIONLINE_ID, ppl.M_PRODUCT_ID,  
			pc.name as category, P.NAME as pname, ppl.AD_ORG_ID,
			ppl.CreatedBy,ppl.UpdatedBy, ppl.M_Locator_ID,ppl.M_AttributeSetInstance_ID,ppl.PRODUCTIONTYPE,ppl.m_product_uom_id,
			ppl.QUANTITYORDER,ppl.c_uom_id
			from   EXMA_PRODUCTIONLINE ppl 
			LEFT JOIN M_Product p ON  ppl.M_PRODUCT_ID = P.M_PRODUCT_ID
			LEFT JOIN M_Product_Category PC ON P.M_Product_Category_ID = PC.M_Product_Category_ID
			WHERE ppl.PRODUCTIONTYPE = '-'
			AND ppl.EXMA_PRODUCTIONPLAN_ID = Cur_ProductionPlan.EXMA_PRODUCTIONPLAN_ID) LOOP --L2


			SELECT count(*) into v_count  FROM M_COSTING c 
			WHERE (c.COSTTYPE = (CASE WHEN (SELECT COUNT(1) FROM M_PRODUCT WHERE M_PRODUCT_ID = Cur_RawMaterial.M_PRODUCT_ID AND PRODUCTTYPE = 'I' 
			AND ISSTOCKED = 'Y') > 0 THEN 'AVA' END))
			AND C.M_PRODUCT_ID = Cur_RawMaterial.M_PRODUCT_ID 
			AND C.AD_ORG_ID = Cur_RawMaterial.AD_ORG_ID
			group by c.updated 
			order by c.updated desc limit 1;


			IF ( V_COUNT = 0 ) THEN

			   select count(*) into v_costcount from m_transaction where upper(iscostcalculated) = 'N' and m_product_id = Cur_RawMaterial.M_PRODUCT_ID;
				--raise exception '% c', v_costcount;
			   IF(v_costcount > 0) THEN
				v_Message := 'NO COST DEFINED FOR RAW MATERIAL PRODUCT';
				raise exception '%', v_Message|| Cur_RawMaterial.pname ;
			    END IF;
			ELSE

			SELECT (c.COST * Cur_RawMaterial.PLANNEDQTY), (c.COST * Cur_RawMaterial.ACTUALQTY) INTO RM_PLANNEDCOST, RM_ACTUALCOST  FROM M_COSTING c 
			WHERE (c.COSTTYPE = (CASE WHEN (SELECT COUNT(1) FROM M_PRODUCT WHERE M_PRODUCT_ID = Cur_RawMaterial.M_PRODUCT_ID AND PRODUCTTYPE = 'I' 
			AND ISSTOCKED = 'Y') > 0 THEN 'AVA' END))
			AND C.M_PRODUCT_ID = Cur_RawMaterial.M_PRODUCT_ID 
			AND C.AD_ORG_ID = Cur_RawMaterial.AD_ORG_ID
			order by c.updated desc limit 1;

			--IF (RM_PLANNEDCOST = 0 OR RM_ACTUALCOST = 0 ) THEN 
	

		select COALESCE(sum(MovementQty),0) into v_cumQty from m_transaction where m_product_id = Cur_RawMaterial.m_product_id 
		and ad_org_id = Cur_RawMaterial.ad_org_id and iscostcalculated = 'Y';


		select COALESCE(sum(Cost),0) into v_avgPosCost from m_transaction_cost where m_transaction_id 
		in(select m_transaction_id from m_transaction
		where m_transaction.m_product_id = Cur_RawMaterial.m_product_id 
		and ad_org_id = Cur_RawMaterial.ad_org_id and iscostcalculated = 'Y' and MovementQty > 0);

		
		select COALESCE(sum(Cost),0) into v_avgNegCost from m_transaction_cost where m_transaction_id 
		in(select m_transaction_id from m_transaction
		where m_transaction.m_product_id = Cur_RawMaterial.m_product_id 
		and ad_org_id = Cur_RawMaterial.ad_org_id and iscostcalculated = 'Y' and MovementQty < 0);


		--raise exception '%, % ', v_avgCost, v_cumQty;
		RM_ACTUALCOST = COALESCE(v_avgPosCost,0) - COALESCE(v_avgNegCost,0);

	        RM_ACTUALCOST = COALESCE(RM_ACTUALCOST/v_cumQty,0);


		RM_PLANNEDCOST = COALESCE(Cur_RawMaterial.PLANNEDQTY,0) * COALESCE(RM_ACTUALCOST,0);

		RM_ACTUALCOST = COALESCE(Cur_RawMaterial.ACTUALQTY,0) * COALESCE(RM_ACTUALCOST,0);



		

		--raise exception '%, % ', RM_ACTUALCOST, RM_PLANNEDCOST;
			--IF (RM_ACTUALCOST = 0 ) THEN	
			--raise exception '% d, ', v_costcount;		
			   select count(*) into v_costcount from m_transaction where iscostcalculated = 'N' and m_product_id = Cur_RawMaterial.M_PRODUCT_ID;

			

			  /* IF(v_costcount > 0) THEN
				v_Message := 'NO COST DEFINED FOR RAW MATERIAL PRODUCT';
				raise exception '%', v_Message|| Cur_RawMaterial.pname ;
			    END IF;*/
			--ELSE
				
				  v_ProductionCost_Tmp := v_ProductionCost_Tmp + COALESCE(round(RM_ACTUALCOST,2),0);
				  v_ProductionCost_Tmp1 := v_ProductionCost_Tmp1 + COALESCE(round(RM_PLANNEDCOST,2),0);
			  PERFORM CWPM_LOG_INSERTION(v_Client_ID, v_Org_ID,V_PRODUCTIONPLAN_ID,'RM_PLANNEDCOST',RM_PLANNEDCOST ,'description','cwct_production_costcalcul');
	  			  PERFORM CWPM_LOG_INSERTION(v_Client_ID, v_Org_ID,V_PRODUCTIONPLAN_ID,'RM_ACTUALCOST',RM_ACTUALCOST ,'description','cwct_production_costcalcul');



	

------Added by jhansi

    IF (RM_PLANNEDCOST < 0) THEN

           select EM_Exs_Is_Pack into v_IsPackagingMateria from m_product where m_product_id = Cur_RawMaterial.m_product_id ;

       IF (v_IsPackagingMateria = 'Y') THEN 

                 RM_PLANNEDCOST := 0;


               ELSE 

                 v_Message := 'Taking Negative Cost For The Product : ';
		 raise exception '%', v_Message|| Cur_RawMaterial.pname ;

	END IF;

     END IF;


    IF (RM_ACTUALCOST < 0) THEN

                   select EM_Exs_Is_Pack into v_IsPackagingMateria from m_product where m_product_id = Cur_RawMaterial.m_product_id ;

           IF (v_IsPackagingMateria = 'Y') THEN 

                 RM_ACTUALCOST := 0;


                 ELSE 

			v_Message := 'Taking Negative Cost For The Product : ';
				raise exception '%', v_Message|| Cur_RawMaterial.pname ;


            END IF;

     END IF;

		


-----Ended by jhansi


				  UPDATE EXMA_PRODUCTIONLINE
				  SET calccost = COALESCE(round(RM_PLANNEDCOST,2), 0), 
				  EM_Cwct_Actualcost = COALESCE(round(RM_ACTUALCOST,2), 0), 
				  EM_Cwpf_Cost_Uom = 'TC',CALCULATED='Y'
				  WHERE EXMA_PRODUCTIONLINE_ID = Cur_RawMaterial.EXMA_PRODUCTIONLINE_ID;


--Added by jhansi for transaction insertion for p- products to avoid stock ledger issue

	-- Only insert in M_TRANSACTION if MovementQty <> 0
        IF Cur_RawMaterial.ACTUALQTY <> 0 THEN
          -- Create Transaction Entry        
           v_ResultStr:='CreateTransaction';
          SELECT * INTO  v_NextNo FROM Ad_Sequence_Next('M_Transaction', v_Org_ID) ;
          INSERT
          INTO M_TRANSACTION
            (
              M_Transaction_ID, EM_EXMA_ProductionLine_ID, AD_Client_ID, AD_Org_ID,
              IsActive, Created, CreatedBy, Updated,
              UpdatedBy, MovementType, M_Locator_ID, M_Product_ID,
              M_AttributeSetInstance_ID, MovementDate, MovementQty, M_Product_UOM_ID,
              QuantityOrder, C_UOM_ID
            )
            VALUES
            (
              v_NextNo, Cur_RawMaterial.EXMA_ProductionLine_ID, v_Client_ID, v_Org_ID,
              'Y', TO_DATE(NOW()), Cur_RawMaterial.CreatedBy, TO_DATE(NOW()),
              Cur_RawMaterial.UpdatedBy, 'P-', Cur_RawMaterial.M_Locator_ID, Cur_RawMaterial.M_Product_ID,
              COALESCE(Cur_RawMaterial.M_AttributeSetInstance_ID, '0'), -- not distinguishing between assemby/disassembly
              Cur_ProductionPlan.Productionplandate,(CASE Cur_RawMaterial.PRODUCTIONTYPE WHEN '+' THEN Cur_RawMaterial.ACTUALQTY ELSE -Cur_RawMaterial.ACTUALQTY END), Cur_RawMaterial.M_Product_UOM_ID,
              (CASE Cur_RawMaterial.PRODUCTIONTYPE WHEN '+' THEN Cur_RawMaterial.QUANTITYORDER ELSE -Cur_RawMaterial.QuantityOrder END), Cur_RawMaterial.C_UOM_ID
            )
            ;
          END IF;


INSERT INTO M_TRANSACTION_COST
( m_transaction_cost_id,ad_client_id ,ad_org_id ,created ,createdby,updated ,updatedby,isactive ,
m_transaction_id,cost,costdate ,c_currency_id,m_costadjustmentline_id, isunitcost,dateacct)
VALUES
(get_uuid(),v_Client_ID, v_Org_ID,TO_DATE(NOW()),  Cur_RawMaterial.CreatedBy, TO_DATE(NOW()),Cur_RawMaterial.UpdatedBy,'Y',
v_NextNo,COALESCE(round(RM_ACTUALCOST,2), 0),TO_DATE(NOW()),'304',null,'Y',TO_DATE(NOW()));

  UPDATE M_TRANSACTION 
      SET iscostcalculated='Y',transactioncost=COALESCE(round(RM_ACTUALCOST,2), 0),c_currency_id='304'
      WHERE m_transaction_id=v_NextNo;
     
--Ended by jhansi for transaction insertion for p- products to avoid stock ledger issue
	
				  

			--END IF;
 
			END IF;  

			
	END LOOP; --L2


	v_ProductionCost := v_ProductionCost + COALESCE(v_ProductionCost_Tmp,0);  --sum of all p-(ACTUAL_COST)
	v_ProductionCost1 := v_ProductionCost1 + COALESCE(v_ProductionCost_Tmp1,0);  --sum of all p-(ESTIMATED_COST)
 
                        


    
			----Indirect Cost Calculation based on CostConfiguration
			v_ResultStr := 'INDIRECT COST';
			SELECT EM_CWPF_EXMA_CostCenter_ID INTO V_EXMA_CostCenter_ID FROM EXMA_WorkRequirement
			LEFT JOIN EXMA_Production ON EXMA_WorkRequirement.EXMA_WorkRequirement_ID = EXMA_Production.EXMA_WorkRequirement_ID 
			LEFT JOIN EXMA_ProductionPlan ON EXMA_Production.EXMA_Production_ID = EXMA_ProductionPlan.EXMA_Production_ID
			WHERE EXMA_ProductionPlan.EXMA_Production_ID = p_Production_ID; --'A1F07E35D07C4886944AE97D7C499815'





			v_ProductionCost_Tmp := 0; 
			v_ProductionCost_Tmp1 := 0;
			V_MOVEMENTQTY := 0;
			V_ESTIMATEDCOST := 0;
			V_COUNT := 0;
			

			SELECT  COUNT(*) INTO V_COUNT FROM CWCT_COSTCONFIG
						      LEFT JOIN EXMA_Indirect_Cost_Value ON  CWCT_COSTCONFIG.EXMA_Indirect_Cost_ID = EXMA_Indirect_Cost_Value.EXMA_Indirect_Cost_ID 
						      WHERE CWCT_COSTCONFIG.EXMA_CostCenter_ID = V_EXMA_CostCenter_ID -- '331F8123439645A7B8D5A948D7E85DEC' --
						   --   AND EXMA_Indirect_Cost_Value.DATEFROM < TO_DATE(v_ProductionDate)
						   --    AND EXMA_Indirect_Cost_Value.DATETO > TO_DATE(v_ProductionDate)
						      GROUP BY CWCT_COSTCONFIG.exma_indirect_cost_id, cwct_costconfig.plannedqty, cwct_costconfig.exempted, 
						      cwct_costconfig.m_product_category_id, exma_indirect_cost_value.cost,exma_indirect_cost_value.cost_uom;
						      



			IF (V_COUNT = 0) THEN --COUNT

			v_Message:= 'COST IS NOT CONFIGURED IN COST CONFIGURATION WINDOW';

			RAISE EXCEPTION '%',v_Message;


			ELSE --COUNT

						FOR Cur_CostConfiguration IN (SELECT CWCT_COSTCONFIG.EXMA_Indirect_Cost_ID,plannedqty, exempted, M_Product_Category_ID,  
						      EXMA_Indirect_Cost_Value.COST, EXMA_Indirect_Cost_Value.Cost_Uom  
						      FROM CWCT_COSTCONFIG
						      LEFT JOIN EXMA_Indirect_Cost_Value ON  CWCT_COSTCONFIG.EXMA_Indirect_Cost_ID = EXMA_Indirect_Cost_Value.EXMA_Indirect_Cost_ID 
						      WHERE CWCT_COSTCONFIG.EXMA_CostCenter_ID = V_EXMA_CostCenter_ID -- '331F8123439645A7B8D5A948D7E85DEC' --
						  --    AND EXMA_Indirect_Cost_Value.DATEFROM <= TO_DATE(v_ProductionDate)
						  --  AND EXMA_Indirect_Cost_Value.DATETO > TO_DATE(v_ProductionDate)
						      ) LOOP  --Indirect --LL3

						      
				IF (Cur_CostConfiguration.plannedqty = 'Y') THEN  -------plannedqty 'Y' 
	 	  			  PERFORM CWPM_LOG_INSERTION(v_Client_ID, v_Org_ID,V_PRODUCTIONPLAN_ID,'coalesce(ROUND(Cur_CostConfiguration.COST * v_ProducedUd_1,2),0)',coalesce(ROUND(Cur_CostConfiguration.COST * v_ProducedUd_1,2),0) ,'description','cwct_production_costcalcul');
	 	  			  PERFORM CWPM_LOG_INSERTION(v_Client_ID, v_Org_ID,V_PRODUCTIONPLAN_ID,'coalesce(ROUND(Cur_CostConfiguration.COST * v_ProducedUd,2),0)',coalesce(ROUND(Cur_CostConfiguration.COST * v_ProducedUd,2),0) ,'description','cwct_production_costcalcul');

				UPDATE EXMA_PL_IC
				SET CALCCOST = coalesce(ROUND(Cur_CostConfiguration.COST * v_ProducedUd_1,2),0), 
				    em_cwct_actualcost = coalesce(ROUND(Cur_CostConfiguration.COST * v_ProducedUd,2),0)
				WHERE EXMA_Indirect_Cost_ID = Cur_CostConfiguration.EXMA_Indirect_Cost_ID
				and EXMA_PRODUCTIONPLAN_ID = Cur_ProductionPlan.EXMA_PRODUCTIONPLAN_ID;



				ELSE
					IF ( Cur_CostConfiguration.exempted = 'N' ) THEN   ----exempted 'N'


					        select ROUND(sum(ppl.EM_Cwpm_Actualqty) ,3), ROUND( sum(ppl.MOVEMENTQTY) ,3) 
						INTO V_ESTIMATEDCOST, V_MOVEMENTQTY 
						from   EXMA_PRODUCTIONLINE ppl 
						LEFT JOIN M_Product p ON  ppl.M_PRODUCT_ID = P.M_PRODUCT_ID
						WHERE ppl.PRODUCTIONTYPE = '-'
						AND ppl.EXMA_PRODUCTIONPLAN_ID = Cur_ProductionPlan.EXMA_PRODUCTIONPLAN_ID
						AND P.M_Product_Category_ID = Cur_CostConfiguration.M_Product_Category_ID; --) LOOP --L4
							
					 v_ProductionCost_Tmp := v_ProductionCost_Tmp + COALESCE(V_MOVEMENTQTY,0);
					 v_ProductionCost_Tmp1 := v_ProductionCost_Tmp1 + COALESCE(V_ESTIMATEDCOST,0);
					 
   PERFORM CWPM_LOG_INSERTION(v_Client_ID, v_Org_ID,V_PRODUCTIONPLAN_ID,'coalesce(ROUND(Cur_CostConfiguration.COST * v_ProductionCost_Tmp1,2),0)',coalesce(ROUND(Cur_CostConfiguration.COST * v_ProductionCost_Tmp1,2),0),'description','cwct_production_costcalcul');
   PERFORM CWPM_LOG_INSERTION(v_Client_ID, v_Org_ID,V_PRODUCTIONPLAN_ID,'coalesce(ROUND(Cur_CostConfiguration.COST * v_ProductionCost_Tmp,2),0)',coalesce(ROUND(Cur_CostConfiguration.COST * v_ProductionCost_Tmp,2),0),'description','cwct_production_costcalcul');
			 
					 
					UPDATE EXMA_PL_IC
					SET CALCCOST = coalesce(ROUND(Cur_CostConfiguration.COST * v_ProductionCost_Tmp1,2),0), 
					    em_cwct_actualcost = coalesce(ROUND(Cur_CostConfiguration.COST * v_ProductionCost_Tmp,2),0)
					WHERE EXMA_Indirect_Cost_ID = Cur_CostConfiguration.EXMA_Indirect_Cost_ID
					and EXMA_PRODUCTIONPLAN_ID = Cur_ProductionPlan.EXMA_PRODUCTIONPLAN_ID;

					END IF; ----exempted 'N'

			END IF;-------plannedqty 'Y'

  		END LOOP;  --Indirect --LL3
     END IF; --COUNT

  ----COST CALCULATION OF P+(PRODUCED) PRODUCT


	v_ProductionCost_Tmp := 0;
	v_Cost:= 0;
	v_Cost1 := 0;				
	V_COUNT := 0;
	V_INDIRECTESTIMATED_COST := 0;
        V_INDIRECTACTUAL_COST := 0;

        
        FOR Cur_ProductionLine IN (SELECT pl.*, p.VALUE, count(*)  AS V_COUNT
                                   FROM EXMA_PRODUCTIONLINE pl, M_PRODUCT p
                                   WHERE EXMA_ProductionPlan_ID = Cur_ProductionPlan.EXMA_ProductionPlan_ID
                                     AND pl.M_Product_ID = p.M_Product_ID
                                     AND pl.CALCULATED = 'N'
                                     AND productiontype = '+'
                                     AND pl.MOVEMENTQTY <> 0
                                     group by pl.exma_productionline_id, p.VALUE
                                    ) LOOP  --LL4


					IF (Cur_ProductionLine.V_COUNT = 0 ) THEN  --C1

					v_Message := 'P+ PRODUCT NOT CONFIGURED IN PROCESS PLAN';

					RAISE EXCEPTION '%',v_Message;

					ELSE 

               -------------Added by jhansi for pheonix wastage p+ standard product by jhansi

                                SELECT PO.em_cwct_isstandard, PO.em_cwct_standardcost INTO V_ISSTANDARD, V_standardcost 
				FROM M_PRODUCT_ORG PO
				WHERE PO.M_PRODUCT_ID = Cur_ProductionLine.M_PRODUCT_ID
				AND PO.AD_ORG_ID = Cur_ProductionLine.AD_ORG_ID;

				IF(V_ISSTANDARD = 'Y') THEN  --IF1


		    PERFORM CWPM_LOG_INSERTION(v_Client_ID, v_Org_ID ,V_PRODUCTIONPLAN_ID,'round(COALESCE((V_standardcost * Cur_ProductionLine.MOVEMENTQTY),0),2) ',round(COALESCE((V_standardcost * Cur_ProductionLine.MOVEMENTQTY),0),2) ,'description','cwct_farmprductn_layingcostcal');

							       UPDATE EXMA_PRODUCTIONLINE
							       SET CALCCOST = round(COALESCE((V_standardcost * Cur_ProductionLine.MOVEMENTQTY),0),2) ,
							       EM_CWCT_ACTUALCOST= round(COALESCE((V_standardcost * Cur_ProductionLine.Movementqty),0),2),
							       EM_Cwpf_Cost_Uom = 'TC' , CALCULATED='Y'
							       WHERE EXMA_PRODUCTIONLINE_ID = Cur_ProductionLine.EXMA_ProductionLine_ID
							       AND EXMA_ProductionPlan_ID= Cur_ProductionLine.EXMA_ProductionPlan_ID;
		 
					ELSE  ---IF(V_ISSTANDARD = 'Y') THEN



               -------------Ended by jhansi for pheonix wastage p+ standard product by jhansi

					

					SELECT coalesce(SUM(CALCCOST),0), coalesce(SUM(em_cwct_actualcost),0) INTO V_INDIRECTESTIMATED_COST, V_INDIRECTACTUAL_COST FROM EXMA_PL_IC
					WHERE EXMA_PRODUCTIONPLAN_ID = Cur_ProductionPlan.EXMA_PRODUCTIONPLAN_ID;
--raise exception 'V_INDIRECTACTUAL_COST===%,%',V_INDIRECTESTIMATED_COST,V_INDIRECTACTUAL_COST;

					v_Cost:= v_Cost + COALESCE(v_ProductionCost,0)  --RAW MATERIAL ACTUAL_COST
							  +COALESCE(V_INDIRECTACTUAL_COST,0) ; -- Indirect COST
							  
					v_Cost1:= v_Cost1 + COALESCE(v_ProductionCost1,0)  --RAW MATERIAL ESTIMATED_COST
							  +COALESCE(V_INDIRECTESTIMATED_COST,0) ; -- Indirect COST

   PERFORM CWPM_LOG_INSERTION(v_Client_ID, v_Org_ID,V_PRODUCTIONPLAN_ID,'v_Cost1',v_Cost1,'description','cwct_production_costcalcul');
   PERFORM CWPM_LOG_INSERTION(v_Client_ID, v_Org_ID,V_PRODUCTIONPLAN_ID,'v_Cost',v_Cost,'description','cwct_production_costcalcul');

					    UPDATE EXMA_PRODUCTIONLINE
					    SET CALCCOST = ROUND(v_Cost1,2),  --ROUND(v_Cost1/Cur_ProductionLine.EM_Cwpm_Actualqty,3), 
					    EM_CWCT_ACTUALCOST= ROUND(v_Cost,2), ---ROUND(v_Cost/Cur_ProductionLine.MOVEMENTQTY,3), 
					    EM_Cwpf_Cost_Uom = 'TC' , CALCULATED='Y'
					    WHERE EXMA_PRODUCTIONLINE_ID = Cur_ProductionLine.EXMA_ProductionLine_ID;

                             END IF;--IF(V_ISSTANDARD = 'Y') THEN

		v_ResultStr := 'insert cost';
		v_McostingCount := 0;
		v_avgCost := 0;
		v_cumQty := 0;
		v_newCumQty := 0;
		v_oldQtyCost := 0;
		v_presentQtyCost := 0;
		v_finalAvgCost := 0;


		select count(*) into v_McostingCount from m_costing 
		where m_product_id = Cur_ProductionLine.m_product_id
		and ad_org_id = Cur_ProductionLine.AD_ORG_ID;

		IF (v_McostingCount IS NULL AND v_McostingCount= 0) THEN --M_COST

			  SELECT * INTO  v_NextNo FROM Ad_Sequence_Next('M_Costing', Cur_ProductionLine.AD_ORG_ID);
			  INSERT INTO M_COSTING (M_COSTING_ID, CREATED, CREATEDBY, UPDATED, UPDATEDBY, AD_CLIENT_ID,
								    AD_ORG_ID, M_PRODUCT_ID, DATETO, DATEFROM, ISMANUAL,
								    EM_EXMA_PRODUCTIONLINE_ID, QTY,
								    PRICE,  CUMQTY,
								    COST, ISPERMANENT, ISPRODUCTION, COSTTYPE,em_cwct_totalcost)
							     VALUES (v_NextNo,TO_DATE(NOW()), p_User_ID, TO_DATE(NOW()), p_User_ID, Cur_ProductionLine.AD_CLIENT_ID,
								    Cur_ProductionLine.AD_ORG_ID, Cur_ProductionLine.M_PRODUCT_ID, TO_DATE('31-12-9999','DD-MM-YYYY'), v_CostingDate, 'N',
								    Cur_ProductionLine.EXMA_PRODUCTIONLINE_ID, ROUND(Cur_ProductionLine.MOVEMENTQTY,3),
								    ROUND(v_Cost/(ROUND(Cur_ProductionLine.MOVEMENTQTY,3)),2), COALESCE(v_Qty,0) + ROUND(Cur_ProductionLine.MOVEMENTQTY,3),
								    (CASE (ROUND(Cur_ProductionLine.MOVEMENTQTY,3)) WHEN 0 THEN 0 ELSE ROUND(v_Cost/(ROUND(Cur_ProductionLine.MOVEMENTQTY,3)),2) END), 
								    'N', 'Y', 'AVA', v_Cost);

		ELSE --M_COST


			select cost,cumqty INTO v_avgCost,v_cumQty 
			from m_costing 
			where m_product_id = Cur_ProductionLine.m_product_id
			and ad_org_id = Cur_ProductionLine.ad_org_id
			order by updated desc limit 1;

			v_newCumQty := coalesce(v_cumQty,0) + ROUND(Cur_ProductionLine.MOVEMENTQTY,3);
			v_oldQtyCost :=  ROUND(coalesce(v_avgCost,0) * coalesce(v_cumQty,0),2);
			v_presentQtyCost := v_Cost;
			v_finalAvgCost := ROUND((coalesce(v_oldQtyCost,0) + coalesce(v_Cost,0)) / coalesce(v_newCumQty,0),2);
			

			  SELECT * INTO  v_NextNo FROM Ad_Sequence_Next('M_Costing', Cur_ProductionLine.AD_ORG_ID);
			  INSERT INTO M_COSTING (M_COSTING_ID, CREATED, CREATEDBY, UPDATED, UPDATEDBY, AD_CLIENT_ID,
								    AD_ORG_ID, M_PRODUCT_ID, DATETO, DATEFROM, ISMANUAL,
								    EM_EXMA_PRODUCTIONLINE_ID, QTY,
								    PRICE,  CUMQTY,
								    COST, ISPERMANENT, ISPRODUCTION, COSTTYPE,em_cwct_totalcost)
							     VALUES (v_NextNo,TO_DATE(NOW()), p_User_ID, TO_DATE(NOW()), p_User_ID, Cur_ProductionLine.AD_CLIENT_ID,
								    Cur_ProductionLine.AD_ORG_ID, Cur_ProductionLine.M_PRODUCT_ID, TO_DATE('31-12-9999','DD-MM-YYYY'), v_CostingDate, 'N',
								    Cur_ProductionLine.EXMA_PRODUCTIONLINE_ID, ROUND(Cur_ProductionLine.MOVEMENTQTY,3),
								    ROUND(v_Cost/(ROUND(Cur_ProductionLine.MOVEMENTQTY,3)),2), COALESCE(v_newCumQty,0),
								    --(CASE (ROUND(Cur_ProductionLine.MOVEMENTQTY,3)) WHEN 0 THEN 0 ELSE ROUND(v_Cost/(ROUND(Cur_ProductionLine.MOVEMENTQTY,3)),2) END),
								     coalesce(v_finalAvgCost,0), 'N', 'Y', 'AVA',v_Cost);


		END IF; --M_COST

		

	v_salescost := ROUND(v_Cost/(ROUND(Cur_ProductionLine.MOVEMENTQTY,3)),2);
			

						      

	END IF; --C1
    END LOOP; --LL4
  	END LOOP; --LL1
				
--END IF; --ISMANUAL

--pavan logic for sales order

	select exma_workrequirement_id INTO v_workreq from exma_production where exma_production_id = p_Production_ID;
	select EM_Exsf_C_Order_ID, Launchdate,em_cwct_c_orderline_id into v_salesorder, v_launchdate, v_salesorderline_id from exma_workrequirement where exma_workrequirement_id = v_workreq;
	if(v_salesorder is not null) then

	/*	select m_pricelist_id into v_pricelist from c_order where c_order_id = v_salesorder;
		if(v_pricelist is not null) then

			select STD_Margin into v_margin from M_DiscountSchemaLine where M_DiscountSchema_ID in 
			(select M_DiscountSchema_ID from m_pricelist_version where m_pricelist_id = v_pricelist and 
			TO_DATE(ValidFrom) >= to_char(v_launchdate,'ddmmyyyy'));

			v_margin_cost := 0;
			if(v_margin is not null) then

				v_margin_cost =	(v_salescost * (v_margin/100)) + v_salescost;
				update c_orderline set EM_Exs_Unitprice = v_margin_cost, priceactual = v_margin_cost
				where c_order_id = v_salesorder;

			else

				update c_orderline set EM_Exs_Unitprice = v_salescost, priceactual = v_salescost
				where c_order_id = v_salesorder;

			end if;

		end if;		*/


	--SELECT c_orderline_id into v_salesorderline_id from c_orderline where c_order_id = v_salesorder;

	SELECT exma_productionline_id INTO v_pline_id FROM exma_productionline WHERE EXMA_ProductionPlan_ID = Cur_ProductionPlan.EXMA_ProductionPlan_ID 
	AND productiontype = '+' 
	AND MOVEMENTQTY <> 0; 

	
	SELECT ad_client_id, ad_org_id, createdby, updatedby, m_product_id, c_uom_id, m_attributesetinstance_id,
	movementqty, m_locator_id INTO v_Client_ID1, v_Org_ID1, v_createdby, v_updatedby, v_product_id1, v_uom_id, 
	v_attributesetinstance_id, v_movementqty1, v_locator_id FROM m_transaction where em_exma_productionline_id = v_pline_id;

	SELECT * INTO  v_reservation_id FROM Ad_Sequence_Next('m_reservation', v_Org_ID1);

	INSERT INTO m_reservation(
		m_reservation_id, ad_client_id, ad_org_id, CREATED, CREATEDBY, UPDATED, UPDATEDBY, ISACTIVE, m_product_id, 
		quantity, c_uom_id, m_attributesetinstance_id, m_locator_id, --reservedqty, 
		releasedqty, m_warehouse_id,
		c_bpartner_id, ad_user_id, c_orderline_id
	) 
	VALUES( 
		v_reservation_id, v_Client_ID1, v_Org_ID1, TO_DATE(NOW()), v_createdby, TO_DATE(NOW()), v_updatedby, 'Y',
		v_product_id1, v_movementqty1, v_uom_id, v_attributesetinstance_id, v_locator_id, --v_movementqty1,
		null, null, null, null, v_salesorderline_id
	);

		SELECT * INTO  v_reservation_stock_id FROM Ad_Sequence_Next('m_reservation_stock', v_Org_ID1);


	INSERT INTO m_reservation_stock(
		m_reservation_stock_id, ad_client_id, ad_org_id, CREATED, CREATEDBY, UPDATED, UPDATEDBY, ISACTIVE, 
		m_reservation_id, quantity, m_attributesetinstance_id, releasedqty, m_locator_id, c_orderline_id, isallocated

	) VALUES (
		v_reservation_stock_id, v_Client_ID1, v_Org_ID1, TO_DATE(NOW()), 
		v_createdby, TO_DATE(NOW()), v_updatedby, 'Y', v_reservation_id, v_movementqty1, v_attributesetinstance_id,
		null, v_locator_id, v_salesorderline_id, 'Y'
	);
		

	end if;
	
---PAVAN

-- by pavan
     select EXMA_WORKREQUIREMENT_ID into V_WORKREQUIREMENT_ID from exma_production where exma_production_id = p_Production_ID; 
     if(V_WORKREQUIREMENT_ID IS NOT NULL) THEN
	    update exma_workrequirement set em_cwlg_status = 'VA' where exma_workrequirement_id = V_WORKREQUIREMENT_ID;
    END IF;
-- by pavan


   END IF; --IFCSIMU
		    
 



  END; --BODY
EXCEPTION
  WHEN  OTHERS THEN
    RAISE NOTICE '%','Production: ' || p_Production_ID || ' ERROR AT: ' || v_ResultStr;

    RAISE EXCEPTION '%', SQLERRM;
    RETURN;
END ; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION cwct_production_costcalcul(character varying, character varying)
  OWNER TO tad;


